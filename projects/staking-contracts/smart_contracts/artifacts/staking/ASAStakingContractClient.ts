/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client'
import { ABIReturn, AppReturn, SendAppTransactionResult } from '@algorandfoundation/algokit-utils/types/app'
import { Arc56Contract, getArc56ReturnValue, getABIStructFromABITuple } from '@algorandfoundation/algokit-utils/types/app-arc56'
import {
  AppClient as _AppClient,
  AppClientMethodCallParams,
  AppClientParams,
  AppClientBareCallParams,
  CallOnComplete,
  AppClientCompilationParams,
  ResolveAppClientByCreatorAndName,
  ResolveAppClientByNetwork,
  CloneAppClientParams,
} from '@algorandfoundation/algokit-utils/types/app-client'
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory'
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, SimulateOptions, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer'
import { SendParams, SendSingleTransactionResult, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction'
import { Address, encodeAddress, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk'
import SimulateResponse = modelsv2.SimulateResponse

export const APP_SPEC: Arc56Contract = {"name":"ASAStakingContract","structs":{"UserStakeInfo":[{"name":"stakedAmount","type":"uint64"},{"name":"firstStakeTime","type":"uint64"},{"name":"lastStakeTime","type":"uint64"},{"name":"totalRewardsEarned","type":"uint64"},{"name":"lastClaimedPeriod","type":"uint64"}]},"methods":[{"name":"getUserStakeInfo","args":[{"type":"account","name":"userAddress"}],"returns":{"type":"(uint64,uint64,uint64,uint64,uint64)","struct":"UserStakeInfo"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Helper function to read user stake info from box storage","events":[],"recommendations":{}},{"name":"storeUserStakeInfo","args":[{"type":"account","name":"userAddress"},{"type":"(uint64,uint64,uint64,uint64,uint64)","struct":"UserStakeInfo","name":"stakeInfo"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Helper function to store user stake info in box storage","events":[],"recommendations":{}},{"name":"getCurrentPeriod","args":[],"returns":{"type":"uint64"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Calculate the current distribution period","events":[],"recommendations":{}},{"name":"initialize","args":[{"type":"asset","name":"asset"},{"type":"account","name":"adminAddress"},{"type":"uint64","name":"aprBasisPoints"},{"type":"uint64","name":"distributionPeriodSeconds"},{"type":"uint64","name":"minimumStake"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Initialize the contract with the ASA token ID and other parameters","events":[],"recommendations":{}},{"name":"optInToAsset","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Opt the contract into the ASA","events":[],"recommendations":{}},{"name":"stake","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Stake tokens\nRequires a companion ASA transfer transaction","events":[],"recommendations":{}},{"name":"withdraw","args":[{"type":"uint64","name":"amount"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Withdraw staked tokens","events":[],"recommendations":{}},{"name":"addRewards","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Add rewards to the reward pool\nOnly the admin can call this\nRequires a companion ASA transfer transaction with the rewards","events":[],"recommendations":{}},{"name":"calculateUserRewardsForPeriod","args":[{"type":"account","name":"userAddress"}],"returns":{"type":"uint64"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Calculate rewards for a specific user for a given period\nThis calculates rewards per distribution period","events":[],"recommendations":{}},{"name":"calculatePendingRewards","args":[{"type":"account","name":"userAddress"}],"returns":{"type":"uint64"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Calculate pending rewards for a user since their last claim","events":[],"recommendations":{}},{"name":"distributeRewards","args":[{"type":"address[]","name":"stakerAddresses"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Distribute and compound rewards for multiple stakers\nThis method is designed to be called by a cron job on a daily basis\nOnly admin can call this method","events":[],"recommendations":{}},{"name":"getActiveStakersCount","args":[{"type":"address[]","name":"stakerAddresses"}],"returns":{"type":"uint64"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Get all non-zero stakers count (for monitoring purposes)\nNote: This doesn't return the actual addresses due to box iteration limitations","events":[],"recommendations":{}},{"name":"updateAPR","args":[{"type":"uint64","name":"newAprBasisPoints"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Update the APR basis points\nOnly the admin can call this","events":[],"recommendations":{}},{"name":"updateAdmin","args":[{"type":"account","name":"newAdminAddress"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Update the admin address\nOnly the current admin can call this","events":[],"recommendations":{}},{"name":"getUserStats","args":[{"type":"account","name":"userAddress"}],"returns":{"type":"uint64[]"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Get current staking statistics for a user","events":[],"recommendations":{}},{"name":"getContractStats","args":[],"returns":{"type":"uint64[]"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Get contract global statistics","events":[],"recommendations":{}},{"name":"emergencyWithdrawRewards","args":[{"type":"uint64","name":"amount"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Emergency withdraw rewards from pool (admin only)","events":[],"recommendations":{}},{"name":"deleteUserBox","args":[{"type":"account","name":"userAddress"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Delete a user's box (for cleanup)\nCan only be called by the box owner or admin","events":[],"recommendations":{}}],"arcs":[22,28],"desc":"ASA Staking Contract for Algorand with Auto-Compounding\n\nThis contract allows users to:\n- Stake an ASA token\n- Earn rewards that compound automatically when claimed\n- Add to their stake at any time\n- Withdraw part or all of their stake at any time\n- Rewards are calculated based on APR and distributed from a reward pool\n\nThis implementation uses box storage to store user staking information","networks":{},"state":{"schema":{"global":{"ints":7,"bytes":8},"local":{"ints":0,"bytes":0}},"keys":{"global":{"asset":{"keyType":"AVMString","valueType":"AVMUint64","key":"YXNzZXQ="},"adminAddress":{"keyType":"AVMString","valueType":"address","key":"YWRtaW5BZGRyZXNz"},"totalStaked":{"keyType":"AVMString","valueType":"AVMUint64","key":"dG90YWxTdGFrZWQ="},"aprBasisPoints":{"keyType":"AVMString","valueType":"AVMUint64","key":"YXByQmFzaXNQb2ludHM="},"lastDistributionTime":{"keyType":"AVMString","valueType":"AVMUint64","key":"bGFzdERpc3RyaWJ1dGlvblRpbWU="},"distributionPeriodRounds":{"keyType":"AVMString","valueType":"AVMUint64","key":"ZGlzdHJpYnV0aW9uUGVyaW9kUm91bmRz"},"minimumStake":{"keyType":"AVMString","valueType":"AVMUint64","key":"bWluaW11bVN0YWtl"},"rewardPool":{"keyType":"AVMString","valueType":"AVMUint64","key":"cmV3YXJkUG9vbA=="}},"local":{},"box":{}},"maps":{"global":{},"local":{},"box":{"stakers":{"keyType":"address","valueType":"UserStakeInfo","prefix":"c3Rha2Vycw=="}}}},"bareActions":{"create":["NoOp"],"call":[]},"sourceInfo":{"approval":{"sourceInfo":[{"pc":[778],"errorMessage":"Already initialized"},{"pc":[906,1124],"errorMessage":"Asset transfer must be to contract"},{"pc":[684],"errorMessage":"Box must have value"},{"pc":[883],"errorMessage":"Contract not initialized"},{"pc":[889,1103],"errorMessage":"Expected 2 txns in group"},{"pc":[918,1136],"errorMessage":"Incorrect asset ID"},{"pc":[1358,1515],"errorMessage":"Index access is out of bounds"},{"pc":[942],"errorMessage":"Initial stake below minimum"},{"pc":[1752],"errorMessage":"Insufficient reward pool"},{"pc":[1129],"errorMessage":"Must provide non-zero rewards"},{"pc":[913],"errorMessage":"Must stake non-zero amount"},{"pc":[1008],"errorMessage":"No stake found"},{"pc":[315,333,349,366,389,407,423,444,459,483,507,519,535,547,559,595,613,635],"errorMessage":"OnCompletion is not NoOp"},{"pc":[1097],"errorMessage":"Only admin can add rewards"},{"pc":[1328],"errorMessage":"Only admin can distribute rewards"},{"pc":[1744],"errorMessage":"Only admin can emergency withdraw"},{"pc":[1562],"errorMessage":"Only admin can update APR"},{"pc":[1579],"errorMessage":"Only admin can update admin"},{"pc":[1811],"errorMessage":"Only box owner or admin can delete box"},{"pc":[784],"errorMessage":"Only creator can initialize"},{"pc":[844],"errorMessage":"Only creator or admin can opt in"},{"pc":[1035],"errorMessage":"Remaining stake would be below minimum"},{"pc":[1337],"errorMessage":"Too many stakers in single batch"},{"pc":[899,1117],"errorMessage":"Transaction 0 must be asset transfer"},{"pc":[1820],"errorMessage":"User still has active stake"},{"pc":[1014],"errorMessage":"Withdrawal amount exceeds stake"},{"pc":[1017],"errorMessage":"Withdrawal amount must be positive"},{"pc":[663],"errorMessage":"can only call when creating"},{"pc":[318,336,352,369,392,410,426,447,462,486,510,522,538,550,562,598,616,638],"errorMessage":"can only call when not creating"},{"pc":[756,776,826,848,878,882,923,988,1033,1057,1067,1093,1107,1140,1156,1160,1168,1324,1409,1460,1470,1558,1575,1658,1662,1667,1672,1677,1682,1686,1738,1748,1756,1766,1793],"errorMessage":"check GlobalState exists"},{"pc":[896,1114],"errorMessage":"transaction type is axfer"}],"pcOffsetMethod":"none"},"clear":{"sourceInfo":[],"pcOffsetMethod":"none"}},"source":{"approval":"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDQgMzIKICAgIGJ5dGVjYmxvY2sgInJld2FyZFBvb2wiICJhc3NldCIgImFkbWluQWRkcmVzcyIgInRvdGFsU3Rha2VkIiAweDE1MWY3Yzc1ICJhcHJCYXNpc1BvaW50cyIgImRpc3RyaWJ1dGlvblBlcmlvZFJvdW5kcyIgIm1pbmltdW1TdGFrZSIgImxhc3REaXN0cmlidXRpb25UaW1lIiAic3Rha2VycyIKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBibnogbWFpbl9hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTQKICAgIC8vIHB1YmxpYyBhc3NldCA9IEdsb2JhbFN0YXRlPEFzc2V0Pih7IGluaXRpYWxWYWx1ZTogQXNzZXQoKSB9KQogICAgYnl0ZWNfMSAvLyAiYXNzZXQiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTUKICAgIC8vIHB1YmxpYyBhZG1pbkFkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGluaXRpYWxWYWx1ZTogQWNjb3VudCgpfSkKICAgIGJ5dGVjXzIgLy8gImFkbWluQWRkcmVzcyIKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTYKICAgIC8vIHB1YmxpYyB0b3RhbFN0YWtlZCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIGJ5dGVjXzMgLy8gInRvdGFsU3Rha2VkIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU3CiAgICAvLyBwdWJsaWMgYXByQmFzaXNQb2ludHMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICBieXRlYyA1IC8vICJhcHJCYXNpc1BvaW50cyIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1OAogICAgLy8gcHVibGljIGxhc3REaXN0cmlidXRpb25UaW1lID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgYnl0ZWMgOCAvLyAibGFzdERpc3RyaWJ1dGlvblRpbWUiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTkKICAgIC8vIHB1YmxpYyBkaXN0cmlidXRpb25QZXJpb2RSb3VuZHMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICBieXRlYyA2IC8vICJkaXN0cmlidXRpb25QZXJpb2RSb3VuZHMiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjAKICAgIC8vIHB1YmxpYyBtaW5pbXVtU3Rha2UgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICBieXRlYyA3IC8vICJtaW5pbXVtU3Rha2UiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjEKICAgIC8vIHB1YmxpYyByZXdhcmRQb29sID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgYnl0ZWNfMCAvLyAicmV3YXJkUG9vbCIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAoKbWFpbl9hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjUyLTUzCiAgICAvLyBAY29udHJhY3QoeyBzdGF0ZVRvdGFsczogeyBnbG9iYWxCeXRlczogOCB9IH0pCiAgICAvLyBleHBvcnQgY2xhc3MgQVNBU3Rha2luZ0NvbnRyYWN0IGV4dGVuZHMgQ29udHJhY3QgewogICAgdHhuIE51bUFwcEFyZ3MKICAgIGJ6IG1haW5fYmFyZV9yb3V0aW5nQDI1CiAgICBwdXNoYnl0ZXNzIDB4NWQ3ODk1MjEgMHgwODBmNmVjZCAweDBlOTNmZGU2IDB4NjY3YzVkMzAgMHg5ZmZkM2U1MyAweDA4OTBiZDU4IDB4MjFmMWRkZmYgMHhiM2I3MDE0NiAweDBiZDhjZjYwIDB4NjkwNGFjNWEgMHgyYjg3ZjU3YyAweGY4M2VlYjVkIDB4MWU2NjEyYmQgMHg4MmFiMWVjNCAweDE1NzY2YjA5IDB4YmZlMzE1NjQgMHhjZTk2M2IxZCAweGRjOWEyYTA1IC8vIG1ldGhvZCAiZ2V0VXNlclN0YWtlSW5mbyhhY2NvdW50KSh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSIsIG1ldGhvZCAic3RvcmVVc2VyU3Rha2VJbmZvKGFjY291bnQsKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpKXZvaWQiLCBtZXRob2QgImdldEN1cnJlbnRQZXJpb2QoKXVpbnQ2NCIsIG1ldGhvZCAiaW5pdGlhbGl6ZShhc3NldCxhY2NvdW50LHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiLCBtZXRob2QgIm9wdEluVG9Bc3NldCgpdm9pZCIsIG1ldGhvZCAic3Rha2UoKXZvaWQiLCBtZXRob2QgIndpdGhkcmF3KHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJhZGRSZXdhcmRzKCl2b2lkIiwgbWV0aG9kICJjYWxjdWxhdGVVc2VyUmV3YXJkc0ZvclBlcmlvZChhY2NvdW50KXVpbnQ2NCIsIG1ldGhvZCAiY2FsY3VsYXRlUGVuZGluZ1Jld2FyZHMoYWNjb3VudCl1aW50NjQiLCBtZXRob2QgImRpc3RyaWJ1dGVSZXdhcmRzKGFkZHJlc3NbXSl2b2lkIiwgbWV0aG9kICJnZXRBY3RpdmVTdGFrZXJzQ291bnQoYWRkcmVzc1tdKXVpbnQ2NCIsIG1ldGhvZCAidXBkYXRlQVBSKHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJ1cGRhdGVBZG1pbihhY2NvdW50KXZvaWQiLCBtZXRob2QgImdldFVzZXJTdGF0cyhhY2NvdW50KXVpbnQ2NFtdIiwgbWV0aG9kICJnZXRDb250cmFjdFN0YXRzKCl1aW50NjRbXSIsIG1ldGhvZCAiZW1lcmdlbmN5V2l0aGRyYXdSZXdhcmRzKHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJkZWxldGVVc2VyQm94KGFjY291bnQpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5fZ2V0VXNlclN0YWtlSW5mb19yb3V0ZUA1IG1haW5fc3RvcmVVc2VyU3Rha2VJbmZvX3JvdXRlQDYgbWFpbl9nZXRDdXJyZW50UGVyaW9kX3JvdXRlQDcgbWFpbl9pbml0aWFsaXplX3JvdXRlQDggbWFpbl9vcHRJblRvQXNzZXRfcm91dGVAOSBtYWluX3N0YWtlX3JvdXRlQDEwIG1haW5fd2l0aGRyYXdfcm91dGVAMTEgbWFpbl9hZGRSZXdhcmRzX3JvdXRlQDEyIG1haW5fY2FsY3VsYXRlVXNlclJld2FyZHNGb3JQZXJpb2Rfcm91dGVAMTMgbWFpbl9jYWxjdWxhdGVQZW5kaW5nUmV3YXJkc19yb3V0ZUAxNCBtYWluX2Rpc3RyaWJ1dGVSZXdhcmRzX3JvdXRlQDE1IG1haW5fZ2V0QWN0aXZlU3Rha2Vyc0NvdW50X3JvdXRlQDE2IG1haW5fdXBkYXRlQVBSX3JvdXRlQDE3IG1haW5fdXBkYXRlQWRtaW5fcm91dGVAMTggbWFpbl9nZXRVc2VyU3RhdHNfcm91dGVAMTkgbWFpbl9nZXRDb250cmFjdFN0YXRzX3JvdXRlQDIwIG1haW5fZW1lcmdlbmN5V2l0aGRyYXdSZXdhcmRzX3JvdXRlQDIxIG1haW5fZGVsZXRlVXNlckJveF9yb3V0ZUAyMgoKbWFpbl9hZnRlcl9pZl9lbHNlQDI5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1Mi01MwogICAgLy8gQGNvbnRyYWN0KHsgc3RhdGVUb3RhbHM6IHsgZ2xvYmFsQnl0ZXM6IDggfSB9KQogICAgLy8gZXhwb3J0IGNsYXNzIEFTQVN0YWtpbmdDb250cmFjdCBleHRlbmRzIENvbnRyYWN0IHsKICAgIGludGNfMCAvLyAwCiAgICByZXR1cm4KCm1haW5fZGVsZXRlVXNlckJveF9yb3V0ZUAyMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTI0CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1Mi01MwogICAgLy8gQGNvbnRyYWN0KHsgc3RhdGVUb3RhbHM6IHsgZ2xvYmFsQnl0ZXM6IDggfSB9KQogICAgLy8gZXhwb3J0IGNsYXNzIEFTQVN0YWtpbmdDb250cmFjdCBleHRlbmRzIENvbnRyYWN0IHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmFzIEFjY291bnRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjUyNAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGRlbGV0ZVVzZXJCb3gKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZW1lcmdlbmN5V2l0aGRyYXdSZXdhcmRzX3JvdXRlQDIxOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0OTYKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjUyLTUzCiAgICAvLyBAY29udHJhY3QoeyBzdGF0ZVRvdGFsczogeyBnbG9iYWxCeXRlczogOCB9IH0pCiAgICAvLyBleHBvcnQgY2xhc3MgQVNBU3Rha2luZ0NvbnRyYWN0IGV4dGVuZHMgQ29udHJhY3QgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0OTYKICAgIC8vIEBhYmltZXRob2QoKQogICAgY2FsbHN1YiBlbWVyZ2VuY3lXaXRoZHJhd1Jld2FyZHMKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZ2V0Q29udHJhY3RTdGF0c19yb3V0ZUAyMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDc3CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBnZXRDb250cmFjdFN0YXRzCiAgICBieXRlYyA0IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2dldFVzZXJTdGF0c19yb3V0ZUAxOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDU3CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1Mi01MwogICAgLy8gQGNvbnRyYWN0KHsgc3RhdGVUb3RhbHM6IHsgZ2xvYmFsQnl0ZXM6IDggfSB9KQogICAgLy8gZXhwb3J0IGNsYXNzIEFTQVN0YWtpbmdDb250cmFjdCBleHRlbmRzIENvbnRyYWN0IHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmFzIEFjY291bnRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ1NwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICBjYWxsc3ViIGdldFVzZXJTdGF0cwogICAgYnl0ZWMgNCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl91cGRhdGVBZG1pbl9yb3V0ZUAxODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDQ0CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1Mi01MwogICAgLy8gQGNvbnRyYWN0KHsgc3RhdGVUb3RhbHM6IHsgZ2xvYmFsQnl0ZXM6IDggfSB9KQogICAgLy8gZXhwb3J0IGNsYXNzIEFTQVN0YWtpbmdDb250cmFjdCBleHRlbmRzIENvbnRyYWN0IHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmFzIEFjY291bnRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ0NAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIHVwZGF0ZUFkbWluCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3VwZGF0ZUFQUl9yb3V0ZUAxNzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDMwCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1Mi01MwogICAgLy8gQGNvbnRyYWN0KHsgc3RhdGVUb3RhbHM6IHsgZ2xvYmFsQnl0ZXM6IDggfSB9KQogICAgLy8gZXhwb3J0IGNsYXNzIEFTQVN0YWtpbmdDb250cmFjdCBleHRlbmRzIENvbnRyYWN0IHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDMwCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgdXBkYXRlQVBSCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2dldEFjdGl2ZVN0YWtlcnNDb3VudF9yb3V0ZUAxNjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDEyCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1Mi01MwogICAgLy8gQGNvbnRyYWN0KHsgc3RhdGVUb3RhbHM6IHsgZ2xvYmFsQnl0ZXM6IDggfSB9KQogICAgLy8gZXhwb3J0IGNsYXNzIEFTQVN0YWtpbmdDb250cmFjdCBleHRlbmRzIENvbnRyYWN0IHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDEyCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGNhbGxzdWIgZ2V0QWN0aXZlU3Rha2Vyc0NvdW50CiAgICBpdG9iCiAgICBieXRlYyA0IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2Rpc3RyaWJ1dGVSZXdhcmRzX3JvdXRlQDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozODcKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjUyLTUzCiAgICAvLyBAY29udHJhY3QoeyBzdGF0ZVRvdGFsczogeyBnbG9iYWxCeXRlczogOCB9IH0pCiAgICAvLyBleHBvcnQgY2xhc3MgQVNBU3Rha2luZ0NvbnRyYWN0IGV4dGVuZHMgQ29udHJhY3QgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozODcKICAgIC8vIEBhYmltZXRob2QoKQogICAgY2FsbHN1YiBkaXN0cmlidXRlUmV3YXJkcwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9jYWxjdWxhdGVQZW5kaW5nUmV3YXJkc19yb3V0ZUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzE0CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1Mi01MwogICAgLy8gQGNvbnRyYWN0KHsgc3RhdGVUb3RhbHM6IHsgZ2xvYmFsQnl0ZXM6IDggfSB9KQogICAgLy8gZXhwb3J0IGNsYXNzIEFTQVN0YWtpbmdDb250cmFjdCBleHRlbmRzIENvbnRyYWN0IHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmFzIEFjY291bnRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjMxNAogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICBjYWxsc3ViIGNhbGN1bGF0ZVBlbmRpbmdSZXdhcmRzCiAgICBpdG9iCiAgICBieXRlYyA0IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2NhbGN1bGF0ZVVzZXJSZXdhcmRzRm9yUGVyaW9kX3JvdXRlQDEzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyNjgKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjUyLTUzCiAgICAvLyBAY29udHJhY3QoeyBzdGF0ZVRvdGFsczogeyBnbG9iYWxCeXRlczogOCB9IH0pCiAgICAvLyBleHBvcnQgY2xhc3MgQVNBU3Rha2luZ0NvbnRyYWN0IGV4dGVuZHMgQ29udHJhY3QgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYXMgQWNjb3VudHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjY4CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGNhbGxzdWIgY2FsY3VsYXRlVXNlclJld2FyZHNGb3JQZXJpb2QKICAgIGl0b2IKICAgIGJ5dGVjIDQgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fYWRkUmV3YXJkc19yb3V0ZUAxMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjQzCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBhZGRSZXdhcmRzCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3dpdGhkcmF3X3JvdXRlQDExOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxOTkKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjUyLTUzCiAgICAvLyBAY29udHJhY3QoeyBzdGF0ZVRvdGFsczogeyBnbG9iYWxCeXRlczogOCB9IH0pCiAgICAvLyBleHBvcnQgY2xhc3MgQVNBU3Rha2luZ0NvbnRyYWN0IGV4dGVuZHMgQ29udHJhY3QgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxOTkKICAgIC8vIEBhYmltZXRob2QoKQogICAgY2FsbHN1YiB3aXRoZHJhdwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9zdGFrZV9yb3V0ZUAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTUyCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBzdGFrZQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9vcHRJblRvQXNzZXRfcm91dGVAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTMxCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBvcHRJblRvQXNzZXQKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5faW5pdGlhbGl6ZV9yb3V0ZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxMDMKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjUyLTUzCiAgICAvLyBAY29udHJhY3QoeyBzdGF0ZVRvdGFsczogeyBnbG9iYWxCeXRlczogOCB9IH0pCiAgICAvLyBleHBvcnQgY2xhc3MgQVNBU3Rha2luZ0NvbnRyYWN0IGV4dGVuZHMgQ29udHJhY3QgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYXMgQXNzZXRzCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICB0eG5hcyBBY2NvdW50cwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxMDMKICAgIC8vIEBhYmltZXRob2QoKQogICAgY2FsbHN1YiBpbml0aWFsaXplCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2dldEN1cnJlbnRQZXJpb2Rfcm91dGVANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OTQKICAgIC8vIHB1YmxpYyBnZXRDdXJyZW50UGVyaW9kKCk6IHVpbnQ2NCB7CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgZ2V0Q3VycmVudFBlcmlvZAogICAgaXRvYgogICAgYnl0ZWMgNCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9zdG9yZVVzZXJTdGFrZUluZm9fcm91dGVANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6ODcKICAgIC8vIHB1YmxpYyBzdG9yZVVzZXJTdGFrZUluZm8odXNlckFkZHJlc3M6IEFjY291bnQsIHN0YWtlSW5mbzogVXNlclN0YWtlSW5mbyk6IHZvaWQgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjUyLTUzCiAgICAvLyBAY29udHJhY3QoeyBzdGF0ZVRvdGFsczogeyBnbG9iYWxCeXRlczogOCB9IH0pCiAgICAvLyBleHBvcnQgY2xhc3MgQVNBU3Rha2luZ0NvbnRyYWN0IGV4dGVuZHMgQ29udHJhY3QgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYXMgQWNjb3VudHMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6ODcKICAgIC8vIHB1YmxpYyBzdG9yZVVzZXJTdGFrZUluZm8odXNlckFkZHJlc3M6IEFjY291bnQsIHN0YWtlSW5mbzogVXNlclN0YWtlSW5mbyk6IHZvaWQgewogICAgY2FsbHN1YiBzdG9yZVVzZXJTdGFrZUluZm8KICAgIHBvcAogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9nZXRVc2VyU3Rha2VJbmZvX3JvdXRlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjY4CiAgICAvLyBwdWJsaWMgZ2V0VXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzczogQWNjb3VudCk6IFVzZXJTdGFrZUluZm8gewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjUyLTUzCiAgICAvLyBAY29udHJhY3QoeyBzdGF0ZVRvdGFsczogeyBnbG9iYWxCeXRlczogOCB9IH0pCiAgICAvLyBleHBvcnQgY2xhc3MgQVNBU3Rha2luZ0NvbnRyYWN0IGV4dGVuZHMgQ29udHJhY3QgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYXMgQWNjb3VudHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjgKICAgIC8vIHB1YmxpYyBnZXRVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzOiBBY2NvdW50KTogVXNlclN0YWtlSW5mbyB7CiAgICBjYWxsc3ViIGdldFVzZXJTdGFrZUluZm8KICAgIGJ5dGVjIDQgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fYmFyZV9yb3V0aW5nQDI1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1Mi01MwogICAgLy8gQGNvbnRyYWN0KHsgc3RhdGVUb3RhbHM6IHsgZ2xvYmFsQnl0ZXM6IDggfSB9KQogICAgLy8gZXhwb3J0IGNsYXNzIEFTQVN0YWtpbmdDb250cmFjdCBleHRlbmRzIENvbnRyYWN0IHsKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIGJueiBtYWluX2FmdGVyX2lmX2Vsc2VAMjkKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAhCiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIGNyZWF0aW5nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6QVNBU3Rha2luZ0NvbnRyYWN0LmdldFVzZXJTdGFrZUluZm8odXNlckFkZHJlc3M6IGJ5dGVzKSAtPiBieXRlczoKZ2V0VXNlclN0YWtlSW5mbzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjgKICAgIC8vIHB1YmxpYyBnZXRVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzOiBBY2NvdW50KTogVXNlclN0YWtlSW5mbyB7CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjMKICAgIC8vIHB1YmxpYyBzdGFrZXJzID0gQm94TWFwPEFjY291bnQsIFVzZXJTdGFrZUluZm8+KHsga2V5UHJlZml4OiAnc3Rha2VycycgfSkKICAgIGJ5dGVjIDkgLy8gInN0YWtlcnMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjY5CiAgICAvLyBjb25zdCB1c2VyQm94ID0gdGhpcy5zdGFrZXJzKHVzZXJBZGRyZXNzKQogICAgZnJhbWVfZGlnIC0xCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYzCiAgICAvLyBwdWJsaWMgc3Rha2VycyA9IEJveE1hcDxBY2NvdW50LCBVc2VyU3Rha2VJbmZvPih7IGtleVByZWZpeDogJ3N0YWtlcnMnIH0pCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjkKICAgIC8vIGNvbnN0IHVzZXJCb3ggPSB0aGlzLnN0YWtlcnModXNlckFkZHJlc3MpCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NzEKICAgIC8vIGlmICh1c2VyQm94LmV4aXN0cykgewogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBieiBnZXRVc2VyU3Rha2VJbmZvX2Vsc2VfYm9keUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjcyCiAgICAvLyByZXR1cm4gdXNlckJveC52YWx1ZS5jb3B5KCkKICAgIGZyYW1lX2RpZyAwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgc3dhcAogICAgcmV0c3ViCgpnZXRVc2VyU3Rha2VJbmZvX2Vsc2VfYm9keUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo3NC04MAogICAgLy8gcmV0dXJuIG5ldyBVc2VyU3Rha2VJbmZvKHsKICAgIC8vICAgc3Rha2VkQW1vdW50OiBuZXcgYXJjNC5VaW50TjY0KDApLAogICAgLy8gICBmaXJzdFN0YWtlVGltZTogbmV3IGFyYzQuVWludE42NCgwKSwKICAgIC8vICAgbGFzdFN0YWtlVGltZTogbmV3IGFyYzQuVWludE42NCgwKSwKICAgIC8vICAgdG90YWxSZXdhcmRzRWFybmVkOiBuZXcgYXJjNC5VaW50TjY0KDApLAogICAgLy8gICBsYXN0Q2xhaW1lZFBlcmlvZDogbmV3IGFyYzQuVWludE42NCgwKSwKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAogICAgc3dhcAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6QVNBU3Rha2luZ0NvbnRyYWN0LnN0b3JlVXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzczogYnl0ZXMsIHN0YWtlSW5mbzogYnl0ZXMpIC0+IGJ5dGVzOgpzdG9yZVVzZXJTdGFrZUluZm86CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjg3CiAgICAvLyBwdWJsaWMgc3RvcmVVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzOiBBY2NvdW50LCBzdGFrZUluZm86IFVzZXJTdGFrZUluZm8pOiB2b2lkIHsKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2MwogICAgLy8gcHVibGljIHN0YWtlcnMgPSBCb3hNYXA8QWNjb3VudCwgVXNlclN0YWtlSW5mbz4oeyBrZXlQcmVmaXg6ICdzdGFrZXJzJyB9KQogICAgYnl0ZWMgOSAvLyAic3Rha2VycyIKICAgIGZyYW1lX2RpZyAtMgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjg4CiAgICAvLyB0aGlzLnN0YWtlcnModXNlckFkZHJlc3MpLnZhbHVlID0gc3Rha2VJbmZvLmNvcHkoKQogICAgZnJhbWVfZGlnIC0xCiAgICBib3hfcHV0CiAgICBmcmFtZV9kaWcgLTEKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OkFTQVN0YWtpbmdDb250cmFjdC5nZXRDdXJyZW50UGVyaW9kKCkgLT4gdWludDY0OgpnZXRDdXJyZW50UGVyaW9kOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo5NAogICAgLy8gcHVibGljIGdldEN1cnJlbnRQZXJpb2QoKTogdWludDY0IHsKICAgIHByb3RvIDAgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1OQogICAgLy8gcHVibGljIGRpc3RyaWJ1dGlvblBlcmlvZFJvdW5kcyA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA2IC8vICJkaXN0cmlidXRpb25QZXJpb2RSb3VuZHMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgc3dhcAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OTYKICAgIC8vIGlmIChwZXJpb2RTZWNvbmRzID09PSAwKSByZXR1cm4gMAogICAgYm56IGdldEN1cnJlbnRQZXJpb2RfYWZ0ZXJfaWZfZWxzZUAyCiAgICBpbnRjXzAgLy8gMAogICAgc3dhcAogICAgcmV0c3ViCgpnZXRDdXJyZW50UGVyaW9kX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OTcKICAgIC8vIHJldHVybiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wIC8gcGVyaW9kU2Vjb25kcwogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgZnJhbWVfZGlnIDAKICAgIC8KICAgIHN3YXAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OkFTQVN0YWtpbmdDb250cmFjdC5pbml0aWFsaXplKGFzc2V0OiB1aW50NjQsIGFkbWluQWRkcmVzczogYnl0ZXMsIGFwckJhc2lzUG9pbnRzOiB1aW50NjQsIGRpc3RyaWJ1dGlvblBlcmlvZFNlY29uZHM6IHVpbnQ2NCwgbWluaW11bVN0YWtlOiB1aW50NjQpIC0+IHZvaWQ6CmluaXRpYWxpemU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEwMy0xMTAKICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIGluaXRpYWxpemUoCiAgICAvLyAgIGFzc2V0OiBBc3NldCwKICAgIC8vICAgYWRtaW5BZGRyZXNzOiBBY2NvdW50LAogICAgLy8gICBhcHJCYXNpc1BvaW50czogdWludDY0LAogICAgLy8gICBkaXN0cmlidXRpb25QZXJpb2RTZWNvbmRzOiB1aW50NjQsCiAgICAvLyAgIG1pbmltdW1TdGFrZTogdWludDY0LAogICAgLy8gKTogdm9pZCB7CiAgICBwcm90byA1IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTQKICAgIC8vIHB1YmxpYyBhc3NldCA9IEdsb2JhbFN0YXRlPEFzc2V0Pih7IGluaXRpYWxWYWx1ZTogQXNzZXQoKSB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImFzc2V0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTEyCiAgICAvLyBhc3NlcnQodGhpcy5hc3NldC52YWx1ZSA9PT0gQXNzZXQoKSwgJ0FscmVhZHkgaW5pdGlhbGl6ZWQnKQogICAgIQogICAgYXNzZXJ0IC8vIEFscmVhZHkgaW5pdGlhbGl6ZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTE1CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gR2xvYmFsLmNyZWF0b3JBZGRyZXNzLCAnT25seSBjcmVhdG9yIGNhbiBpbml0aWFsaXplJykKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IGNyZWF0b3IgY2FuIGluaXRpYWxpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTQKICAgIC8vIHB1YmxpYyBhc3NldCA9IEdsb2JhbFN0YXRlPEFzc2V0Pih7IGluaXRpYWxWYWx1ZTogQXNzZXQoKSB9KQogICAgYnl0ZWNfMSAvLyAiYXNzZXQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjExOAogICAgLy8gdGhpcy5hc3NldC52YWx1ZSA9IGFzc2V0CiAgICBmcmFtZV9kaWcgLTUKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU1CiAgICAvLyBwdWJsaWMgYWRtaW5BZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBpbml0aWFsVmFsdWU6IEFjY291bnQoKX0pCiAgICBieXRlY18yIC8vICJhZG1pbkFkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjExOQogICAgLy8gdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUgPSBhZG1pbkFkZHJlc3MKICAgIGZyYW1lX2RpZyAtNAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTYKICAgIC8vIHB1YmxpYyB0b3RhbFN0YWtlZCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIGJ5dGVjXzMgLy8gInRvdGFsU3Rha2VkIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxMjAKICAgIC8vIHRoaXMudG90YWxTdGFrZWQudmFsdWUgPSAwCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTcKICAgIC8vIHB1YmxpYyBhcHJCYXNpc1BvaW50cyA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIGJ5dGVjIDUgLy8gImFwckJhc2lzUG9pbnRzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxMjEKICAgIC8vIHRoaXMuYXByQmFzaXNQb2ludHMudmFsdWUgPSBhcHJCYXNpc1BvaW50cwogICAgZnJhbWVfZGlnIC0zCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1OAogICAgLy8gcHVibGljIGxhc3REaXN0cmlidXRpb25UaW1lID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgYnl0ZWMgOCAvLyAibGFzdERpc3RyaWJ1dGlvblRpbWUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEyMgogICAgLy8gdGhpcy5sYXN0RGlzdHJpYnV0aW9uVGltZS52YWx1ZSA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU5CiAgICAvLyBwdWJsaWMgZGlzdHJpYnV0aW9uUGVyaW9kUm91bmRzID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgYnl0ZWMgNiAvLyAiZGlzdHJpYnV0aW9uUGVyaW9kUm91bmRzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxMjMKICAgIC8vIHRoaXMuZGlzdHJpYnV0aW9uUGVyaW9kUm91bmRzLnZhbHVlID0gZGlzdHJpYnV0aW9uUGVyaW9kU2Vjb25kcwogICAgZnJhbWVfZGlnIC0yCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2MAogICAgLy8gcHVibGljIG1pbmltdW1TdGFrZSA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIGJ5dGVjIDcgLy8gIm1pbmltdW1TdGFrZSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTI0CiAgICAvLyB0aGlzLm1pbmltdW1TdGFrZS52YWx1ZSA9IG1pbmltdW1TdGFrZQogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2MQogICAgLy8gcHVibGljIHJld2FyZFBvb2wgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICBieXRlY18wIC8vICJyZXdhcmRQb29sIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxMjUKICAgIC8vIHRoaXMucmV3YXJkUG9vbC52YWx1ZSA9IDAKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6QVNBU3Rha2luZ0NvbnRyYWN0Lm9wdEluVG9Bc3NldCgpIC0+IHZvaWQ6Cm9wdEluVG9Bc3NldDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTMxLTEzMgogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgb3B0SW5Ub0Fzc2V0KCk6IHZvaWQgewogICAgcHJvdG8gMCAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU1CiAgICAvLyBwdWJsaWMgYWRtaW5BZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBpbml0aWFsVmFsdWU6IEFjY291bnQoKX0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiYWRtaW5BZGRyZXNzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTM1CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gR2xvYmFsLmNyZWF0b3JBZGRyZXNzIHx8IFR4bi5zZW5kZXIgPT09IGFkbWluQWRkciwgJ09ubHkgY3JlYXRvciBvciBhZG1pbiBjYW4gb3B0IGluJykKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGJueiBvcHRJblRvQXNzZXRfYm9vbF90cnVlQDIKICAgIHR4biBTZW5kZXIKICAgIGZyYW1lX2RpZyAwCiAgICA9PQogICAgYnogb3B0SW5Ub0Fzc2V0X2Jvb2xfZmFsc2VAMwoKb3B0SW5Ub0Fzc2V0X2Jvb2xfdHJ1ZUAyOgogICAgaW50Y18xIC8vIDEKCm9wdEluVG9Bc3NldF9ib29sX21lcmdlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEzNQogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IEdsb2JhbC5jcmVhdG9yQWRkcmVzcyB8fCBUeG4uc2VuZGVyID09PSBhZG1pbkFkZHIsICdPbmx5IGNyZWF0b3Igb3IgYWRtaW4gY2FuIG9wdCBpbicpCiAgICBhc3NlcnQgLy8gT25seSBjcmVhdG9yIG9yIGFkbWluIGNhbiBvcHQgaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTQKICAgIC8vIHB1YmxpYyBhc3NldCA9IEdsb2JhbFN0YXRlPEFzc2V0Pih7IGluaXRpYWxWYWx1ZTogQXNzZXQoKSB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImFzc2V0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTM5LTE0NQogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE0MQogICAgLy8gYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgc3dhcAogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTQyCiAgICAvLyBhc3NldEFtb3VudDogMCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTM5LTE0NAogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgfSkKICAgIGludGNfMiAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTM5LTE0NQogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgcmV0c3ViCgpvcHRJblRvQXNzZXRfYm9vbF9mYWxzZUAzOgogICAgaW50Y18wIC8vIDAKICAgIGIgb3B0SW5Ub0Fzc2V0X2Jvb2xfbWVyZ2VANAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OkFTQVN0YWtpbmdDb250cmFjdC5zdGFrZSgpIC0+IHZvaWQ6CnN0YWtlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxNTItMTUzCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyBzdGFrZSgpOiB2b2lkIHsKICAgIHByb3RvIDAgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1NAogICAgLy8gcHVibGljIGFzc2V0ID0gR2xvYmFsU3RhdGU8QXNzZXQ+KHsgaW5pdGlhbFZhbHVlOiBBc3NldCgpIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAiYXNzZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImFzc2V0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTU2CiAgICAvLyBhc3NlcnQodGhpcy5hc3NldC52YWx1ZSAhPT0gQXNzZXQoKSwgJ0NvbnRyYWN0IG5vdCBpbml0aWFsaXplZCcpCiAgICBhc3NlcnQgLy8gQ29udHJhY3Qgbm90IGluaXRpYWxpemVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE1OQogICAgLy8gYXNzZXJ0KEdsb2JhbC5ncm91cFNpemUgPT09IDIsICdFeHBlY3RlZCAyIHR4bnMgaW4gZ3JvdXAnKQogICAgZ2xvYmFsIEdyb3VwU2l6ZQogICAgcHVzaGludCAyIC8vIDIKICAgID09CiAgICBhc3NlcnQgLy8gRXhwZWN0ZWQgMiB0eG5zIGluIGdyb3VwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE2MgogICAgLy8gY29uc3QgeGZlclR4biA9IGd0eG4uQXNzZXRUcmFuc2ZlclR4bigwKQogICAgaW50Y18wIC8vIDAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBkdXAKICAgIGludGNfMiAvLyBheGZlcgogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIGF4ZmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE2MwogICAgLy8gYXNzZXJ0KHhmZXJUeG4udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFzc2V0VHJhbnNmZXIsICdUcmFuc2FjdGlvbiAwIG11c3QgYmUgYXNzZXQgdHJhbnNmZXInKQogICAgaW50Y18yIC8vIDQKICAgID09CiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gMCBtdXN0IGJlIGFzc2V0IHRyYW5zZmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE2MgogICAgLy8gY29uc3QgeGZlclR4biA9IGd0eG4uQXNzZXRUcmFuc2ZlclR4bigwKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTY0CiAgICAvLyBhc3NlcnQoeGZlclR4bi5hc3NldFJlY2VpdmVyID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywgJ0Fzc2V0IHRyYW5zZmVyIG11c3QgYmUgdG8gY29udHJhY3QnKQogICAgZ3R4bnMgQXNzZXRSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQXNzZXQgdHJhbnNmZXIgbXVzdCBiZSB0byBjb250cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxNjIKICAgIC8vIGNvbnN0IHhmZXJUeG4gPSBndHhuLkFzc2V0VHJhbnNmZXJUeG4oMCkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE2NQogICAgLy8gYXNzZXJ0KHhmZXJUeG4uYXNzZXRBbW91bnQgPiAwLCAnTXVzdCBzdGFrZSBub24temVybyBhbW91bnQnKQogICAgZ3R4bnMgQXNzZXRBbW91bnQKICAgIGR1cAogICAgY292ZXIgMgogICAgYXNzZXJ0IC8vIE11c3Qgc3Rha2Ugbm9uLXplcm8gYW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE2MgogICAgLy8gY29uc3QgeGZlclR4biA9IGd0eG4uQXNzZXRUcmFuc2ZlclR4bigwKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTY2CiAgICAvLyBhc3NlcnQoeGZlclR4bi54ZmVyQXNzZXQgPT09IGFzc2V0LCAnSW5jb3JyZWN0IGFzc2V0IElEJykKICAgIGd0eG5zIFhmZXJBc3NldAogICAgPT0KICAgIGFzc2VydCAvLyBJbmNvcnJlY3QgYXNzZXQgSUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjAKICAgIC8vIHB1YmxpYyBtaW5pbXVtU3Rha2UgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNyAvLyAibWluaW11bVN0YWtlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTczCiAgICAvLyBjb25zdCBzZW5kZXJBZGRyZXNzID0gVHhuLnNlbmRlcgogICAgdHhuIFNlbmRlcgogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE3NAogICAgLy8gY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHNlbmRlckFkZHJlc3MpCiAgICBjYWxsc3ViIGdldFVzZXJTdGFrZUluZm8KICAgIGR1cG4gMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxNzcKICAgIC8vIGlmIChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSA9PT0gMCkgewogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBibnogc3Rha2VfYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE3OAogICAgLy8gYXNzZXJ0KHN0YWtlQW1vdW50ID49IG1pbmltdW1TdGFrZSwgJ0luaXRpYWwgc3Rha2UgYmVsb3cgbWluaW11bScpCiAgICBmcmFtZV9kaWcgMAogICAgZnJhbWVfZGlnIDEKICAgID49CiAgICBhc3NlcnQgLy8gSW5pdGlhbCBzdGFrZSBiZWxvdyBtaW5pbXVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE4MAogICAgLy8gc3Rha2VJbmZvLmxhc3RDbGFpbWVkUGVyaW9kID0gbmV3IGFyYzQuVWludE42NCh0aGlzLmdldEN1cnJlbnRQZXJpb2QoKSkKICAgIGNhbGxzdWIgZ2V0Q3VycmVudFBlcmlvZAogICAgaXRvYgogICAgZnJhbWVfZGlnIDMKICAgIHN3YXAKICAgIHJlcGxhY2UyIDMyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE4MgogICAgLy8gc3Rha2VJbmZvLmZpcnN0U3Rha2VUaW1lID0gbmV3IGFyYzQuVWludE42NChHbG9iYWwubGF0ZXN0VGltZXN0YW1wKQogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaXRvYgogICAgcmVwbGFjZTIgOAogICAgZnJhbWVfYnVyeSA0CgpzdGFrZV9hZnRlcl9pZl9lbHNlQDI6CiAgICBmcmFtZV9kaWcgNAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxODYKICAgIC8vIHN0YWtlSW5mby5zdGFrZWRBbW91bnQgPSBuZXcgYXJjNC5VaW50TjY0KHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlICsgc3Rha2VBbW91bnQpCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfZGlnIDAKICAgIGR1cAogICAgY292ZXIgMwogICAgKwogICAgaXRvYgogICAgcmVwbGFjZTIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxODcKICAgIC8vIHN0YWtlSW5mby5sYXN0U3Rha2VUaW1lID0gbmV3IGFyYzQuVWludE42NChHbG9iYWwubGF0ZXN0VGltZXN0YW1wKQogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaXRvYgogICAgcmVwbGFjZTIgMTYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTkwCiAgICAvLyB0aGlzLnN0b3JlVXNlclN0YWtlSW5mbyhzZW5kZXJBZGRyZXNzLCBzdGFrZUluZm8pCiAgICBmcmFtZV9kaWcgMgogICAgc3dhcAogICAgY2FsbHN1YiBzdG9yZVVzZXJTdGFrZUluZm8KICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1NgogICAgLy8gcHVibGljIHRvdGFsU3Rha2VkID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gInRvdGFsU3Rha2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTkzCiAgICAvLyB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlID0gdGhpcy50b3RhbFN0YWtlZC52YWx1ZSArIHN0YWtlQW1vdW50CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU2CiAgICAvLyBwdWJsaWMgdG90YWxTdGFrZWQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICBieXRlY18zIC8vICJ0b3RhbFN0YWtlZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTkzCiAgICAvLyB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlID0gdGhpcy50b3RhbFN0YWtlZC52YWx1ZSArIHN0YWtlQW1vdW50CiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6QVNBU3Rha2luZ0NvbnRyYWN0LndpdGhkcmF3KGFtb3VudDogdWludDY0KSAtPiB2b2lkOgp3aXRoZHJhdzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTk5LTIwMAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgd2l0aGRyYXcoYW1vdW50OiB1aW50NjQpOiB2b2lkIHsKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyMDEKICAgIC8vIGNvbnN0IHNlbmRlckFkZHJlc3MgPSBUeG4uc2VuZGVyCiAgICB0eG4gU2VuZGVyCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjAyCiAgICAvLyBjb25zdCBzdGFrZUluZm8gPSB0aGlzLmdldFVzZXJTdGFrZUluZm8oc2VuZGVyQWRkcmVzcykKICAgIGNhbGxzdWIgZ2V0VXNlclN0YWtlSW5mbwogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjIwNQogICAgLy8gYXNzZXJ0KHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlID4gMCwgJ05vIHN0YWtlIGZvdW5kJykKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwbiAyCiAgICBhc3NlcnQgLy8gTm8gc3Rha2UgZm91bmQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjA2CiAgICAvLyBhc3NlcnQoYW1vdW50IDw9IHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlLCAnV2l0aGRyYXdhbCBhbW91bnQgZXhjZWVkcyBzdGFrZScpCiAgICBmcmFtZV9kaWcgLTEKICAgIGRpZyAxCiAgICA8PQogICAgYXNzZXJ0IC8vIFdpdGhkcmF3YWwgYW1vdW50IGV4Y2VlZHMgc3Rha2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjA3CiAgICAvLyBhc3NlcnQoYW1vdW50ID4gMCwgJ1dpdGhkcmF3YWwgYW1vdW50IG11c3QgYmUgcG9zaXRpdmUnKQogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NlcnQgLy8gV2l0aGRyYXdhbCBhbW91bnQgbXVzdCBiZSBwb3NpdGl2ZQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyMTEKICAgIC8vIGlmIChhbW91bnQgPCBzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSkgewogICAgZnJhbWVfZGlnIC0xCiAgICA+CiAgICBieiB3aXRoZHJhd19hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjEyCiAgICAvLyBjb25zdCByZW1haW5pbmdTdGFrZTogdWludDY0ID0gc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgLSBhbW91bnQKICAgIGZyYW1lX2RpZyAyCiAgICBmcmFtZV9kaWcgLTEKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjAKICAgIC8vIHB1YmxpYyBtaW5pbXVtU3Rha2UgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNyAvLyAibWluaW11bVN0YWtlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjE0CiAgICAvLyBhc3NlcnQocmVtYWluaW5nU3Rha2UgPj0gbWluaW11bVN0YWtlLCAnUmVtYWluaW5nIHN0YWtlIHdvdWxkIGJlIGJlbG93IG1pbmltdW0nKQogICAgPj0KICAgIGFzc2VydCAvLyBSZW1haW5pbmcgc3Rha2Ugd291bGQgYmUgYmVsb3cgbWluaW11bQoKd2l0aGRyYXdfYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyMTgKICAgIC8vIHN0YWtlSW5mby5zdGFrZWRBbW91bnQgPSBuZXcgYXJjNC5VaW50TjY0KHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlIC0gYW1vdW50KQogICAgZnJhbWVfZGlnIDIKICAgIGZyYW1lX2RpZyAtMQogICAgLQogICAgaXRvYgogICAgZnJhbWVfZGlnIDEKICAgIHN3YXAKICAgIHJlcGxhY2UyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjIxCiAgICAvLyB0aGlzLnN0b3JlVXNlclN0YWtlSW5mbyhzZW5kZXJBZGRyZXNzLCBzdGFrZUluZm8pCiAgICBmcmFtZV9kaWcgMAogICAgc3dhcAogICAgY2FsbHN1YiBzdG9yZVVzZXJTdGFrZUluZm8KICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1NgogICAgLy8gcHVibGljIHRvdGFsU3Rha2VkID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gInRvdGFsU3Rha2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjI0CiAgICAvLyB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlID0gdGhpcy50b3RhbFN0YWtlZC52YWx1ZSAtIGFtb3VudAogICAgZnJhbWVfZGlnIC0xCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU2CiAgICAvLyBwdWJsaWMgdG90YWxTdGFrZWQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICBieXRlY18zIC8vICJ0b3RhbFN0YWtlZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjI0CiAgICAvLyB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlID0gdGhpcy50b3RhbFN0YWtlZC52YWx1ZSAtIGFtb3VudAogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTQKICAgIC8vIHB1YmxpYyBhc3NldCA9IEdsb2JhbFN0YXRlPEFzc2V0Pih7IGluaXRpYWxWYWx1ZTogQXNzZXQoKSB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImFzc2V0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjI4LTIzNQogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogVHhuLnNlbmRlciwKICAgIC8vICAgICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgICAgZmVlOiAxMDAwLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjMwCiAgICAvLyBhc3NldFJlY2VpdmVyOiBUeG4uc2VuZGVyLAogICAgdHhuIFNlbmRlcgogICAgc3dhcAogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjIyOC0yMzQKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IFR4bi5zZW5kZXIsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICAgIGZlZTogMTAwMCwKICAgIC8vICAgfSkKICAgIGludGNfMiAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjIzMwogICAgLy8gZmVlOiAxMDAwLAogICAgcHVzaGludCAxMDAwIC8vIDEwMDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjIyOC0yMzUKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IFR4bi5zZW5kZXIsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICAgIGZlZTogMTAwMCwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6QVNBU3Rha2luZ0NvbnRyYWN0LmFkZFJld2FyZHMoKSAtPiB2b2lkOgphZGRSZXdhcmRzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1NQogICAgLy8gcHVibGljIGFkbWluQWRkcmVzcyA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsgaW5pdGlhbFZhbHVlOiBBY2NvdW50KCl9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImFkbWluQWRkcmVzcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI0NwogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IGFkbWluQWRkciwgJ09ubHkgYWRtaW4gY2FuIGFkZCByZXdhcmRzJykKICAgIHR4biBTZW5kZXIKICAgID09CiAgICBhc3NlcnQgLy8gT25seSBhZG1pbiBjYW4gYWRkIHJld2FyZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjUwCiAgICAvLyBhc3NlcnQoR2xvYmFsLmdyb3VwU2l6ZSA9PT0gMiwgJ0V4cGVjdGVkIDIgdHhucyBpbiBncm91cCcpCiAgICBnbG9iYWwgR3JvdXBTaXplCiAgICBwdXNoaW50IDIgLy8gMgogICAgPT0KICAgIGFzc2VydCAvLyBFeHBlY3RlZCAyIHR4bnMgaW4gZ3JvdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTQKICAgIC8vIHB1YmxpYyBhc3NldCA9IEdsb2JhbFN0YXRlPEFzc2V0Pih7IGluaXRpYWxWYWx1ZTogQXNzZXQoKSB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImFzc2V0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjU0CiAgICAvLyBjb25zdCB4ZmVyVHhuID0gZ3R4bi5Bc3NldFRyYW5zZmVyVHhuKDApCiAgICBpbnRjXzAgLy8gMAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGR1cAogICAgaW50Y18yIC8vIGF4ZmVyCiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgYXhmZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjU1CiAgICAvLyBhc3NlcnQoeGZlclR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXNzZXRUcmFuc2ZlciwgJ1RyYW5zYWN0aW9uIDAgbXVzdCBiZSBhc3NldCB0cmFuc2ZlcicpCiAgICBpbnRjXzIgLy8gNAogICAgPT0KICAgIGFzc2VydCAvLyBUcmFuc2FjdGlvbiAwIG11c3QgYmUgYXNzZXQgdHJhbnNmZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjU0CiAgICAvLyBjb25zdCB4ZmVyVHhuID0gZ3R4bi5Bc3NldFRyYW5zZmVyVHhuKDApCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyNTYKICAgIC8vIGFzc2VydCh4ZmVyVHhuLmFzc2V0UmVjZWl2ZXIgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLCAnQXNzZXQgdHJhbnNmZXIgbXVzdCBiZSB0byBjb250cmFjdCcpCiAgICBndHhucyBBc3NldFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBBc3NldCB0cmFuc2ZlciBtdXN0IGJlIHRvIGNvbnRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI1NAogICAgLy8gY29uc3QgeGZlclR4biA9IGd0eG4uQXNzZXRUcmFuc2ZlclR4bigwKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjU3CiAgICAvLyBhc3NlcnQoeGZlclR4bi5hc3NldEFtb3VudCA+IDAsICdNdXN0IHByb3ZpZGUgbm9uLXplcm8gcmV3YXJkcycpCiAgICBndHhucyBBc3NldEFtb3VudAogICAgZHVwCiAgICBhc3NlcnQgLy8gTXVzdCBwcm92aWRlIG5vbi16ZXJvIHJld2FyZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjU0CiAgICAvLyBjb25zdCB4ZmVyVHhuID0gZ3R4bi5Bc3NldFRyYW5zZmVyVHhuKDApCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyNTgKICAgIC8vIGFzc2VydCh4ZmVyVHhuLnhmZXJBc3NldCA9PT0gYXNzZXQsICdJbmNvcnJlY3QgYXNzZXQgSUQnKQogICAgZ3R4bnMgWGZlckFzc2V0CiAgICB1bmNvdmVyIDIKICAgID09CiAgICBhc3NlcnQgLy8gSW5jb3JyZWN0IGFzc2V0IElECiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYxCiAgICAvLyBwdWJsaWMgcmV3YXJkUG9vbCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJyZXdhcmRQb29sIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjYxCiAgICAvLyB0aGlzLnJld2FyZFBvb2wudmFsdWUgPSB0aGlzLnJld2FyZFBvb2wudmFsdWUgKyB4ZmVyVHhuLmFzc2V0QW1vdW50CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYxCiAgICAvLyBwdWJsaWMgcmV3YXJkUG9vbCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIGJ5dGVjXzAgLy8gInJld2FyZFBvb2wiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI2MQogICAgLy8gdGhpcy5yZXdhcmRQb29sLnZhbHVlID0gdGhpcy5yZXdhcmRQb29sLnZhbHVlICsgeGZlclR4bi5hc3NldEFtb3VudAogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OkFTQVN0YWtpbmdDb250cmFjdC5jYWxjdWxhdGVVc2VyUmV3YXJkc0ZvclBlcmlvZCh1c2VyQWRkcmVzczogYnl0ZXMpIC0+IHVpbnQ2NDoKY2FsY3VsYXRlVXNlclJld2FyZHNGb3JQZXJpb2Q6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI2OC0yNjkKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgLy8gcHVibGljIGNhbGN1bGF0ZVVzZXJSZXdhcmRzRm9yUGVyaW9kKHVzZXJBZGRyZXNzOiBBY2NvdW50KTogdWludDY0IHsKICAgIHByb3RvIDEgMQogICAgaW50Y18wIC8vIDAKICAgIHB1c2hieXRlcyAiIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1NwogICAgLy8gcHVibGljIGFwckJhc2lzUG9pbnRzID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDUgLy8gImFwckJhc2lzUG9pbnRzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTYKICAgIC8vIHB1YmxpYyB0b3RhbFN0YWtlZCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJ0b3RhbFN0YWtlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU5CiAgICAvLyBwdWJsaWMgZGlzdHJpYnV0aW9uUGVyaW9kUm91bmRzID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDYgLy8gImRpc3RyaWJ1dGlvblBlcmlvZFJvdW5kcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBjb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI3NQogICAgLy8gaWYgKHRvdGFsU3Rha2VkID09PSAwIHx8IHBlcmlvZFNlY29uZHMgPT09IDApIHsKICAgIGJ6IGNhbGN1bGF0ZVVzZXJSZXdhcmRzRm9yUGVyaW9kX2lmX2JvZHlAMgogICAgZnJhbWVfZGlnIDMKICAgIGJueiBjYWxjdWxhdGVVc2VyUmV3YXJkc0ZvclBlcmlvZF9hZnRlcl9pZl9lbHNlQDMKCmNhbGN1bGF0ZVVzZXJSZXdhcmRzRm9yUGVyaW9kX2lmX2JvZHlAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6Mjc2CiAgICAvLyByZXR1cm4gMAogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpjYWxjdWxhdGVVc2VyUmV3YXJkc0ZvclBlcmlvZF9hZnRlcl9pZl9lbHNlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI4MAogICAgLy8gY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzKQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIGdldFVzZXJTdGFrZUluZm8KICAgIGR1cAogICAgZnJhbWVfYnVyeSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI4MwogICAgLy8gaWYgKHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlID09PSAwKSB7CiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgZnJhbWVfYnVyeSAxCiAgICBibnogY2FsY3VsYXRlVXNlclJld2FyZHNGb3JQZXJpb2RfYWZ0ZXJfaWZfZWxzZUA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI4NAogICAgLy8gcmV0dXJuIDAKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKY2FsY3VsYXRlVXNlclJld2FyZHNGb3JQZXJpb2RfYWZ0ZXJfaWZfZWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyODkKICAgIC8vIGNvbnN0IGZpcnN0U3Rha2VUaW1lID0gc3Rha2VJbmZvLmZpcnN0U3Rha2VUaW1lLm5hdGl2ZQogICAgZnJhbWVfZGlnIDAKICAgIHB1c2hpbnQgOCAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyOTMKICAgIC8vIGlmIChHbG9iYWwubGF0ZXN0VGltZXN0YW1wIDwgZmlyc3RTdGFrZVRpbWUgKyBtaW5pbXVtU3Rha2VUaW1lKSB7CiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM3CiAgICAvLyBjb25zdCBST1VORFNfUEVSX0RBWSA9IFVpbnQ2NCgzMDg1NykgLy8gKDI0ICogNjAgKiA2MCkgLyAyLjgKICAgIHB1c2hpbnQgMzA4NTcgLy8gMzA4NTcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MjkzCiAgICAvLyBpZiAoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA8IGZpcnN0U3Rha2VUaW1lICsgbWluaW11bVN0YWtlVGltZSkgewogICAgKwogICAgPAogICAgYnogY2FsY3VsYXRlVXNlclJld2FyZHNGb3JQZXJpb2RfYWZ0ZXJfaWZfZWxzZUA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI5NAogICAgLy8gcmV0dXJuIDAKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKY2FsY3VsYXRlVXNlclJld2FyZHNGb3JQZXJpb2RfYWZ0ZXJfaWZfZWxzZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozMDIKICAgIC8vIGNvbnN0IHBlcmlvZFJhdGVOdW1lcmF0b3I6IHVpbnQ2NCA9IGFwciAqIHBlcmlvZFNlY29uZHMKICAgIGZyYW1lX2RpZyAyCiAgICBmcmFtZV9kaWcgMwogICAgKgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozMDYKICAgIC8vIGNvbnN0IHJld2FyZDogdWludDY0ID0gKHVzZXJTdGFrZSAqIHBlcmlvZFJhdGVOdW1lcmF0b3IpIC8gcGVyaW9kUmF0ZURlbm9taW5hdG9yCiAgICBmcmFtZV9kaWcgMQogICAgKgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozMDMKICAgIC8vIGNvbnN0IHBlcmlvZFJhdGVEZW5vbWluYXRvcjogdWludDY0ID0gMTAwMDAgKiB5ZWFySW5TZWNvbmRzCiAgICBwdXNoaW50IDExMjYyODU3MDAwMCAvLyAxMTI2Mjg1NzAwMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzA2CiAgICAvLyBjb25zdCByZXdhcmQ6IHVpbnQ2NCA9ICh1c2VyU3Rha2UgKiBwZXJpb2RSYXRlTnVtZXJhdG9yKSAvIHBlcmlvZFJhdGVEZW5vbWluYXRvcgogICAgLwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozMDgKICAgIC8vIHJldHVybiByZXdhcmQKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6QVNBU3Rha2luZ0NvbnRyYWN0LmNhbGN1bGF0ZVBlbmRpbmdSZXdhcmRzKHVzZXJBZGRyZXNzOiBieXRlcykgLT4gdWludDY0OgpjYWxjdWxhdGVQZW5kaW5nUmV3YXJkczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzE0LTMxNQogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICAvLyBwdWJsaWMgY2FsY3VsYXRlUGVuZGluZ1Jld2FyZHModXNlckFkZHJlc3M6IEFjY291bnQpOiB1aW50NjQgewogICAgcHJvdG8gMSAxCiAgICBwdXNoYnl0ZXMgIiIKICAgIGR1cG4gMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozMTYKICAgIC8vIGNvbnN0IHN0YWtlSW5mbyA9IHRoaXMuZ2V0VXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzcykKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBnZXRVc2VyU3Rha2VJbmZvCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzE4CiAgICAvLyBpZiAoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgPT09IDApIHsKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgYm56IGNhbGN1bGF0ZVBlbmRpbmdSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozMTkKICAgIC8vIHJldHVybiAwCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCmNhbGN1bGF0ZVBlbmRpbmdSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzIyCiAgICAvLyBjb25zdCBjdXJyZW50UGVyaW9kID0gdGhpcy5nZXRDdXJyZW50UGVyaW9kKCkKICAgIGNhbGxzdWIgZ2V0Q3VycmVudFBlcmlvZAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzIzCiAgICAvLyBjb25zdCBsYXN0Q2xhaW1lZFBlcmlvZCA9IHN0YWtlSW5mby5sYXN0Q2xhaW1lZFBlcmlvZC5uYXRpdmUKICAgIGZyYW1lX2RpZyAzCiAgICBpbnRjXzMgLy8gMzIKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozMjYKICAgIC8vIGNvbnN0IHBlcmlvZHNTaW5jZUxhc3RDbGFpbTogdWludDY0ID0gY3VycmVudFBlcmlvZCA+IGxhc3RDbGFpbWVkUGVyaW9kID8gY3VycmVudFBlcmlvZCAtIGxhc3RDbGFpbWVkUGVyaW9kIDogMAogICAgPgogICAgYnogY2FsY3VsYXRlUGVuZGluZ1Jld2FyZHNfdGVybmFyeV9mYWxzZUA0CiAgICBmcmFtZV9kaWcgMAogICAgZnJhbWVfZGlnIDEKICAgIC0KICAgIGZyYW1lX2J1cnkgMgoKY2FsY3VsYXRlUGVuZGluZ1Jld2FyZHNfdGVybmFyeV9tZXJnZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozMjgKICAgIC8vIGlmIChwZXJpb2RzU2luY2VMYXN0Q2xhaW0gPT09IDApIHsKICAgIGZyYW1lX2RpZyAyCiAgICBibnogY2FsY3VsYXRlUGVuZGluZ1Jld2FyZHNfYWZ0ZXJfaWZfZWxzZUA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjMyOQogICAgLy8gcmV0dXJuIDAKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKY2FsY3VsYXRlUGVuZGluZ1Jld2FyZHNfYWZ0ZXJfaWZfZWxzZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozMzMKICAgIC8vIGNvbnN0IHJld2FyZFBlclBlcmlvZCA9IHRoaXMuY2FsY3VsYXRlVXNlclJld2FyZHNGb3JQZXJpb2QodXNlckFkZHJlc3MpCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgY2FsY3VsYXRlVXNlclJld2FyZHNGb3JQZXJpb2QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzM1CiAgICAvLyByZXR1cm4gcmV3YXJkUGVyUGVyaW9kICogcGVyaW9kc1NpbmNlTGFzdENsYWltCiAgICBmcmFtZV9kaWcgMgogICAgKgogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCmNhbGN1bGF0ZVBlbmRpbmdSZXdhcmRzX3Rlcm5hcnlfZmFsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzI2CiAgICAvLyBjb25zdCBwZXJpb2RzU2luY2VMYXN0Q2xhaW06IHVpbnQ2NCA9IGN1cnJlbnRQZXJpb2QgPiBsYXN0Q2xhaW1lZFBlcmlvZCA/IGN1cnJlbnRQZXJpb2QgLSBsYXN0Q2xhaW1lZFBlcmlvZCA6IDAKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDIKICAgIGIgY2FsY3VsYXRlUGVuZGluZ1Jld2FyZHNfdGVybmFyeV9tZXJnZUA1CgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6QVNBU3Rha2luZ0NvbnRyYWN0LmRpc3RyaWJ1dGVSZXdhcmRzKHN0YWtlckFkZHJlc3NlczogYnl0ZXMpIC0+IHZvaWQ6CmRpc3RyaWJ1dGVSZXdhcmRzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozODctMzg4CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyBkaXN0cmlidXRlUmV3YXJkcyhzdGFrZXJBZGRyZXNzZXM6IGFyYzQuQWRkcmVzc1tdKTogdm9pZCB7CiAgICBwcm90byAxIDAKICAgIGludGNfMCAvLyAwCiAgICBkdXAKICAgIHB1c2hieXRlcyAiIgogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU1CiAgICAvLyBwdWJsaWMgYWRtaW5BZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBpbml0aWFsVmFsdWU6IEFjY291bnQoKX0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiYWRtaW5BZGRyZXNzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzkxCiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gYWRtaW5BZGRyLCAnT25seSBhZG1pbiBjYW4gZGlzdHJpYnV0ZSByZXdhcmRzJykKICAgIHR4biBTZW5kZXIKICAgID09CiAgICBhc3NlcnQgLy8gT25seSBhZG1pbiBjYW4gZGlzdHJpYnV0ZSByZXdhcmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM5NAogICAgLy8gYXNzZXJ0KHN0YWtlckFkZHJlc3Nlcy5sZW5ndGggPD0gNTAsICdUb28gbWFueSBzdGFrZXJzIGluIHNpbmdsZSBiYXRjaCcpCiAgICBmcmFtZV9kaWcgLTEKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZHVwCiAgICBwdXNoaW50IDUwIC8vIDUwCiAgICA8PQogICAgYXNzZXJ0IC8vIFRvbyBtYW55IHN0YWtlcnMgaW4gc2luZ2xlIGJhdGNoCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM5NgogICAgLy8gbGV0IHRvdGFsRGlzdHJpYnV0ZWQ6IHVpbnQ2NCA9IDAKICAgIGludGNfMCAvLyAwCiAgICBkdXAKCmRpc3RyaWJ1dGVSZXdhcmRzX2Zvcl9oZWFkZXJAMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6Mzk5CiAgICAvLyBmb3IgKGNvbnN0IHN0YWtlciBvZiBzdGFrZXJBZGRyZXNzZXMpIHsKICAgIGZyYW1lX2RpZyA2CiAgICBmcmFtZV9kaWcgNAogICAgPAogICAgYnogZGlzdHJpYnV0ZVJld2FyZHNfYWZ0ZXJfZm9yQDQKICAgIGZyYW1lX2RpZyAtMQogICAgZXh0cmFjdCAyIDAKICAgIGZyYW1lX2RpZyA2CiAgICBpbnRjXzMgLy8gMzIKICAgICoKICAgIGludGNfMyAvLyAzMgogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozNDMKICAgIC8vIGNvbnN0IHN0YWtlSW5mbyA9IHRoaXMuZ2V0VXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzcykKICAgIGNhbGxzdWIgZ2V0VXNlclN0YWtlSW5mbwogICAgZHVwCiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzQ2CiAgICAvLyBpZiAoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgPT09IDApIHsKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDMKICAgIGJueiBkaXN0cmlidXRlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzQ3CiAgICAvLyByZXR1cm4gMAogICAgaW50Y18wIC8vIDAKCmRpc3RyaWJ1dGVSZXdhcmRzX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6QVNBU3Rha2luZ0NvbnRyYWN0LmNvbXBvdW5kUmV3YXJkc0ZvclVzZXJAMTI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQwMQogICAgLy8gdG90YWxEaXN0cmlidXRlZCA9IHRvdGFsRGlzdHJpYnV0ZWQgKyByZXdhcmRzQ29tcG91bmRlZAogICAgZnJhbWVfZGlnIDUKICAgICsKICAgIGZyYW1lX2J1cnkgNQogICAgZnJhbWVfZGlnIDYKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDYKICAgIGIgZGlzdHJpYnV0ZVJld2FyZHNfZm9yX2hlYWRlckAxCgpkaXN0cmlidXRlUmV3YXJkc19hZnRlcl9pZl9lbHNlQDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM1MQogICAgLy8gY29uc3QgcGVuZGluZ1Jld2FyZHMgPSB0aGlzLmNhbGN1bGF0ZVBlbmRpbmdSZXdhcmRzKHVzZXJBZGRyZXNzKQogICAgZnJhbWVfZGlnIDEKICAgIGNhbGxzdWIgY2FsY3VsYXRlUGVuZGluZ1Jld2FyZHMKICAgIGR1cAogICAgZnJhbWVfYnVyeSAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM1NAogICAgLy8gaWYgKHBlbmRpbmdSZXdhcmRzID09PSAwKSB7CiAgICBibnogZGlzdHJpYnV0ZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM1NQogICAgLy8gcmV0dXJuIDAKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQwMAogICAgLy8gY29uc3QgcmV3YXJkc0NvbXBvdW5kZWQgPSB0aGlzLmNvbXBvdW5kUmV3YXJkc0ZvclVzZXIoc3Rha2VyLm5hdGl2ZSkKICAgIGIgZGlzdHJpYnV0ZVJld2FyZHNfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjpBU0FTdGFraW5nQ29udHJhY3QuY29tcG91bmRSZXdhcmRzRm9yVXNlckAxMgoKZGlzdHJpYnV0ZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2MQogICAgLy8gcHVibGljIHJld2FyZFBvb2wgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAicmV3YXJkUG9vbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM1OQogICAgLy8gaWYgKHRoaXMucmV3YXJkUG9vbC52YWx1ZSA8IHBlbmRpbmdSZXdhcmRzKSB7CiAgICBmcmFtZV9kaWcgMgogICAgPAogICAgYnogZGlzdHJpYnV0ZVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozNjAKICAgIC8vIHJldHVybiAwCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0MDAKICAgIC8vIGNvbnN0IHJld2FyZHNDb21wb3VuZGVkID0gdGhpcy5jb21wb3VuZFJld2FyZHNGb3JVc2VyKHN0YWtlci5uYXRpdmUpCiAgICBiIGRpc3RyaWJ1dGVSZXdhcmRzX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6QVNBU3Rha2luZ0NvbnRyYWN0LmNvbXBvdW5kUmV3YXJkc0ZvclVzZXJAMTIKCmRpc3RyaWJ1dGVSZXdhcmRzX2FmdGVyX2lmX2Vsc2VAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM2NAogICAgLy8gc3Rha2VJbmZvLnN0YWtlZEFtb3VudCA9IG5ldyBhcmM0LlVpbnRONjQoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgKyBwZW5kaW5nUmV3YXJkcykKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9kaWcgMgogICAgZHVwCiAgICBjb3ZlciAyCiAgICArCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgMAogICAgc3dhcAogICAgcmVwbGFjZTIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozNjcKICAgIC8vIHN0YWtlSW5mby50b3RhbFJld2FyZHNFYXJuZWQgPSBuZXcgYXJjNC5VaW50TjY0KHN0YWtlSW5mby50b3RhbFJld2FyZHNFYXJuZWQubmF0aXZlICsgcGVuZGluZ1Jld2FyZHMpCiAgICBkdXAKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIGV4dHJhY3RfdWludDY0CiAgICBkaWcgMgogICAgKwogICAgaXRvYgogICAgcmVwbGFjZTIgMjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzcwCiAgICAvLyBzdGFrZUluZm8ubGFzdENsYWltZWRQZXJpb2QgPSBuZXcgYXJjNC5VaW50TjY0KHRoaXMuZ2V0Q3VycmVudFBlcmlvZCgpKQogICAgY2FsbHN1YiBnZXRDdXJyZW50UGVyaW9kCiAgICBpdG9iCiAgICByZXBsYWNlMiAzMgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozNzMKICAgIC8vIHRoaXMuc3RvcmVVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzLCBzdGFrZUluZm8pCiAgICBmcmFtZV9kaWcgMQogICAgc3dhcAogICAgY2FsbHN1YiBzdG9yZVVzZXJTdGFrZUluZm8KICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1NgogICAgLy8gcHVibGljIHRvdGFsU3Rha2VkID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gInRvdGFsU3Rha2VkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6Mzc2CiAgICAvLyB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlID0gdGhpcy50b3RhbFN0YWtlZC52YWx1ZSArIHBlbmRpbmdSZXdhcmRzCiAgICBkaWcgMQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1NgogICAgLy8gcHVibGljIHRvdGFsU3Rha2VkID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgYnl0ZWNfMyAvLyAidG90YWxTdGFrZWQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM3NgogICAgLy8gdGhpcy50b3RhbFN0YWtlZC52YWx1ZSA9IHRoaXMudG90YWxTdGFrZWQudmFsdWUgKyBwZW5kaW5nUmV3YXJkcwogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjEKICAgIC8vIHB1YmxpYyByZXdhcmRQb29sID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gInJld2FyZFBvb2wiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozNzcKICAgIC8vIHRoaXMucmV3YXJkUG9vbC52YWx1ZSA9IHRoaXMucmV3YXJkUG9vbC52YWx1ZSAtIHBlbmRpbmdSZXdhcmRzCiAgICBkaWcgMQogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2MQogICAgLy8gcHVibGljIHJld2FyZFBvb2wgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICBieXRlY18wIC8vICJyZXdhcmRQb29sIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czozNzcKICAgIC8vIHRoaXMucmV3YXJkUG9vbC52YWx1ZSA9IHRoaXMucmV3YXJkUG9vbC52YWx1ZSAtIHBlbmRpbmdSZXdhcmRzCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0MDAKICAgIC8vIGNvbnN0IHJld2FyZHNDb21wb3VuZGVkID0gdGhpcy5jb21wb3VuZFJld2FyZHNGb3JVc2VyKHN0YWtlci5uYXRpdmUpCiAgICBiIGRpc3RyaWJ1dGVSZXdhcmRzX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6QVNBU3Rha2luZ0NvbnRyYWN0LmNvbXBvdW5kUmV3YXJkc0ZvclVzZXJAMTIKCmRpc3RyaWJ1dGVSZXdhcmRzX2FmdGVyX2ZvckA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1OAogICAgLy8gcHVibGljIGxhc3REaXN0cmlidXRpb25UaW1lID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgYnl0ZWMgOCAvLyAibGFzdERpc3RyaWJ1dGlvblRpbWUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQwNQogICAgLy8gdGhpcy5sYXN0RGlzdHJpYnV0aW9uVGltZS52YWx1ZSA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjpBU0FTdGFraW5nQ29udHJhY3QuZ2V0QWN0aXZlU3Rha2Vyc0NvdW50KHN0YWtlckFkZHJlc3NlczogYnl0ZXMpIC0+IHVpbnQ2NDoKZ2V0QWN0aXZlU3Rha2Vyc0NvdW50OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0MTItNDEzCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIHB1YmxpYyBnZXRBY3RpdmVTdGFrZXJzQ291bnQoc3Rha2VyQWRkcmVzc2VzOiBhcmM0LkFkZHJlc3NbXSk6IHVpbnQ2NCB7CiAgICBwcm90byAxIDEKICAgIHB1c2hieXRlcyAiIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0MTQKICAgIC8vIGxldCBhY3RpdmVDb3VudDogdWludDY0ID0gMAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDE2CiAgICAvLyBmb3IgKGNvbnN0IHN0YWtlciBvZiBzdGFrZXJBZGRyZXNzZXMpIHsKICAgIGZyYW1lX2RpZyAtMQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzAgLy8gMAoKZ2V0QWN0aXZlU3Rha2Vyc0NvdW50X2Zvcl9oZWFkZXJAMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDE2CiAgICAvLyBmb3IgKGNvbnN0IHN0YWtlciBvZiBzdGFrZXJBZGRyZXNzZXMpIHsKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9kaWcgMgogICAgPAogICAgYnogZ2V0QWN0aXZlU3Rha2Vyc0NvdW50X2FmdGVyX2ZvckA2CiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgMiAwCiAgICBmcmFtZV9kaWcgMwogICAgaW50Y18zIC8vIDMyCiAgICAqCiAgICBpbnRjXzMgLy8gMzIKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0MTcKICAgIC8vIGNvbnN0IHN0YWtlSW5mbyA9IHRoaXMuZ2V0VXNlclN0YWtlSW5mbyhzdGFrZXIubmF0aXZlKQogICAgY2FsbHN1YiBnZXRVc2VyU3Rha2VJbmZvCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQxOAogICAgLy8gaWYgKHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlID4gMCkgewogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9kaWcgMQogICAgZnJhbWVfYnVyeSAwCiAgICBieiBnZXRBY3RpdmVTdGFrZXJzQ291bnRfYWZ0ZXJfaWZfZWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQxOQogICAgLy8gYWN0aXZlQ291bnQgPSBhY3RpdmVDb3VudCArIDEKICAgIGZyYW1lX2RpZyAxCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSAwCgpnZXRBY3RpdmVTdGFrZXJzQ291bnRfYWZ0ZXJfaWZfZWxzZUA0OgogICAgZnJhbWVfZGlnIDAKICAgIGZyYW1lX2J1cnkgMQogICAgZnJhbWVfZGlnIDMKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDMKICAgIGIgZ2V0QWN0aXZlU3Rha2Vyc0NvdW50X2Zvcl9oZWFkZXJAMQoKZ2V0QWN0aXZlU3Rha2Vyc0NvdW50X2FmdGVyX2ZvckA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0MjMKICAgIC8vIHJldHVybiBhY3RpdmVDb3VudAogICAgZnJhbWVfZGlnIDEKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6QVNBU3Rha2luZ0NvbnRyYWN0LnVwZGF0ZUFQUihuZXdBcHJCYXNpc1BvaW50czogdWludDY0KSAtPiB2b2lkOgp1cGRhdGVBUFI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQzMC00MzEKICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIHVwZGF0ZUFQUihuZXdBcHJCYXNpc1BvaW50czogdWludDY0KTogdm9pZCB7CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTUKICAgIC8vIHB1YmxpYyBhZG1pbkFkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGluaXRpYWxWYWx1ZTogQWNjb3VudCgpfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJhZG1pbkFkZHJlc3MiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0MzQKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSBhZG1pbkFkZHIsICdPbmx5IGFkbWluIGNhbiB1cGRhdGUgQVBSJykKICAgIHR4biBTZW5kZXIKICAgID09CiAgICBhc3NlcnQgLy8gT25seSBhZG1pbiBjYW4gdXBkYXRlIEFQUgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1NwogICAgLy8gcHVibGljIGFwckJhc2lzUG9pbnRzID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgYnl0ZWMgNSAvLyAiYXByQmFzaXNQb2ludHMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQzNwogICAgLy8gdGhpcy5hcHJCYXNpc1BvaW50cy52YWx1ZSA9IG5ld0FwckJhc2lzUG9pbnRzCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjpBU0FTdGFraW5nQ29udHJhY3QudXBkYXRlQWRtaW4obmV3QWRtaW5BZGRyZXNzOiBieXRlcykgLT4gdm9pZDoKdXBkYXRlQWRtaW46CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ0NC00NDUKICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIHVwZGF0ZUFkbWluKG5ld0FkbWluQWRkcmVzczogQWNjb3VudCk6IHZvaWQgewogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU1CiAgICAvLyBwdWJsaWMgYWRtaW5BZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBpbml0aWFsVmFsdWU6IEFjY291bnQoKX0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiYWRtaW5BZGRyZXNzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDQ4CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gYWRtaW5BZGRyLCAnT25seSBhZG1pbiBjYW4gdXBkYXRlIGFkbWluJykKICAgIHR4biBTZW5kZXIKICAgID09CiAgICBhc3NlcnQgLy8gT25seSBhZG1pbiBjYW4gdXBkYXRlIGFkbWluCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU1CiAgICAvLyBwdWJsaWMgYWRtaW5BZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBpbml0aWFsVmFsdWU6IEFjY291bnQoKX0pCiAgICBieXRlY18yIC8vICJhZG1pbkFkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ1MQogICAgLy8gdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUgPSBuZXdBZG1pbkFkZHJlc3MKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OkFTQVN0YWtpbmdDb250cmFjdC5nZXRVc2VyU3RhdHModXNlckFkZHJlc3M6IGJ5dGVzKSAtPiBieXRlczoKZ2V0VXNlclN0YXRzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0NTctNDU4CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIHB1YmxpYyBnZXRVc2VyU3RhdHModXNlckFkZHJlc3M6IEFjY291bnQpOiBBcnJheTx1aW50NjQ+IHsKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0NTkKICAgIC8vIGNvbnN0IHN0YWtlSW5mbyA9IHRoaXMuZ2V0VXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzcykKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBnZXRVc2VyU3Rha2VJbmZvCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ2MAogICAgLy8gY29uc3QgcGVuZGluZ1Jld2FyZHMgPSB0aGlzLmNhbGN1bGF0ZVBlbmRpbmdSZXdhcmRzKHVzZXJBZGRyZXNzKQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIGNhbGN1bGF0ZVBlbmRpbmdSZXdhcmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ2MwogICAgLy8gc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUsCiAgICBkaWcgMQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ2NAogICAgLy8gc3Rha2VJbmZvLmZpcnN0U3Rha2VUaW1lLm5hdGl2ZSwKICAgIGRpZyAyCiAgICBwdXNoaW50IDggLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDY1CiAgICAvLyBzdGFrZUluZm8ubGFzdFN0YWtlVGltZS5uYXRpdmUsCiAgICBkaWcgMwogICAgcHVzaGludCAxNiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDY2CiAgICAvLyBzdGFrZUluZm8udG90YWxSZXdhcmRzRWFybmVkLm5hdGl2ZSwKICAgIGRpZyA0CiAgICBwdXNoaW50IDI0IC8vIDI0CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0NjgKICAgIC8vIHN0YWtlSW5mby5sYXN0Q2xhaW1lZFBlcmlvZC5uYXRpdmUsCiAgICB1bmNvdmVyIDUKICAgIGludGNfMyAvLyAzMgogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDYzCiAgICAvLyBzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSwKICAgIHVuY292ZXIgNAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0NjQKICAgIC8vIHN0YWtlSW5mby5maXJzdFN0YWtlVGltZS5uYXRpdmUsCiAgICB1bmNvdmVyIDQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDYzLTQ2OAogICAgLy8gc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUsCiAgICAvLyBzdGFrZUluZm8uZmlyc3RTdGFrZVRpbWUubmF0aXZlLAogICAgLy8gc3Rha2VJbmZvLmxhc3RTdGFrZVRpbWUubmF0aXZlLAogICAgLy8gc3Rha2VJbmZvLnRvdGFsUmV3YXJkc0Vhcm5lZC5uYXRpdmUsCiAgICAvLyBwZW5kaW5nUmV3YXJkcywKICAgIC8vIHN0YWtlSW5mby5sYXN0Q2xhaW1lZFBlcmlvZC5uYXRpdmUsCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDY1CiAgICAvLyBzdGFrZUluZm8ubGFzdFN0YWtlVGltZS5uYXRpdmUsCiAgICB1bmNvdmVyIDMKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDYzLTQ2OAogICAgLy8gc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUsCiAgICAvLyBzdGFrZUluZm8uZmlyc3RTdGFrZVRpbWUubmF0aXZlLAogICAgLy8gc3Rha2VJbmZvLmxhc3RTdGFrZVRpbWUubmF0aXZlLAogICAgLy8gc3Rha2VJbmZvLnRvdGFsUmV3YXJkc0Vhcm5lZC5uYXRpdmUsCiAgICAvLyBwZW5kaW5nUmV3YXJkcywKICAgIC8vIHN0YWtlSW5mby5sYXN0Q2xhaW1lZFBlcmlvZC5uYXRpdmUsCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDY2CiAgICAvLyBzdGFrZUluZm8udG90YWxSZXdhcmRzRWFybmVkLm5hdGl2ZSwKICAgIHVuY292ZXIgMgogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0NjMtNDY4CiAgICAvLyBzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSwKICAgIC8vIHN0YWtlSW5mby5maXJzdFN0YWtlVGltZS5uYXRpdmUsCiAgICAvLyBzdGFrZUluZm8ubGFzdFN0YWtlVGltZS5uYXRpdmUsCiAgICAvLyBzdGFrZUluZm8udG90YWxSZXdhcmRzRWFybmVkLm5hdGl2ZSwKICAgIC8vIHBlbmRpbmdSZXdhcmRzLAogICAgLy8gc3Rha2VJbmZvLmxhc3RDbGFpbWVkUGVyaW9kLm5hdGl2ZSwKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0NjcKICAgIC8vIHBlbmRpbmdSZXdhcmRzLAogICAgdW5jb3ZlciAyCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ2My00NjgKICAgIC8vIHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlLAogICAgLy8gc3Rha2VJbmZvLmZpcnN0U3Rha2VUaW1lLm5hdGl2ZSwKICAgIC8vIHN0YWtlSW5mby5sYXN0U3Rha2VUaW1lLm5hdGl2ZSwKICAgIC8vIHN0YWtlSW5mby50b3RhbFJld2FyZHNFYXJuZWQubmF0aXZlLAogICAgLy8gcGVuZGluZ1Jld2FyZHMsCiAgICAvLyBzdGFrZUluZm8ubGFzdENsYWltZWRQZXJpb2QubmF0aXZlLAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ2OAogICAgLy8gc3Rha2VJbmZvLmxhc3RDbGFpbWVkUGVyaW9kLm5hdGl2ZSwKICAgIHN3YXAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDYzLTQ2OAogICAgLy8gc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUsCiAgICAvLyBzdGFrZUluZm8uZmlyc3RTdGFrZVRpbWUubmF0aXZlLAogICAgLy8gc3Rha2VJbmZvLmxhc3RTdGFrZVRpbWUubmF0aXZlLAogICAgLy8gc3Rha2VJbmZvLnRvdGFsUmV3YXJkc0Vhcm5lZC5uYXRpdmUsCiAgICAvLyBwZW5kaW5nUmV3YXJkcywKICAgIC8vIHN0YWtlSW5mby5sYXN0Q2xhaW1lZFBlcmlvZC5uYXRpdmUsCiAgICBjb25jYXQKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDggLy8gOAogICAgLwogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0NzEKICAgIC8vIHJldHVybiByZXN1bHQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OkFTQVN0YWtpbmdDb250cmFjdC5nZXRDb250cmFjdFN0YXRzKCkgLT4gYnl0ZXM6CmdldENvbnRyYWN0U3RhdHM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU0CiAgICAvLyBwdWJsaWMgYXNzZXQgPSBHbG9iYWxTdGF0ZTxBc3NldD4oeyBpbml0aWFsVmFsdWU6IEFzc2V0KCkgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJhc3NldCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU2CiAgICAvLyBwdWJsaWMgdG90YWxTdGFrZWQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAidG90YWxTdGFrZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1NwogICAgLy8gcHVibGljIGFwckJhc2lzUG9pbnRzID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDUgLy8gImFwckJhc2lzUG9pbnRzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTgKICAgIC8vIHB1YmxpYyBsYXN0RGlzdHJpYnV0aW9uVGltZSA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA4IC8vICJsYXN0RGlzdHJpYnV0aW9uVGltZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU5CiAgICAvLyBwdWJsaWMgZGlzdHJpYnV0aW9uUGVyaW9kUm91bmRzID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDYgLy8gImRpc3RyaWJ1dGlvblBlcmlvZFJvdW5kcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYwCiAgICAvLyBwdWJsaWMgbWluaW11bVN0YWtlID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDcgLy8gIm1pbmltdW1TdGFrZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYxCiAgICAvLyBwdWJsaWMgcmV3YXJkUG9vbCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJyZXdhcmRQb29sIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDg3CiAgICAvLyB0aGlzLmdldEN1cnJlbnRQZXJpb2QoKSwKICAgIGNhbGxzdWIgZ2V0Q3VycmVudFBlcmlvZAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1NAogICAgLy8gcHVibGljIGFzc2V0ID0gR2xvYmFsU3RhdGU8QXNzZXQ+KHsgaW5pdGlhbFZhbHVlOiBBc3NldCgpIH0pCiAgICB1bmNvdmVyIDcKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTYKICAgIC8vIHB1YmxpYyB0b3RhbFN0YWtlZCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIHVuY292ZXIgNwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1Ni00ODcKICAgIC8vIHB1YmxpYyB0b3RhbFN0YWtlZCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIC8vIHB1YmxpYyBhcHJCYXNpc1BvaW50cyA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIC8vIHB1YmxpYyBsYXN0RGlzdHJpYnV0aW9uVGltZSA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIC8vIHB1YmxpYyBkaXN0cmlidXRpb25QZXJpb2RSb3VuZHMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICAvLyBwdWJsaWMgbWluaW11bVN0YWtlID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgLy8gcHVibGljIHJld2FyZFBvb2wgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICAvLyAKICAgIC8vIHB1YmxpYyBzdGFrZXJzID0gQm94TWFwPEFjY291bnQsIFVzZXJTdGFrZUluZm8+KHsga2V5UHJlZml4OiAnc3Rha2VycycgfSkKICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gcmVhZCB1c2VyIHN0YWtlIGluZm8gZnJvbSBib3ggc3RvcmFnZQogICAgLy8gICovCiAgICAvLyBwdWJsaWMgZ2V0VXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzczogQWNjb3VudCk6IFVzZXJTdGFrZUluZm8gewogICAgLy8gICBjb25zdCB1c2VyQm94ID0gdGhpcy5zdGFrZXJzKHVzZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIGlmICh1c2VyQm94LmV4aXN0cykgewogICAgLy8gICAgIHJldHVybiB1c2VyQm94LnZhbHVlLmNvcHkoKQogICAgLy8gICB9IGVsc2UgewogICAgLy8gICAgIHJldHVybiBuZXcgVXNlclN0YWtlSW5mbyh7CiAgICAvLyAgICAgICBzdGFrZWRBbW91bnQ6IG5ldyBhcmM0LlVpbnRONjQoMCksCiAgICAvLyAgICAgICBmaXJzdFN0YWtlVGltZTogbmV3IGFyYzQuVWludE42NCgwKSwKICAgIC8vICAgICAgIGxhc3RTdGFrZVRpbWU6IG5ldyBhcmM0LlVpbnRONjQoMCksCiAgICAvLyAgICAgICB0b3RhbFJld2FyZHNFYXJuZWQ6IG5ldyBhcmM0LlVpbnRONjQoMCksCiAgICAvLyAgICAgICBsYXN0Q2xhaW1lZFBlcmlvZDogbmV3IGFyYzQuVWludE42NCgwKSwKICAgIC8vICAgICB9KQogICAgLy8gICB9CiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogSGVscGVyIGZ1bmN0aW9uIHRvIHN0b3JlIHVzZXIgc3Rha2UgaW5mbyBpbiBib3ggc3RvcmFnZQogICAgLy8gICovCiAgICAvLyBwdWJsaWMgc3RvcmVVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzOiBBY2NvdW50LCBzdGFrZUluZm86IFVzZXJTdGFrZUluZm8pOiB2b2lkIHsKICAgIC8vICAgdGhpcy5zdGFrZXJzKHVzZXJBZGRyZXNzKS52YWx1ZSA9IHN0YWtlSW5mby5jb3B5KCkKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBDYWxjdWxhdGUgdGhlIGN1cnJlbnQgZGlzdHJpYnV0aW9uIHBlcmlvZAogICAgLy8gICovCiAgICAvLyBwdWJsaWMgZ2V0Q3VycmVudFBlcmlvZCgpOiB1aW50NjQgewogICAgLy8gICBjb25zdCBwZXJpb2RTZWNvbmRzID0gdGhpcy5kaXN0cmlidXRpb25QZXJpb2RSb3VuZHMudmFsdWUKICAgIC8vICAgaWYgKHBlcmlvZFNlY29uZHMgPT09IDApIHJldHVybiAwCiAgICAvLyAgIHJldHVybiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wIC8gcGVyaW9kU2Vjb25kcwogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIEluaXRpYWxpemUgdGhlIGNvbnRyYWN0IHdpdGggdGhlIEFTQSB0b2tlbiBJRCBhbmQgb3RoZXIgcGFyYW1ldGVycwogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyBpbml0aWFsaXplKAogICAgLy8gICBhc3NldDogQXNzZXQsCiAgICAvLyAgIGFkbWluQWRkcmVzczogQWNjb3VudCwKICAgIC8vICAgYXByQmFzaXNQb2ludHM6IHVpbnQ2NCwKICAgIC8vICAgZGlzdHJpYnV0aW9uUGVyaW9kU2Vjb25kczogdWludDY0LAogICAgLy8gICBtaW5pbXVtU3Rha2U6IHVpbnQ2NCwKICAgIC8vICk6IHZvaWQgewogICAgLy8gICAvLyBFbnN1cmUgdGhpcyBpcyBvbmx5IGNhbGxlZCBkdXJpbmcgY29udHJhY3QgY3JlYXRpb24KICAgIC8vICAgYXNzZXJ0KHRoaXMuYXNzZXQudmFsdWUgPT09IEFzc2V0KCksICdBbHJlYWR5IGluaXRpYWxpemVkJykKICAgIC8vIAogICAgLy8gICAvLyBFbnN1cmUgb25seSB0aGUgY3JlYXRvciBjYW4gaW5pdGlhbGl6ZQogICAgLy8gICBhc3NlcnQoVHhuLnNlbmRlciA9PT0gR2xvYmFsLmNyZWF0b3JBZGRyZXNzLCAnT25seSBjcmVhdG9yIGNhbiBpbml0aWFsaXplJykKICAgIC8vIAogICAgLy8gICAvLyBTdG9yZSB0aGUgaW5pdGlhbCBwYXJhbWV0ZXJzCiAgICAvLyAgIHRoaXMuYXNzZXQudmFsdWUgPSBhc3NldAogICAgLy8gICB0aGlzLmFkbWluQWRkcmVzcy52YWx1ZSA9IGFkbWluQWRkcmVzcwogICAgLy8gICB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlID0gMAogICAgLy8gICB0aGlzLmFwckJhc2lzUG9pbnRzLnZhbHVlID0gYXByQmFzaXNQb2ludHMKICAgIC8vICAgdGhpcy5sYXN0RGlzdHJpYnV0aW9uVGltZS52YWx1ZSA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIC8vICAgdGhpcy5kaXN0cmlidXRpb25QZXJpb2RSb3VuZHMudmFsdWUgPSBkaXN0cmlidXRpb25QZXJpb2RTZWNvbmRzCiAgICAvLyAgIHRoaXMubWluaW11bVN0YWtlLnZhbHVlID0gbWluaW11bVN0YWtlCiAgICAvLyAgIHRoaXMucmV3YXJkUG9vbC52YWx1ZSA9IDAKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBPcHQgdGhlIGNvbnRyYWN0IGludG8gdGhlIEFTQQogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyBvcHRJblRvQXNzZXQoKTogdm9pZCB7CiAgICAvLyAgIC8vIEVuc3VyZSBvbmx5IHRoZSBjcmVhdG9yIG9yIGFkbWluIGNhbiBvcHQgaW4KICAgIC8vICAgY29uc3QgYWRtaW5BZGRyID0gdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUKICAgIC8vICAgYXNzZXJ0KFR4bi5zZW5kZXIgPT09IEdsb2JhbC5jcmVhdG9yQWRkcmVzcyB8fCBUeG4uc2VuZGVyID09PSBhZG1pbkFkZHIsICdPbmx5IGNyZWF0b3Igb3IgYWRtaW4gY2FuIG9wdCBpbicpCiAgICAvLyAKICAgIC8vICAgLy8gT3B0IHRoZSBjb250cmFjdCBpbnRvIHRoZSBBU0EKICAgIC8vICAgY29uc3QgYXNzZXQgPSB0aGlzLmFzc2V0LnZhbHVlCiAgICAvLyAgIGl0eG4KICAgIC8vICAgICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICAgIGFzc2V0QW1vdW50OiAwLAogICAgLy8gICAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgICB9KQogICAgLy8gICAgIC5zdWJtaXQoKQogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIFN0YWtlIHRva2VucwogICAgLy8gICogUmVxdWlyZXMgYSBjb21wYW5pb24gQVNBIHRyYW5zZmVyIHRyYW5zYWN0aW9uCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIHN0YWtlKCk6IHZvaWQgewogICAgLy8gICAvLyBFbnN1cmUgdGhlIGNvbnRyYWN0IGhhcyBvcHRlZCBpbnRvIHRoZSBBU0EKICAgIC8vICAgY29uc3QgYXNzZXQgPSB0aGlzLmFzc2V0LnZhbHVlCiAgICAvLyAgIGFzc2VydCh0aGlzLmFzc2V0LnZhbHVlICE9PSBBc3NldCgpLCAnQ29udHJhY3Qgbm90IGluaXRpYWxpemVkJykKICAgIC8vIAogICAgLy8gICAvLyBFbnN1cmUgdGhpcyBjYWxsIGhhcyBhIGNvbXBhbmlvbiBBU0EgdHJhbnNmZXIgdHJhbnNhY3Rpb24KICAgIC8vICAgYXNzZXJ0KEdsb2JhbC5ncm91cFNpemUgPT09IDIsICdFeHBlY3RlZCAyIHR4bnMgaW4gZ3JvdXAnKQogICAgLy8gCiAgICAvLyAgIC8vIEdldCB0aGUgQVNBIHRyYW5zZmVyIGRldGFpbHMKICAgIC8vICAgY29uc3QgeGZlclR4biA9IGd0eG4uQXNzZXRUcmFuc2ZlclR4bigwKQogICAgLy8gICBhc3NlcnQoeGZlclR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXNzZXRUcmFuc2ZlciwgJ1RyYW5zYWN0aW9uIDAgbXVzdCBiZSBhc3NldCB0cmFuc2ZlcicpCiAgICAvLyAgIGFzc2VydCh4ZmVyVHhuLmFzc2V0UmVjZWl2ZXIgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLCAnQXNzZXQgdHJhbnNmZXIgbXVzdCBiZSB0byBjb250cmFjdCcpCiAgICAvLyAgIGFzc2VydCh4ZmVyVHhuLmFzc2V0QW1vdW50ID4gMCwgJ011c3Qgc3Rha2Ugbm9uLXplcm8gYW1vdW50JykKICAgIC8vICAgYXNzZXJ0KHhmZXJUeG4ueGZlckFzc2V0ID09PSBhc3NldCwgJ0luY29ycmVjdCBhc3NldCBJRCcpCiAgICAvLyAKICAgIC8vICAgLy8gR2V0IHRoZSBzdGFrZSBhbW91bnQgZnJvbSB0aGUgdHJhbnNhY3Rpb24KICAgIC8vICAgY29uc3Qgc3Rha2VBbW91bnQgPSB4ZmVyVHhuLmFzc2V0QW1vdW50CiAgICAvLyAgIGNvbnN0IG1pbmltdW1TdGFrZSA9IHRoaXMubWluaW11bVN0YWtlLnZhbHVlCiAgICAvLyAKICAgIC8vICAgLy8gR2V0IHRoZSBjdXJyZW50IHVzZXIgc3Rha2UgaW5mbwogICAgLy8gICBjb25zdCBzZW5kZXJBZGRyZXNzID0gVHhuLnNlbmRlcgogICAgLy8gICBjb25zdCBzdGFrZUluZm8gPSB0aGlzLmdldFVzZXJTdGFrZUluZm8oc2VuZGVyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICAvLyBJZiB0aGlzIGlzIGEgbmV3IHN0YWtlLCBlbnN1cmUgaXQgbWVldHMgbWluaW11bQogICAgLy8gICBpZiAoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgPT09IDApIHsKICAgIC8vICAgICBhc3NlcnQoc3Rha2VBbW91bnQgPj0gbWluaW11bVN0YWtlLCAnSW5pdGlhbCBzdGFrZSBiZWxvdyBtaW5pbXVtJykKICAgIC8vICAgICAvLyBTZXQgdGhlIGluaXRpYWwgY2xhaW0gcGVyaW9kIHRvIGN1cnJlbnQgcGVyaW9kCiAgICAvLyAgICAgc3Rha2VJbmZvLmxhc3RDbGFpbWVkUGVyaW9kID0gbmV3IGFyYzQuVWludE42NCh0aGlzLmdldEN1cnJlbnRQZXJpb2QoKSkKICAgIC8vICAgICAvLyBTZXQgdGhlIGZpcnN0IHN0YWtlIHRpbWUgKHRoaXMgbmV2ZXIgY2hhbmdlcyBhZnRlciBpbml0aWFsIHN0YWtlKQogICAgLy8gICAgIHN0YWtlSW5mby5maXJzdFN0YWtlVGltZSA9IG5ldyBhcmM0LlVpbnRONjQoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCkKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBzdGFrZSBpbmZvCiAgICAvLyAgIHN0YWtlSW5mby5zdGFrZWRBbW91bnQgPSBuZXcgYXJjNC5VaW50TjY0KHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlICsgc3Rha2VBbW91bnQpCiAgICAvLyAgIHN0YWtlSW5mby5sYXN0U3Rha2VUaW1lID0gbmV3IGFyYzQuVWludE42NChHbG9iYWwubGF0ZXN0VGltZXN0YW1wKQogICAgLy8gCiAgICAvLyAgIC8vIFN0b3JlIHVwZGF0ZWQgc3Rha2UgaW5mbwogICAgLy8gICB0aGlzLnN0b3JlVXNlclN0YWtlSW5mbyhzZW5kZXJBZGRyZXNzLCBzdGFrZUluZm8pCiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIGdsb2JhbCBzdGF0ZQogICAgLy8gICB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlID0gdGhpcy50b3RhbFN0YWtlZC52YWx1ZSArIHN0YWtlQW1vdW50CiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogV2l0aGRyYXcgc3Rha2VkIHRva2VucwogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyB3aXRoZHJhdyhhbW91bnQ6IHVpbnQ2NCk6IHZvaWQgewogICAgLy8gICBjb25zdCBzZW5kZXJBZGRyZXNzID0gVHhuLnNlbmRlcgogICAgLy8gICBjb25zdCBzdGFrZUluZm8gPSB0aGlzLmdldFVzZXJTdGFrZUluZm8oc2VuZGVyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICAvLyBFbnN1cmUgdXNlciBoYXMgZW5vdWdoIHN0YWtlZAogICAgLy8gICBhc3NlcnQoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgPiAwLCAnTm8gc3Rha2UgZm91bmQnKQogICAgLy8gICBhc3NlcnQoYW1vdW50IDw9IHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlLCAnV2l0aGRyYXdhbCBhbW91bnQgZXhjZWVkcyBzdGFrZScpCiAgICAvLyAgIGFzc2VydChhbW91bnQgPiAwLCAnV2l0aGRyYXdhbCBhbW91bnQgbXVzdCBiZSBwb3NpdGl2ZScpCiAgICAvLyAKICAgIC8vICAgLy8gSWYgd2l0aGRyYXdpbmcgYWxsLCBubyBuZWVkIHRvIGNoZWNrIG1pbmltdW0gcmVtYWluaW5nCiAgICAvLyAgIC8vIElmIHBhcnRpYWwgd2l0aGRyYXdhbCwgZW5zdXJlIHJlbWFpbmluZyBzdGFrZSBtZWV0cyBtaW5pbXVtCiAgICAvLyAgIGlmIChhbW91bnQgPCBzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSkgewogICAgLy8gICAgIGNvbnN0IHJlbWFpbmluZ1N0YWtlOiB1aW50NjQgPSBzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSAtIGFtb3VudAogICAgLy8gICAgIGNvbnN0IG1pbmltdW1TdGFrZSA9IHRoaXMubWluaW11bVN0YWtlLnZhbHVlCiAgICAvLyAgICAgYXNzZXJ0KHJlbWFpbmluZ1N0YWtlID49IG1pbmltdW1TdGFrZSwgJ1JlbWFpbmluZyBzdGFrZSB3b3VsZCBiZSBiZWxvdyBtaW5pbXVtJykKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBzdGFrZSBpbmZvCiAgICAvLyAgIHN0YWtlSW5mby5zdGFrZWRBbW91bnQgPSBuZXcgYXJjNC5VaW50TjY0KHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlIC0gYW1vdW50KQogICAgLy8gCiAgICAvLyAgIC8vIFN0b3JlIHVwZGF0ZWQgc3Rha2UgaW5mbwogICAgLy8gICB0aGlzLnN0b3JlVXNlclN0YWtlSW5mbyhzZW5kZXJBZGRyZXNzLCBzdGFrZUluZm8pCiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIGdsb2JhbCBzdGF0ZQogICAgLy8gICB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlID0gdGhpcy50b3RhbFN0YWtlZC52YWx1ZSAtIGFtb3VudAogICAgLy8gCiAgICAvLyAgIC8vIFRyYW5zZmVyIHRva2VucyBiYWNrIHRvIHVzZXIKICAgIC8vICAgY29uc3QgYXNzZXQgPSB0aGlzLmFzc2V0LnZhbHVlCiAgICAvLyAgIGl0eG4KICAgIC8vICAgICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiBUeG4uc2VuZGVyLAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgICAgICBmZWU6IDEwMDAsCiAgICAvLyAgICAgfSkKICAgIC8vICAgICAuc3VibWl0KCkKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBBZGQgcmV3YXJkcyB0byB0aGUgcmV3YXJkIHBvb2wKICAgIC8vICAqIE9ubHkgdGhlIGFkbWluIGNhbiBjYWxsIHRoaXMKICAgIC8vICAqIFJlcXVpcmVzIGEgY29tcGFuaW9uIEFTQSB0cmFuc2ZlciB0cmFuc2FjdGlvbiB3aXRoIHRoZSByZXdhcmRzCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIGFkZFJld2FyZHMoKTogdm9pZCB7CiAgICAvLyAgIC8vIEVuc3VyZSBvbmx5IGFkbWluIGNhbiBhZGQgcmV3YXJkcwogICAgLy8gICBjb25zdCBhZG1pbkFkZHIgPSB0aGlzLmFkbWluQWRkcmVzcy52YWx1ZQogICAgLy8gICBhc3NlcnQoVHhuLnNlbmRlciA9PT0gYWRtaW5BZGRyLCAnT25seSBhZG1pbiBjYW4gYWRkIHJld2FyZHMnKQogICAgLy8gCiAgICAvLyAgIC8vIEVuc3VyZSB0aGlzIGNhbGwgaGFzIGEgY29tcGFuaW9uIEFTQSB0cmFuc2ZlciB0cmFuc2FjdGlvbiB3aXRoIHJld2FyZHMKICAgIC8vICAgYXNzZXJ0KEdsb2JhbC5ncm91cFNpemUgPT09IDIsICdFeHBlY3RlZCAyIHR4bnMgaW4gZ3JvdXAnKQogICAgLy8gCiAgICAvLyAgIC8vIEdldCB0aGUgQVNBIHRyYW5zZmVyIGRldGFpbHMKICAgIC8vICAgY29uc3QgYXNzZXQgPSB0aGlzLmFzc2V0LnZhbHVlCiAgICAvLyAgIGNvbnN0IHhmZXJUeG4gPSBndHhuLkFzc2V0VHJhbnNmZXJUeG4oMCkKICAgIC8vICAgYXNzZXJ0KHhmZXJUeG4udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFzc2V0VHJhbnNmZXIsICdUcmFuc2FjdGlvbiAwIG11c3QgYmUgYXNzZXQgdHJhbnNmZXInKQogICAgLy8gICBhc3NlcnQoeGZlclR4bi5hc3NldFJlY2VpdmVyID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywgJ0Fzc2V0IHRyYW5zZmVyIG11c3QgYmUgdG8gY29udHJhY3QnKQogICAgLy8gICBhc3NlcnQoeGZlclR4bi5hc3NldEFtb3VudCA+IDAsICdNdXN0IHByb3ZpZGUgbm9uLXplcm8gcmV3YXJkcycpCiAgICAvLyAgIGFzc2VydCh4ZmVyVHhuLnhmZXJBc3NldCA9PT0gYXNzZXQsICdJbmNvcnJlY3QgYXNzZXQgSUQnKQogICAgLy8gCiAgICAvLyAgIC8vIEFkZCByZXdhcmRzIHRvIHRoZSBwb29sCiAgICAvLyAgIHRoaXMucmV3YXJkUG9vbC52YWx1ZSA9IHRoaXMucmV3YXJkUG9vbC52YWx1ZSArIHhmZXJUeG4uYXNzZXRBbW91bnQKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBDYWxjdWxhdGUgcmV3YXJkcyBmb3IgYSBzcGVjaWZpYyB1c2VyIGZvciBhIGdpdmVuIHBlcmlvZAogICAgLy8gICogVGhpcyBjYWxjdWxhdGVzIHJld2FyZHMgcGVyIGRpc3RyaWJ1dGlvbiBwZXJpb2QKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICAvLyBwdWJsaWMgY2FsY3VsYXRlVXNlclJld2FyZHNGb3JQZXJpb2QodXNlckFkZHJlc3M6IEFjY291bnQpOiB1aW50NjQgewogICAgLy8gICBjb25zdCBhcHIgPSB0aGlzLmFwckJhc2lzUG9pbnRzLnZhbHVlCiAgICAvLyAgIGNvbnN0IHRvdGFsU3Rha2VkID0gdGhpcy50b3RhbFN0YWtlZC52YWx1ZQogICAgLy8gICBjb25zdCBwZXJpb2RTZWNvbmRzID0gdGhpcy5kaXN0cmlidXRpb25QZXJpb2RSb3VuZHMudmFsdWUKICAgIC8vIAogICAgLy8gICAvLyBJZiBubyB0b3RhbCBzdGFrZSBvciBubyBwZXJpb2QgZGVmaW5lZCwgcmV0dXJuIDAKICAgIC8vICAgaWYgKHRvdGFsU3Rha2VkID09PSAwIHx8IHBlcmlvZFNlY29uZHMgPT09IDApIHsKICAgIC8vICAgICByZXR1cm4gMAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gR2V0IHRoZSB1c2VyJ3Mgc3Rha2UgaW5mbwogICAgLy8gICBjb25zdCBzdGFrZUluZm8gPSB0aGlzLmdldFVzZXJTdGFrZUluZm8odXNlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgLy8gSWYgdXNlciBoYXMgbm8gc3Rha2UsIHJldHVybiAwCiAgICAvLyAgIGlmIChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSA9PT0gMCkgewogICAgLy8gICAgIHJldHVybiAwCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBHZXQgdXNlcidzIHN0YWtlIGFtb3VudCBhbmQgZmlyc3Qgc3Rha2UgdGltZQogICAgLy8gICBjb25zdCB1c2VyU3Rha2UgPSBzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZQogICAgLy8gICBjb25zdCBmaXJzdFN0YWtlVGltZSA9IHN0YWtlSW5mby5maXJzdFN0YWtlVGltZS5uYXRpdmUKICAgIC8vIAogICAgLy8gICAvLyBDaGVjayBpZiB1c2VyIGhhcyBiZWVuIHN0YWtlZCBmb3IgdGhlIG1pbmltdW0gcGVyaW9kICh1c2luZyBmaXJzdCBzdGFrZSB0aW1lKQogICAgLy8gICBjb25zdCBtaW5pbXVtU3Rha2VUaW1lOiB1aW50NjQgPSBST1VORFNfUEVSX0RBWQogICAgLy8gICBpZiAoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA8IGZpcnN0U3Rha2VUaW1lICsgbWluaW11bVN0YWtlVGltZSkgewogICAgLy8gICAgIHJldHVybiAwCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBDYWxjdWxhdGUgcmV3YXJkIHJhdGUgZm9yIHRoZSBwZXJpb2QKICAgIC8vICAgLy8gQVBSIGlzIGluIGJhc2lzIHBvaW50cyAoZS5nLiwgNTAwID0gNSUpCiAgICAvLyAgIC8vIENvbnZlcnQgQVBSIHRvIHBlcmlvZCByYXRlOiAoQVBSIC8gMTAwMDApICogKHBlcmlvZFNlY29uZHMgLyAzMTUzNjAwMCkKICAgIC8vICAgLy8gd2hlcmUgMzE1MzYwMDAgaXMgc2Vjb25kcyBpbiBhIHllYXIKICAgIC8vICAgY29uc3QgeWVhckluU2Vjb25kczogdWludDY0ID0gUk9VTkRTX1BFUl9ZRUFSCiAgICAvLyAgIGNvbnN0IHBlcmlvZFJhdGVOdW1lcmF0b3I6IHVpbnQ2NCA9IGFwciAqIHBlcmlvZFNlY29uZHMKICAgIC8vICAgY29uc3QgcGVyaW9kUmF0ZURlbm9taW5hdG9yOiB1aW50NjQgPSAxMDAwMCAqIHllYXJJblNlY29uZHMKICAgIC8vIAogICAgLy8gICAvLyBDYWxjdWxhdGUgcmV3YXJkOiB1c2VyU3Rha2UgKiBwZXJpb2RSYXRlCiAgICAvLyAgIGNvbnN0IHJld2FyZDogdWludDY0ID0gKHVzZXJTdGFrZSAqIHBlcmlvZFJhdGVOdW1lcmF0b3IpIC8gcGVyaW9kUmF0ZURlbm9taW5hdG9yCiAgICAvLyAKICAgIC8vICAgcmV0dXJuIHJld2FyZAogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIENhbGN1bGF0ZSBwZW5kaW5nIHJld2FyZHMgZm9yIGEgdXNlciBzaW5jZSB0aGVpciBsYXN0IGNsYWltCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgLy8gcHVibGljIGNhbGN1bGF0ZVBlbmRpbmdSZXdhcmRzKHVzZXJBZGRyZXNzOiBBY2NvdW50KTogdWludDY0IHsKICAgIC8vICAgY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIGlmIChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSA9PT0gMCkgewogICAgLy8gICAgIHJldHVybiAwCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICBjb25zdCBjdXJyZW50UGVyaW9kID0gdGhpcy5nZXRDdXJyZW50UGVyaW9kKCkKICAgIC8vICAgY29uc3QgbGFzdENsYWltZWRQZXJpb2QgPSBzdGFrZUluZm8ubGFzdENsYWltZWRQZXJpb2QubmF0aXZlCiAgICAvLyAKICAgIC8vICAgLy8gQ2FsY3VsYXRlIHBlcmlvZHMgc2luY2UgbGFzdCBjbGFpbQogICAgLy8gICBjb25zdCBwZXJpb2RzU2luY2VMYXN0Q2xhaW06IHVpbnQ2NCA9IGN1cnJlbnRQZXJpb2QgPiBsYXN0Q2xhaW1lZFBlcmlvZCA/IGN1cnJlbnRQZXJpb2QgLSBsYXN0Q2xhaW1lZFBlcmlvZCA6IDAKICAgIC8vIAogICAgLy8gICBpZiAocGVyaW9kc1NpbmNlTGFzdENsYWltID09PSAwKSB7CiAgICAvLyAgICAgcmV0dXJuIDAKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIENhbGN1bGF0ZSByZXdhcmQgcGVyIHBlcmlvZAogICAgLy8gICBjb25zdCByZXdhcmRQZXJQZXJpb2QgPSB0aGlzLmNhbGN1bGF0ZVVzZXJSZXdhcmRzRm9yUGVyaW9kKHVzZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIHJldHVybiByZXdhcmRQZXJQZXJpb2QgKiBwZXJpb2RzU2luY2VMYXN0Q2xhaW0KICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29tcG91bmQgcmV3YXJkcyBmb3IgYSBzaW5nbGUgdXNlcgogICAgLy8gICogVXNlZCBieSB0aGUgYXV0b21hdGVkIGRpc3RyaWJ1dGlvbiBzeXN0ZW0KICAgIC8vICAqLwogICAgLy8gcHJpdmF0ZSBjb21wb3VuZFJld2FyZHNGb3JVc2VyKHVzZXJBZGRyZXNzOiBBY2NvdW50KTogdWludDY0IHsKICAgIC8vICAgY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIC8vIFNraXAgaWYgdXNlciBoYXMgbm8gc3Rha2UKICAgIC8vICAgaWYgKHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlID09PSAwKSB7CiAgICAvLyAgICAgcmV0dXJuIDAKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIENhbGN1bGF0ZSBwZW5kaW5nIHJld2FyZHMKICAgIC8vICAgY29uc3QgcGVuZGluZ1Jld2FyZHMgPSB0aGlzLmNhbGN1bGF0ZVBlbmRpbmdSZXdhcmRzKHVzZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIC8vIFNraXAgaWYgbm8gcmV3YXJkcyB0byBjb21wb3VuZAogICAgLy8gICBpZiAocGVuZGluZ1Jld2FyZHMgPT09IDApIHsKICAgIC8vICAgICByZXR1cm4gMAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gU2tpcCBpZiByZXdhcmQgcG9vbCBoYXMgaW5zdWZmaWNpZW50IGZ1bmRzIGZvciB0aGlzIHVzZXIKICAgIC8vICAgaWYgKHRoaXMucmV3YXJkUG9vbC52YWx1ZSA8IHBlbmRpbmdSZXdhcmRzKSB7CiAgICAvLyAgICAgcmV0dXJuIDAKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIEF1dG8tY29tcG91bmQ6IEFkZCByZXdhcmRzIHRvIHN0YWtlZCBhbW91bnQKICAgIC8vICAgc3Rha2VJbmZvLnN0YWtlZEFtb3VudCA9IG5ldyBhcmM0LlVpbnRONjQoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgKyBwZW5kaW5nUmV3YXJkcykKICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgdG90YWwgcmV3YXJkcyBlYXJuZWQKICAgIC8vICAgc3Rha2VJbmZvLnRvdGFsUmV3YXJkc0Vhcm5lZCA9IG5ldyBhcmM0LlVpbnRONjQoc3Rha2VJbmZvLnRvdGFsUmV3YXJkc0Vhcm5lZC5uYXRpdmUgKyBwZW5kaW5nUmV3YXJkcykKICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgbGFzdCBjbGFpbWVkIHBlcmlvZCB0byBjdXJyZW50IHBlcmlvZAogICAgLy8gICBzdGFrZUluZm8ubGFzdENsYWltZWRQZXJpb2QgPSBuZXcgYXJjNC5VaW50TjY0KHRoaXMuZ2V0Q3VycmVudFBlcmlvZCgpKQogICAgLy8gCiAgICAvLyAgIC8vIFN0b3JlIHVwZGF0ZWQgc3Rha2UgaW5mbwogICAgLy8gICB0aGlzLnN0b3JlVXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzcywgc3Rha2VJbmZvKQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBnbG9iYWwgc3RhdGUKICAgIC8vICAgdGhpcy50b3RhbFN0YWtlZC52YWx1ZSA9IHRoaXMudG90YWxTdGFrZWQudmFsdWUgKyBwZW5kaW5nUmV3YXJkcwogICAgLy8gICB0aGlzLnJld2FyZFBvb2wudmFsdWUgPSB0aGlzLnJld2FyZFBvb2wudmFsdWUgLSBwZW5kaW5nUmV3YXJkcwogICAgLy8gCiAgICAvLyAgIHJldHVybiBwZW5kaW5nUmV3YXJkcwogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIERpc3RyaWJ1dGUgYW5kIGNvbXBvdW5kIHJld2FyZHMgZm9yIG11bHRpcGxlIHN0YWtlcnMKICAgIC8vICAqIFRoaXMgbWV0aG9kIGlzIGRlc2lnbmVkIHRvIGJlIGNhbGxlZCBieSBhIGNyb24gam9iIG9uIGEgZGFpbHkgYmFzaXMKICAgIC8vICAqIE9ubHkgYWRtaW4gY2FuIGNhbGwgdGhpcyBtZXRob2QKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgZGlzdHJpYnV0ZVJld2FyZHMoc3Rha2VyQWRkcmVzc2VzOiBhcmM0LkFkZHJlc3NbXSk6IHZvaWQgewogICAgLy8gICAvLyBFbnN1cmUgb25seSBhZG1pbiBjYW4gZGlzdHJpYnV0ZSByZXdhcmRzCiAgICAvLyAgIGNvbnN0IGFkbWluQWRkciA9IHRoaXMuYWRtaW5BZGRyZXNzLnZhbHVlCiAgICAvLyAgIGFzc2VydChUeG4uc2VuZGVyID09PSBhZG1pbkFkZHIsICdPbmx5IGFkbWluIGNhbiBkaXN0cmlidXRlIHJld2FyZHMnKQogICAgLy8gCiAgICAvLyAgIC8vIEVuc3VyZSB3ZSBkb24ndCBwcm9jZXNzIHRvbyBtYW55IHN0YWtlcnMgaW4gb25lIGNhbGwgKGdhcyBsaW1pdCBwcm90ZWN0aW9uKQogICAgLy8gICBhc3NlcnQoc3Rha2VyQWRkcmVzc2VzLmxlbmd0aCA8PSA1MCwgJ1RvbyBtYW55IHN0YWtlcnMgaW4gc2luZ2xlIGJhdGNoJykKICAgIC8vIAogICAgLy8gICBsZXQgdG90YWxEaXN0cmlidXRlZDogdWludDY0ID0gMAogICAgLy8gCiAgICAvLyAgIC8vIFByb2Nlc3MgZWFjaCBzdGFrZXIKICAgIC8vICAgZm9yIChjb25zdCBzdGFrZXIgb2Ygc3Rha2VyQWRkcmVzc2VzKSB7CiAgICAvLyAgICAgY29uc3QgcmV3YXJkc0NvbXBvdW5kZWQgPSB0aGlzLmNvbXBvdW5kUmV3YXJkc0ZvclVzZXIoc3Rha2VyLm5hdGl2ZSkKICAgIC8vICAgICB0b3RhbERpc3RyaWJ1dGVkID0gdG90YWxEaXN0cmlidXRlZCArIHJld2FyZHNDb21wb3VuZGVkCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgbGFzdCBkaXN0cmlidXRpb24gdGltZQogICAgLy8gICB0aGlzLmxhc3REaXN0cmlidXRpb25UaW1lLnZhbHVlID0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcAogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIEdldCBhbGwgbm9uLXplcm8gc3Rha2VycyBjb3VudCAoZm9yIG1vbml0b3JpbmcgcHVycG9zZXMpCiAgICAvLyAgKiBOb3RlOiBUaGlzIGRvZXNuJ3QgcmV0dXJuIHRoZSBhY3R1YWwgYWRkcmVzc2VzIGR1ZSB0byBib3ggaXRlcmF0aW9uIGxpbWl0YXRpb25zCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgLy8gcHVibGljIGdldEFjdGl2ZVN0YWtlcnNDb3VudChzdGFrZXJBZGRyZXNzZXM6IGFyYzQuQWRkcmVzc1tdKTogdWludDY0IHsKICAgIC8vICAgbGV0IGFjdGl2ZUNvdW50OiB1aW50NjQgPSAwCiAgICAvLyAKICAgIC8vICAgZm9yIChjb25zdCBzdGFrZXIgb2Ygc3Rha2VyQWRkcmVzc2VzKSB7CiAgICAvLyAgICAgY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHN0YWtlci5uYXRpdmUpCiAgICAvLyAgICAgaWYgKHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlID4gMCkgewogICAgLy8gICAgICAgYWN0aXZlQ291bnQgPSBhY3RpdmVDb3VudCArIDEKICAgIC8vICAgICB9CiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICByZXR1cm4gYWN0aXZlQ291bnQKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBVcGRhdGUgdGhlIEFQUiBiYXNpcyBwb2ludHMKICAgIC8vICAqIE9ubHkgdGhlIGFkbWluIGNhbiBjYWxsIHRoaXMKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgdXBkYXRlQVBSKG5ld0FwckJhc2lzUG9pbnRzOiB1aW50NjQpOiB2b2lkIHsKICAgIC8vICAgLy8gRW5zdXJlIG9ubHkgYWRtaW4gY2FuIHVwZGF0ZSBBUFIKICAgIC8vICAgY29uc3QgYWRtaW5BZGRyID0gdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUKICAgIC8vICAgYXNzZXJ0KFR4bi5zZW5kZXIgPT09IGFkbWluQWRkciwgJ09ubHkgYWRtaW4gY2FuIHVwZGF0ZSBBUFInKQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBBUFIKICAgIC8vICAgdGhpcy5hcHJCYXNpc1BvaW50cy52YWx1ZSA9IG5ld0FwckJhc2lzUG9pbnRzCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogVXBkYXRlIHRoZSBhZG1pbiBhZGRyZXNzCiAgICAvLyAgKiBPbmx5IHRoZSBjdXJyZW50IGFkbWluIGNhbiBjYWxsIHRoaXMKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgdXBkYXRlQWRtaW4obmV3QWRtaW5BZGRyZXNzOiBBY2NvdW50KTogdm9pZCB7CiAgICAvLyAgIC8vIEVuc3VyZSBvbmx5IGFkbWluIGNhbiB1cGRhdGUgYWRtaW4KICAgIC8vICAgY29uc3QgYWRtaW5BZGRyID0gdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUKICAgIC8vICAgYXNzZXJ0KFR4bi5zZW5kZXIgPT09IGFkbWluQWRkciwgJ09ubHkgYWRtaW4gY2FuIHVwZGF0ZSBhZG1pbicpCiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIGFkbWluIGFkZHJlc3MKICAgIC8vICAgdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUgPSBuZXdBZG1pbkFkZHJlc3MKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBHZXQgY3VycmVudCBzdGFraW5nIHN0YXRpc3RpY3MgZm9yIGEgdXNlcgogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIHB1YmxpYyBnZXRVc2VyU3RhdHModXNlckFkZHJlc3M6IEFjY291bnQpOiBBcnJheTx1aW50NjQ+IHsKICAgIC8vICAgY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzKQogICAgLy8gICBjb25zdCBwZW5kaW5nUmV3YXJkcyA9IHRoaXMuY2FsY3VsYXRlUGVuZGluZ1Jld2FyZHModXNlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgY29uc3QgcmVzdWx0OiB1aW50NjRbXSA9IFsKICAgIC8vICAgICBzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSwKICAgIC8vICAgICBzdGFrZUluZm8uZmlyc3RTdGFrZVRpbWUubmF0aXZlLAogICAgLy8gICAgIHN0YWtlSW5mby5sYXN0U3Rha2VUaW1lLm5hdGl2ZSwKICAgIC8vICAgICBzdGFrZUluZm8udG90YWxSZXdhcmRzRWFybmVkLm5hdGl2ZSwKICAgIC8vICAgICBwZW5kaW5nUmV3YXJkcywKICAgIC8vICAgICBzdGFrZUluZm8ubGFzdENsYWltZWRQZXJpb2QubmF0aXZlLAogICAgLy8gICBdCiAgICAvLyAKICAgIC8vICAgcmV0dXJuIHJlc3VsdAogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIEdldCBjb250cmFjdCBnbG9iYWwgc3RhdGlzdGljcwogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIHB1YmxpYyBnZXRDb250cmFjdFN0YXRzKCk6IEFycmF5PHVpbnQ2ND4gewogICAgLy8gICBjb25zdCByZXN1bHQ6IHVpbnQ2NFtdID0gWwogICAgLy8gICAgIHRoaXMuYXNzZXQudmFsdWUuaWQsCiAgICAvLyAgICAgdGhpcy50b3RhbFN0YWtlZC52YWx1ZSwKICAgIC8vICAgICB0aGlzLmFwckJhc2lzUG9pbnRzLnZhbHVlLAogICAgLy8gICAgIHRoaXMubGFzdERpc3RyaWJ1dGlvblRpbWUudmFsdWUsCiAgICAvLyAgICAgdGhpcy5kaXN0cmlidXRpb25QZXJpb2RSb3VuZHMudmFsdWUsCiAgICAvLyAgICAgdGhpcy5taW5pbXVtU3Rha2UudmFsdWUsCiAgICAvLyAgICAgdGhpcy5yZXdhcmRQb29sLnZhbHVlLAogICAgLy8gICAgIHRoaXMuZ2V0Q3VycmVudFBlcmlvZCgpLAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU3CiAgICAvLyBwdWJsaWMgYXByQmFzaXNQb2ludHMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICB1bmNvdmVyIDYKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTYtNDg3CiAgICAvLyBwdWJsaWMgdG90YWxTdGFrZWQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICAvLyBwdWJsaWMgYXByQmFzaXNQb2ludHMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICAvLyBwdWJsaWMgbGFzdERpc3RyaWJ1dGlvblRpbWUgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICAvLyBwdWJsaWMgZGlzdHJpYnV0aW9uUGVyaW9kUm91bmRzID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgLy8gcHVibGljIG1pbmltdW1TdGFrZSA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIC8vIHB1YmxpYyByZXdhcmRQb29sID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgLy8gCiAgICAvLyBwdWJsaWMgc3Rha2VycyA9IEJveE1hcDxBY2NvdW50LCBVc2VyU3Rha2VJbmZvPih7IGtleVByZWZpeDogJ3N0YWtlcnMnIH0pCiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogSGVscGVyIGZ1bmN0aW9uIHRvIHJlYWQgdXNlciBzdGFrZSBpbmZvIGZyb20gYm94IHN0b3JhZ2UKICAgIC8vICAqLwogICAgLy8gcHVibGljIGdldFVzZXJTdGFrZUluZm8odXNlckFkZHJlc3M6IEFjY291bnQpOiBVc2VyU3Rha2VJbmZvIHsKICAgIC8vICAgY29uc3QgdXNlckJveCA9IHRoaXMuc3Rha2Vycyh1c2VyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICBpZiAodXNlckJveC5leGlzdHMpIHsKICAgIC8vICAgICByZXR1cm4gdXNlckJveC52YWx1ZS5jb3B5KCkKICAgIC8vICAgfSBlbHNlIHsKICAgIC8vICAgICByZXR1cm4gbmV3IFVzZXJTdGFrZUluZm8oewogICAgLy8gICAgICAgc3Rha2VkQW1vdW50OiBuZXcgYXJjNC5VaW50TjY0KDApLAogICAgLy8gICAgICAgZmlyc3RTdGFrZVRpbWU6IG5ldyBhcmM0LlVpbnRONjQoMCksCiAgICAvLyAgICAgICBsYXN0U3Rha2VUaW1lOiBuZXcgYXJjNC5VaW50TjY0KDApLAogICAgLy8gICAgICAgdG90YWxSZXdhcmRzRWFybmVkOiBuZXcgYXJjNC5VaW50TjY0KDApLAogICAgLy8gICAgICAgbGFzdENsYWltZWRQZXJpb2Q6IG5ldyBhcmM0LlVpbnRONjQoMCksCiAgICAvLyAgICAgfSkKICAgIC8vICAgfQogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIEhlbHBlciBmdW5jdGlvbiB0byBzdG9yZSB1c2VyIHN0YWtlIGluZm8gaW4gYm94IHN0b3JhZ2UKICAgIC8vICAqLwogICAgLy8gcHVibGljIHN0b3JlVXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzczogQWNjb3VudCwgc3Rha2VJbmZvOiBVc2VyU3Rha2VJbmZvKTogdm9pZCB7CiAgICAvLyAgIHRoaXMuc3Rha2Vycyh1c2VyQWRkcmVzcykudmFsdWUgPSBzdGFrZUluZm8uY29weSgpCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogQ2FsY3VsYXRlIHRoZSBjdXJyZW50IGRpc3RyaWJ1dGlvbiBwZXJpb2QKICAgIC8vICAqLwogICAgLy8gcHVibGljIGdldEN1cnJlbnRQZXJpb2QoKTogdWludDY0IHsKICAgIC8vICAgY29uc3QgcGVyaW9kU2Vjb25kcyA9IHRoaXMuZGlzdHJpYnV0aW9uUGVyaW9kUm91bmRzLnZhbHVlCiAgICAvLyAgIGlmIChwZXJpb2RTZWNvbmRzID09PSAwKSByZXR1cm4gMAogICAgLy8gICByZXR1cm4gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCAvIHBlcmlvZFNlY29uZHMKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBJbml0aWFsaXplIHRoZSBjb250cmFjdCB3aXRoIHRoZSBBU0EgdG9rZW4gSUQgYW5kIG90aGVyIHBhcmFtZXRlcnMKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgaW5pdGlhbGl6ZSgKICAgIC8vICAgYXNzZXQ6IEFzc2V0LAogICAgLy8gICBhZG1pbkFkZHJlc3M6IEFjY291bnQsCiAgICAvLyAgIGFwckJhc2lzUG9pbnRzOiB1aW50NjQsCiAgICAvLyAgIGRpc3RyaWJ1dGlvblBlcmlvZFNlY29uZHM6IHVpbnQ2NCwKICAgIC8vICAgbWluaW11bVN0YWtlOiB1aW50NjQsCiAgICAvLyApOiB2b2lkIHsKICAgIC8vICAgLy8gRW5zdXJlIHRoaXMgaXMgb25seSBjYWxsZWQgZHVyaW5nIGNvbnRyYWN0IGNyZWF0aW9uCiAgICAvLyAgIGFzc2VydCh0aGlzLmFzc2V0LnZhbHVlID09PSBBc3NldCgpLCAnQWxyZWFkeSBpbml0aWFsaXplZCcpCiAgICAvLyAKICAgIC8vICAgLy8gRW5zdXJlIG9ubHkgdGhlIGNyZWF0b3IgY2FuIGluaXRpYWxpemUKICAgIC8vICAgYXNzZXJ0KFR4bi5zZW5kZXIgPT09IEdsb2JhbC5jcmVhdG9yQWRkcmVzcywgJ09ubHkgY3JlYXRvciBjYW4gaW5pdGlhbGl6ZScpCiAgICAvLyAKICAgIC8vICAgLy8gU3RvcmUgdGhlIGluaXRpYWwgcGFyYW1ldGVycwogICAgLy8gICB0aGlzLmFzc2V0LnZhbHVlID0gYXNzZXQKICAgIC8vICAgdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUgPSBhZG1pbkFkZHJlc3MKICAgIC8vICAgdGhpcy50b3RhbFN0YWtlZC52YWx1ZSA9IDAKICAgIC8vICAgdGhpcy5hcHJCYXNpc1BvaW50cy52YWx1ZSA9IGFwckJhc2lzUG9pbnRzCiAgICAvLyAgIHRoaXMubGFzdERpc3RyaWJ1dGlvblRpbWUudmFsdWUgPSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wCiAgICAvLyAgIHRoaXMuZGlzdHJpYnV0aW9uUGVyaW9kUm91bmRzLnZhbHVlID0gZGlzdHJpYnV0aW9uUGVyaW9kU2Vjb25kcwogICAgLy8gICB0aGlzLm1pbmltdW1TdGFrZS52YWx1ZSA9IG1pbmltdW1TdGFrZQogICAgLy8gICB0aGlzLnJld2FyZFBvb2wudmFsdWUgPSAwCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogT3B0IHRoZSBjb250cmFjdCBpbnRvIHRoZSBBU0EKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgb3B0SW5Ub0Fzc2V0KCk6IHZvaWQgewogICAgLy8gICAvLyBFbnN1cmUgb25seSB0aGUgY3JlYXRvciBvciBhZG1pbiBjYW4gb3B0IGluCiAgICAvLyAgIGNvbnN0IGFkbWluQWRkciA9IHRoaXMuYWRtaW5BZGRyZXNzLnZhbHVlCiAgICAvLyAgIGFzc2VydChUeG4uc2VuZGVyID09PSBHbG9iYWwuY3JlYXRvckFkZHJlc3MgfHwgVHhuLnNlbmRlciA9PT0gYWRtaW5BZGRyLCAnT25seSBjcmVhdG9yIG9yIGFkbWluIGNhbiBvcHQgaW4nKQogICAgLy8gCiAgICAvLyAgIC8vIE9wdCB0aGUgY29udHJhY3QgaW50byB0aGUgQVNBCiAgICAvLyAgIGNvbnN0IGFzc2V0ID0gdGhpcy5hc3NldC52YWx1ZQogICAgLy8gICBpdHhuCiAgICAvLyAgICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgICBhc3NldEFtb3VudDogMCwKICAgIC8vICAgICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgICAgfSkKICAgIC8vICAgICAuc3VibWl0KCkKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBTdGFrZSB0b2tlbnMKICAgIC8vICAqIFJlcXVpcmVzIGEgY29tcGFuaW9uIEFTQSB0cmFuc2ZlciB0cmFuc2FjdGlvbgogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyBzdGFrZSgpOiB2b2lkIHsKICAgIC8vICAgLy8gRW5zdXJlIHRoZSBjb250cmFjdCBoYXMgb3B0ZWQgaW50byB0aGUgQVNBCiAgICAvLyAgIGNvbnN0IGFzc2V0ID0gdGhpcy5hc3NldC52YWx1ZQogICAgLy8gICBhc3NlcnQodGhpcy5hc3NldC52YWx1ZSAhPT0gQXNzZXQoKSwgJ0NvbnRyYWN0IG5vdCBpbml0aWFsaXplZCcpCiAgICAvLyAKICAgIC8vICAgLy8gRW5zdXJlIHRoaXMgY2FsbCBoYXMgYSBjb21wYW5pb24gQVNBIHRyYW5zZmVyIHRyYW5zYWN0aW9uCiAgICAvLyAgIGFzc2VydChHbG9iYWwuZ3JvdXBTaXplID09PSAyLCAnRXhwZWN0ZWQgMiB0eG5zIGluIGdyb3VwJykKICAgIC8vIAogICAgLy8gICAvLyBHZXQgdGhlIEFTQSB0cmFuc2ZlciBkZXRhaWxzCiAgICAvLyAgIGNvbnN0IHhmZXJUeG4gPSBndHhuLkFzc2V0VHJhbnNmZXJUeG4oMCkKICAgIC8vICAgYXNzZXJ0KHhmZXJUeG4udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFzc2V0VHJhbnNmZXIsICdUcmFuc2FjdGlvbiAwIG11c3QgYmUgYXNzZXQgdHJhbnNmZXInKQogICAgLy8gICBhc3NlcnQoeGZlclR4bi5hc3NldFJlY2VpdmVyID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywgJ0Fzc2V0IHRyYW5zZmVyIG11c3QgYmUgdG8gY29udHJhY3QnKQogICAgLy8gICBhc3NlcnQoeGZlclR4bi5hc3NldEFtb3VudCA+IDAsICdNdXN0IHN0YWtlIG5vbi16ZXJvIGFtb3VudCcpCiAgICAvLyAgIGFzc2VydCh4ZmVyVHhuLnhmZXJBc3NldCA9PT0gYXNzZXQsICdJbmNvcnJlY3QgYXNzZXQgSUQnKQogICAgLy8gCiAgICAvLyAgIC8vIEdldCB0aGUgc3Rha2UgYW1vdW50IGZyb20gdGhlIHRyYW5zYWN0aW9uCiAgICAvLyAgIGNvbnN0IHN0YWtlQW1vdW50ID0geGZlclR4bi5hc3NldEFtb3VudAogICAgLy8gICBjb25zdCBtaW5pbXVtU3Rha2UgPSB0aGlzLm1pbmltdW1TdGFrZS52YWx1ZQogICAgLy8gCiAgICAvLyAgIC8vIEdldCB0aGUgY3VycmVudCB1c2VyIHN0YWtlIGluZm8KICAgIC8vICAgY29uc3Qgc2VuZGVyQWRkcmVzcyA9IFR4bi5zZW5kZXIKICAgIC8vICAgY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHNlbmRlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgLy8gSWYgdGhpcyBpcyBhIG5ldyBzdGFrZSwgZW5zdXJlIGl0IG1lZXRzIG1pbmltdW0KICAgIC8vICAgaWYgKHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlID09PSAwKSB7CiAgICAvLyAgICAgYXNzZXJ0KHN0YWtlQW1vdW50ID49IG1pbmltdW1TdGFrZSwgJ0luaXRpYWwgc3Rha2UgYmVsb3cgbWluaW11bScpCiAgICAvLyAgICAgLy8gU2V0IHRoZSBpbml0aWFsIGNsYWltIHBlcmlvZCB0byBjdXJyZW50IHBlcmlvZAogICAgLy8gICAgIHN0YWtlSW5mby5sYXN0Q2xhaW1lZFBlcmlvZCA9IG5ldyBhcmM0LlVpbnRONjQodGhpcy5nZXRDdXJyZW50UGVyaW9kKCkpCiAgICAvLyAgICAgLy8gU2V0IHRoZSBmaXJzdCBzdGFrZSB0aW1lICh0aGlzIG5ldmVyIGNoYW5nZXMgYWZ0ZXIgaW5pdGlhbCBzdGFrZSkKICAgIC8vICAgICBzdGFrZUluZm8uZmlyc3RTdGFrZVRpbWUgPSBuZXcgYXJjNC5VaW50TjY0KEdsb2JhbC5sYXRlc3RUaW1lc3RhbXApCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgc3Rha2UgaW5mbwogICAgLy8gICBzdGFrZUluZm8uc3Rha2VkQW1vdW50ID0gbmV3IGFyYzQuVWludE42NChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSArIHN0YWtlQW1vdW50KQogICAgLy8gICBzdGFrZUluZm8ubGFzdFN0YWtlVGltZSA9IG5ldyBhcmM0LlVpbnRONjQoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCkKICAgIC8vIAogICAgLy8gICAvLyBTdG9yZSB1cGRhdGVkIHN0YWtlIGluZm8KICAgIC8vICAgdGhpcy5zdG9yZVVzZXJTdGFrZUluZm8oc2VuZGVyQWRkcmVzcywgc3Rha2VJbmZvKQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBnbG9iYWwgc3RhdGUKICAgIC8vICAgdGhpcy50b3RhbFN0YWtlZC52YWx1ZSA9IHRoaXMudG90YWxTdGFrZWQudmFsdWUgKyBzdGFrZUFtb3VudAogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIFdpdGhkcmF3IHN0YWtlZCB0b2tlbnMKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgd2l0aGRyYXcoYW1vdW50OiB1aW50NjQpOiB2b2lkIHsKICAgIC8vICAgY29uc3Qgc2VuZGVyQWRkcmVzcyA9IFR4bi5zZW5kZXIKICAgIC8vICAgY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHNlbmRlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgLy8gRW5zdXJlIHVzZXIgaGFzIGVub3VnaCBzdGFrZWQKICAgIC8vICAgYXNzZXJ0KHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlID4gMCwgJ05vIHN0YWtlIGZvdW5kJykKICAgIC8vICAgYXNzZXJ0KGFtb3VudCA8PSBzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSwgJ1dpdGhkcmF3YWwgYW1vdW50IGV4Y2VlZHMgc3Rha2UnKQogICAgLy8gICBhc3NlcnQoYW1vdW50ID4gMCwgJ1dpdGhkcmF3YWwgYW1vdW50IG11c3QgYmUgcG9zaXRpdmUnKQogICAgLy8gCiAgICAvLyAgIC8vIElmIHdpdGhkcmF3aW5nIGFsbCwgbm8gbmVlZCB0byBjaGVjayBtaW5pbXVtIHJlbWFpbmluZwogICAgLy8gICAvLyBJZiBwYXJ0aWFsIHdpdGhkcmF3YWwsIGVuc3VyZSByZW1haW5pbmcgc3Rha2UgbWVldHMgbWluaW11bQogICAgLy8gICBpZiAoYW1vdW50IDwgc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUpIHsKICAgIC8vICAgICBjb25zdCByZW1haW5pbmdTdGFrZTogdWludDY0ID0gc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgLSBhbW91bnQKICAgIC8vICAgICBjb25zdCBtaW5pbXVtU3Rha2UgPSB0aGlzLm1pbmltdW1TdGFrZS52YWx1ZQogICAgLy8gICAgIGFzc2VydChyZW1haW5pbmdTdGFrZSA+PSBtaW5pbXVtU3Rha2UsICdSZW1haW5pbmcgc3Rha2Ugd291bGQgYmUgYmVsb3cgbWluaW11bScpCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgc3Rha2UgaW5mbwogICAgLy8gICBzdGFrZUluZm8uc3Rha2VkQW1vdW50ID0gbmV3IGFyYzQuVWludE42NChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSAtIGFtb3VudCkKICAgIC8vIAogICAgLy8gICAvLyBTdG9yZSB1cGRhdGVkIHN0YWtlIGluZm8KICAgIC8vICAgdGhpcy5zdG9yZVVzZXJTdGFrZUluZm8oc2VuZGVyQWRkcmVzcywgc3Rha2VJbmZvKQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBnbG9iYWwgc3RhdGUKICAgIC8vICAgdGhpcy50b3RhbFN0YWtlZC52YWx1ZSA9IHRoaXMudG90YWxTdGFrZWQudmFsdWUgLSBhbW91bnQKICAgIC8vIAogICAgLy8gICAvLyBUcmFuc2ZlciB0b2tlbnMgYmFjayB0byB1c2VyCiAgICAvLyAgIGNvbnN0IGFzc2V0ID0gdGhpcy5hc3NldC52YWx1ZQogICAgLy8gICBpdHhuCiAgICAvLyAgICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgICAgYXNzZXRSZWNlaXZlcjogVHhuLnNlbmRlciwKICAgIC8vICAgICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICAgICAgZmVlOiAxMDAwLAogICAgLy8gICAgIH0pCiAgICAvLyAgICAgLnN1Ym1pdCgpCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogQWRkIHJld2FyZHMgdG8gdGhlIHJld2FyZCBwb29sCiAgICAvLyAgKiBPbmx5IHRoZSBhZG1pbiBjYW4gY2FsbCB0aGlzCiAgICAvLyAgKiBSZXF1aXJlcyBhIGNvbXBhbmlvbiBBU0EgdHJhbnNmZXIgdHJhbnNhY3Rpb24gd2l0aCB0aGUgcmV3YXJkcwogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyBhZGRSZXdhcmRzKCk6IHZvaWQgewogICAgLy8gICAvLyBFbnN1cmUgb25seSBhZG1pbiBjYW4gYWRkIHJld2FyZHMKICAgIC8vICAgY29uc3QgYWRtaW5BZGRyID0gdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUKICAgIC8vICAgYXNzZXJ0KFR4bi5zZW5kZXIgPT09IGFkbWluQWRkciwgJ09ubHkgYWRtaW4gY2FuIGFkZCByZXdhcmRzJykKICAgIC8vIAogICAgLy8gICAvLyBFbnN1cmUgdGhpcyBjYWxsIGhhcyBhIGNvbXBhbmlvbiBBU0EgdHJhbnNmZXIgdHJhbnNhY3Rpb24gd2l0aCByZXdhcmRzCiAgICAvLyAgIGFzc2VydChHbG9iYWwuZ3JvdXBTaXplID09PSAyLCAnRXhwZWN0ZWQgMiB0eG5zIGluIGdyb3VwJykKICAgIC8vIAogICAgLy8gICAvLyBHZXQgdGhlIEFTQSB0cmFuc2ZlciBkZXRhaWxzCiAgICAvLyAgIGNvbnN0IGFzc2V0ID0gdGhpcy5hc3NldC52YWx1ZQogICAgLy8gICBjb25zdCB4ZmVyVHhuID0gZ3R4bi5Bc3NldFRyYW5zZmVyVHhuKDApCiAgICAvLyAgIGFzc2VydCh4ZmVyVHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5Bc3NldFRyYW5zZmVyLCAnVHJhbnNhY3Rpb24gMCBtdXN0IGJlIGFzc2V0IHRyYW5zZmVyJykKICAgIC8vICAgYXNzZXJ0KHhmZXJUeG4uYXNzZXRSZWNlaXZlciA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsICdBc3NldCB0cmFuc2ZlciBtdXN0IGJlIHRvIGNvbnRyYWN0JykKICAgIC8vICAgYXNzZXJ0KHhmZXJUeG4uYXNzZXRBbW91bnQgPiAwLCAnTXVzdCBwcm92aWRlIG5vbi16ZXJvIHJld2FyZHMnKQogICAgLy8gICBhc3NlcnQoeGZlclR4bi54ZmVyQXNzZXQgPT09IGFzc2V0LCAnSW5jb3JyZWN0IGFzc2V0IElEJykKICAgIC8vIAogICAgLy8gICAvLyBBZGQgcmV3YXJkcyB0byB0aGUgcG9vbAogICAgLy8gICB0aGlzLnJld2FyZFBvb2wudmFsdWUgPSB0aGlzLnJld2FyZFBvb2wudmFsdWUgKyB4ZmVyVHhuLmFzc2V0QW1vdW50CiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogQ2FsY3VsYXRlIHJld2FyZHMgZm9yIGEgc3BlY2lmaWMgdXNlciBmb3IgYSBnaXZlbiBwZXJpb2QKICAgIC8vICAqIFRoaXMgY2FsY3VsYXRlcyByZXdhcmRzIHBlciBkaXN0cmlidXRpb24gcGVyaW9kCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgLy8gcHVibGljIGNhbGN1bGF0ZVVzZXJSZXdhcmRzRm9yUGVyaW9kKHVzZXJBZGRyZXNzOiBBY2NvdW50KTogdWludDY0IHsKICAgIC8vICAgY29uc3QgYXByID0gdGhpcy5hcHJCYXNpc1BvaW50cy52YWx1ZQogICAgLy8gICBjb25zdCB0b3RhbFN0YWtlZCA9IHRoaXMudG90YWxTdGFrZWQudmFsdWUKICAgIC8vICAgY29uc3QgcGVyaW9kU2Vjb25kcyA9IHRoaXMuZGlzdHJpYnV0aW9uUGVyaW9kUm91bmRzLnZhbHVlCiAgICAvLyAKICAgIC8vICAgLy8gSWYgbm8gdG90YWwgc3Rha2Ugb3Igbm8gcGVyaW9kIGRlZmluZWQsIHJldHVybiAwCiAgICAvLyAgIGlmICh0b3RhbFN0YWtlZCA9PT0gMCB8fCBwZXJpb2RTZWNvbmRzID09PSAwKSB7CiAgICAvLyAgICAgcmV0dXJuIDAKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIEdldCB0aGUgdXNlcidzIHN0YWtlIGluZm8KICAgIC8vICAgY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIC8vIElmIHVzZXIgaGFzIG5vIHN0YWtlLCByZXR1cm4gMAogICAgLy8gICBpZiAoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgPT09IDApIHsKICAgIC8vICAgICByZXR1cm4gMAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gR2V0IHVzZXIncyBzdGFrZSBhbW91bnQgYW5kIGZpcnN0IHN0YWtlIHRpbWUKICAgIC8vICAgY29uc3QgdXNlclN0YWtlID0gc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUKICAgIC8vICAgY29uc3QgZmlyc3RTdGFrZVRpbWUgPSBzdGFrZUluZm8uZmlyc3RTdGFrZVRpbWUubmF0aXZlCiAgICAvLyAKICAgIC8vICAgLy8gQ2hlY2sgaWYgdXNlciBoYXMgYmVlbiBzdGFrZWQgZm9yIHRoZSBtaW5pbXVtIHBlcmlvZCAodXNpbmcgZmlyc3Qgc3Rha2UgdGltZSkKICAgIC8vICAgY29uc3QgbWluaW11bVN0YWtlVGltZTogdWludDY0ID0gUk9VTkRTX1BFUl9EQVkKICAgIC8vICAgaWYgKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPCBmaXJzdFN0YWtlVGltZSArIG1pbmltdW1TdGFrZVRpbWUpIHsKICAgIC8vICAgICByZXR1cm4gMAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gQ2FsY3VsYXRlIHJld2FyZCByYXRlIGZvciB0aGUgcGVyaW9kCiAgICAvLyAgIC8vIEFQUiBpcyBpbiBiYXNpcyBwb2ludHMgKGUuZy4sIDUwMCA9IDUlKQogICAgLy8gICAvLyBDb252ZXJ0IEFQUiB0byBwZXJpb2QgcmF0ZTogKEFQUiAvIDEwMDAwKSAqIChwZXJpb2RTZWNvbmRzIC8gMzE1MzYwMDApCiAgICAvLyAgIC8vIHdoZXJlIDMxNTM2MDAwIGlzIHNlY29uZHMgaW4gYSB5ZWFyCiAgICAvLyAgIGNvbnN0IHllYXJJblNlY29uZHM6IHVpbnQ2NCA9IFJPVU5EU19QRVJfWUVBUgogICAgLy8gICBjb25zdCBwZXJpb2RSYXRlTnVtZXJhdG9yOiB1aW50NjQgPSBhcHIgKiBwZXJpb2RTZWNvbmRzCiAgICAvLyAgIGNvbnN0IHBlcmlvZFJhdGVEZW5vbWluYXRvcjogdWludDY0ID0gMTAwMDAgKiB5ZWFySW5TZWNvbmRzCiAgICAvLyAKICAgIC8vICAgLy8gQ2FsY3VsYXRlIHJld2FyZDogdXNlclN0YWtlICogcGVyaW9kUmF0ZQogICAgLy8gICBjb25zdCByZXdhcmQ6IHVpbnQ2NCA9ICh1c2VyU3Rha2UgKiBwZXJpb2RSYXRlTnVtZXJhdG9yKSAvIHBlcmlvZFJhdGVEZW5vbWluYXRvcgogICAgLy8gCiAgICAvLyAgIHJldHVybiByZXdhcmQKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBDYWxjdWxhdGUgcGVuZGluZyByZXdhcmRzIGZvciBhIHVzZXIgc2luY2UgdGhlaXIgbGFzdCBjbGFpbQogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIHB1YmxpYyBjYWxjdWxhdGVQZW5kaW5nUmV3YXJkcyh1c2VyQWRkcmVzczogQWNjb3VudCk6IHVpbnQ2NCB7CiAgICAvLyAgIGNvbnN0IHN0YWtlSW5mbyA9IHRoaXMuZ2V0VXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICBpZiAoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgPT09IDApIHsKICAgIC8vICAgICByZXR1cm4gMAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgY29uc3QgY3VycmVudFBlcmlvZCA9IHRoaXMuZ2V0Q3VycmVudFBlcmlvZCgpCiAgICAvLyAgIGNvbnN0IGxhc3RDbGFpbWVkUGVyaW9kID0gc3Rha2VJbmZvLmxhc3RDbGFpbWVkUGVyaW9kLm5hdGl2ZQogICAgLy8gCiAgICAvLyAgIC8vIENhbGN1bGF0ZSBwZXJpb2RzIHNpbmNlIGxhc3QgY2xhaW0KICAgIC8vICAgY29uc3QgcGVyaW9kc1NpbmNlTGFzdENsYWltOiB1aW50NjQgPSBjdXJyZW50UGVyaW9kID4gbGFzdENsYWltZWRQZXJpb2QgPyBjdXJyZW50UGVyaW9kIC0gbGFzdENsYWltZWRQZXJpb2QgOiAwCiAgICAvLyAKICAgIC8vICAgaWYgKHBlcmlvZHNTaW5jZUxhc3RDbGFpbSA9PT0gMCkgewogICAgLy8gICAgIHJldHVybiAwCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBDYWxjdWxhdGUgcmV3YXJkIHBlciBwZXJpb2QKICAgIC8vICAgY29uc3QgcmV3YXJkUGVyUGVyaW9kID0gdGhpcy5jYWxjdWxhdGVVc2VyUmV3YXJkc0ZvclBlcmlvZCh1c2VyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICByZXR1cm4gcmV3YXJkUGVyUGVyaW9kICogcGVyaW9kc1NpbmNlTGFzdENsYWltCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbXBvdW5kIHJld2FyZHMgZm9yIGEgc2luZ2xlIHVzZXIKICAgIC8vICAqIFVzZWQgYnkgdGhlIGF1dG9tYXRlZCBkaXN0cmlidXRpb24gc3lzdGVtCiAgICAvLyAgKi8KICAgIC8vIHByaXZhdGUgY29tcG91bmRSZXdhcmRzRm9yVXNlcih1c2VyQWRkcmVzczogQWNjb3VudCk6IHVpbnQ2NCB7CiAgICAvLyAgIGNvbnN0IHN0YWtlSW5mbyA9IHRoaXMuZ2V0VXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICAvLyBTa2lwIGlmIHVzZXIgaGFzIG5vIHN0YWtlCiAgICAvLyAgIGlmIChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSA9PT0gMCkgewogICAgLy8gICAgIHJldHVybiAwCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBDYWxjdWxhdGUgcGVuZGluZyByZXdhcmRzCiAgICAvLyAgIGNvbnN0IHBlbmRpbmdSZXdhcmRzID0gdGhpcy5jYWxjdWxhdGVQZW5kaW5nUmV3YXJkcyh1c2VyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICAvLyBTa2lwIGlmIG5vIHJld2FyZHMgdG8gY29tcG91bmQKICAgIC8vICAgaWYgKHBlbmRpbmdSZXdhcmRzID09PSAwKSB7CiAgICAvLyAgICAgcmV0dXJuIDAKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIFNraXAgaWYgcmV3YXJkIHBvb2wgaGFzIGluc3VmZmljaWVudCBmdW5kcyBmb3IgdGhpcyB1c2VyCiAgICAvLyAgIGlmICh0aGlzLnJld2FyZFBvb2wudmFsdWUgPCBwZW5kaW5nUmV3YXJkcykgewogICAgLy8gICAgIHJldHVybiAwCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBBdXRvLWNvbXBvdW5kOiBBZGQgcmV3YXJkcyB0byBzdGFrZWQgYW1vdW50CiAgICAvLyAgIHN0YWtlSW5mby5zdGFrZWRBbW91bnQgPSBuZXcgYXJjNC5VaW50TjY0KHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlICsgcGVuZGluZ1Jld2FyZHMpCiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIHRvdGFsIHJld2FyZHMgZWFybmVkCiAgICAvLyAgIHN0YWtlSW5mby50b3RhbFJld2FyZHNFYXJuZWQgPSBuZXcgYXJjNC5VaW50TjY0KHN0YWtlSW5mby50b3RhbFJld2FyZHNFYXJuZWQubmF0aXZlICsgcGVuZGluZ1Jld2FyZHMpCiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIGxhc3QgY2xhaW1lZCBwZXJpb2QgdG8gY3VycmVudCBwZXJpb2QKICAgIC8vICAgc3Rha2VJbmZvLmxhc3RDbGFpbWVkUGVyaW9kID0gbmV3IGFyYzQuVWludE42NCh0aGlzLmdldEN1cnJlbnRQZXJpb2QoKSkKICAgIC8vIAogICAgLy8gICAvLyBTdG9yZSB1cGRhdGVkIHN0YWtlIGluZm8KICAgIC8vICAgdGhpcy5zdG9yZVVzZXJTdGFrZUluZm8odXNlckFkZHJlc3MsIHN0YWtlSW5mbykKICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgZ2xvYmFsIHN0YXRlCiAgICAvLyAgIHRoaXMudG90YWxTdGFrZWQudmFsdWUgPSB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlICsgcGVuZGluZ1Jld2FyZHMKICAgIC8vICAgdGhpcy5yZXdhcmRQb29sLnZhbHVlID0gdGhpcy5yZXdhcmRQb29sLnZhbHVlIC0gcGVuZGluZ1Jld2FyZHMKICAgIC8vIAogICAgLy8gICByZXR1cm4gcGVuZGluZ1Jld2FyZHMKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBEaXN0cmlidXRlIGFuZCBjb21wb3VuZCByZXdhcmRzIGZvciBtdWx0aXBsZSBzdGFrZXJzCiAgICAvLyAgKiBUaGlzIG1ldGhvZCBpcyBkZXNpZ25lZCB0byBiZSBjYWxsZWQgYnkgYSBjcm9uIGpvYiBvbiBhIGRhaWx5IGJhc2lzCiAgICAvLyAgKiBPbmx5IGFkbWluIGNhbiBjYWxsIHRoaXMgbWV0aG9kCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIGRpc3RyaWJ1dGVSZXdhcmRzKHN0YWtlckFkZHJlc3NlczogYXJjNC5BZGRyZXNzW10pOiB2b2lkIHsKICAgIC8vICAgLy8gRW5zdXJlIG9ubHkgYWRtaW4gY2FuIGRpc3RyaWJ1dGUgcmV3YXJkcwogICAgLy8gICBjb25zdCBhZG1pbkFkZHIgPSB0aGlzLmFkbWluQWRkcmVzcy52YWx1ZQogICAgLy8gICBhc3NlcnQoVHhuLnNlbmRlciA9PT0gYWRtaW5BZGRyLCAnT25seSBhZG1pbiBjYW4gZGlzdHJpYnV0ZSByZXdhcmRzJykKICAgIC8vIAogICAgLy8gICAvLyBFbnN1cmUgd2UgZG9uJ3QgcHJvY2VzcyB0b28gbWFueSBzdGFrZXJzIGluIG9uZSBjYWxsIChnYXMgbGltaXQgcHJvdGVjdGlvbikKICAgIC8vICAgYXNzZXJ0KHN0YWtlckFkZHJlc3Nlcy5sZW5ndGggPD0gNTAsICdUb28gbWFueSBzdGFrZXJzIGluIHNpbmdsZSBiYXRjaCcpCiAgICAvLyAKICAgIC8vICAgbGV0IHRvdGFsRGlzdHJpYnV0ZWQ6IHVpbnQ2NCA9IDAKICAgIC8vIAogICAgLy8gICAvLyBQcm9jZXNzIGVhY2ggc3Rha2VyCiAgICAvLyAgIGZvciAoY29uc3Qgc3Rha2VyIG9mIHN0YWtlckFkZHJlc3NlcykgewogICAgLy8gICAgIGNvbnN0IHJld2FyZHNDb21wb3VuZGVkID0gdGhpcy5jb21wb3VuZFJld2FyZHNGb3JVc2VyKHN0YWtlci5uYXRpdmUpCiAgICAvLyAgICAgdG90YWxEaXN0cmlidXRlZCA9IHRvdGFsRGlzdHJpYnV0ZWQgKyByZXdhcmRzQ29tcG91bmRlZAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIGxhc3QgZGlzdHJpYnV0aW9uIHRpbWUKICAgIC8vICAgdGhpcy5sYXN0RGlzdHJpYnV0aW9uVGltZS52YWx1ZSA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBHZXQgYWxsIG5vbi16ZXJvIHN0YWtlcnMgY291bnQgKGZvciBtb25pdG9yaW5nIHB1cnBvc2VzKQogICAgLy8gICogTm90ZTogVGhpcyBkb2Vzbid0IHJldHVybiB0aGUgYWN0dWFsIGFkZHJlc3NlcyBkdWUgdG8gYm94IGl0ZXJhdGlvbiBsaW1pdGF0aW9ucwogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIHB1YmxpYyBnZXRBY3RpdmVTdGFrZXJzQ291bnQoc3Rha2VyQWRkcmVzc2VzOiBhcmM0LkFkZHJlc3NbXSk6IHVpbnQ2NCB7CiAgICAvLyAgIGxldCBhY3RpdmVDb3VudDogdWludDY0ID0gMAogICAgLy8gCiAgICAvLyAgIGZvciAoY29uc3Qgc3Rha2VyIG9mIHN0YWtlckFkZHJlc3NlcykgewogICAgLy8gICAgIGNvbnN0IHN0YWtlSW5mbyA9IHRoaXMuZ2V0VXNlclN0YWtlSW5mbyhzdGFrZXIubmF0aXZlKQogICAgLy8gICAgIGlmIChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSA+IDApIHsKICAgIC8vICAgICAgIGFjdGl2ZUNvdW50ID0gYWN0aXZlQ291bnQgKyAxCiAgICAvLyAgICAgfQogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgcmV0dXJuIGFjdGl2ZUNvdW50CiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogVXBkYXRlIHRoZSBBUFIgYmFzaXMgcG9pbnRzCiAgICAvLyAgKiBPbmx5IHRoZSBhZG1pbiBjYW4gY2FsbCB0aGlzCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIHVwZGF0ZUFQUihuZXdBcHJCYXNpc1BvaW50czogdWludDY0KTogdm9pZCB7CiAgICAvLyAgIC8vIEVuc3VyZSBvbmx5IGFkbWluIGNhbiB1cGRhdGUgQVBSCiAgICAvLyAgIGNvbnN0IGFkbWluQWRkciA9IHRoaXMuYWRtaW5BZGRyZXNzLnZhbHVlCiAgICAvLyAgIGFzc2VydChUeG4uc2VuZGVyID09PSBhZG1pbkFkZHIsICdPbmx5IGFkbWluIGNhbiB1cGRhdGUgQVBSJykKICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgQVBSCiAgICAvLyAgIHRoaXMuYXByQmFzaXNQb2ludHMudmFsdWUgPSBuZXdBcHJCYXNpc1BvaW50cwogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIFVwZGF0ZSB0aGUgYWRtaW4gYWRkcmVzcwogICAgLy8gICogT25seSB0aGUgY3VycmVudCBhZG1pbiBjYW4gY2FsbCB0aGlzCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIHVwZGF0ZUFkbWluKG5ld0FkbWluQWRkcmVzczogQWNjb3VudCk6IHZvaWQgewogICAgLy8gICAvLyBFbnN1cmUgb25seSBhZG1pbiBjYW4gdXBkYXRlIGFkbWluCiAgICAvLyAgIGNvbnN0IGFkbWluQWRkciA9IHRoaXMuYWRtaW5BZGRyZXNzLnZhbHVlCiAgICAvLyAgIGFzc2VydChUeG4uc2VuZGVyID09PSBhZG1pbkFkZHIsICdPbmx5IGFkbWluIGNhbiB1cGRhdGUgYWRtaW4nKQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBhZG1pbiBhZGRyZXNzCiAgICAvLyAgIHRoaXMuYWRtaW5BZGRyZXNzLnZhbHVlID0gbmV3QWRtaW5BZGRyZXNzCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogR2V0IGN1cnJlbnQgc3Rha2luZyBzdGF0aXN0aWNzIGZvciBhIHVzZXIKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICAvLyBwdWJsaWMgZ2V0VXNlclN0YXRzKHVzZXJBZGRyZXNzOiBBY2NvdW50KTogQXJyYXk8dWludDY0PiB7CiAgICAvLyAgIGNvbnN0IHN0YWtlSW5mbyA9IHRoaXMuZ2V0VXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzcykKICAgIC8vICAgY29uc3QgcGVuZGluZ1Jld2FyZHMgPSB0aGlzLmNhbGN1bGF0ZVBlbmRpbmdSZXdhcmRzKHVzZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIGNvbnN0IHJlc3VsdDogdWludDY0W10gPSBbCiAgICAvLyAgICAgc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUsCiAgICAvLyAgICAgc3Rha2VJbmZvLmZpcnN0U3Rha2VUaW1lLm5hdGl2ZSwKICAgIC8vICAgICBzdGFrZUluZm8ubGFzdFN0YWtlVGltZS5uYXRpdmUsCiAgICAvLyAgICAgc3Rha2VJbmZvLnRvdGFsUmV3YXJkc0Vhcm5lZC5uYXRpdmUsCiAgICAvLyAgICAgcGVuZGluZ1Jld2FyZHMsCiAgICAvLyAgICAgc3Rha2VJbmZvLmxhc3RDbGFpbWVkUGVyaW9kLm5hdGl2ZSwKICAgIC8vICAgXQogICAgLy8gCiAgICAvLyAgIHJldHVybiByZXN1bHQKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBHZXQgY29udHJhY3QgZ2xvYmFsIHN0YXRpc3RpY3MKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICAvLyBwdWJsaWMgZ2V0Q29udHJhY3RTdGF0cygpOiBBcnJheTx1aW50NjQ+IHsKICAgIC8vICAgY29uc3QgcmVzdWx0OiB1aW50NjRbXSA9IFsKICAgIC8vICAgICB0aGlzLmFzc2V0LnZhbHVlLmlkLAogICAgLy8gICAgIHRoaXMudG90YWxTdGFrZWQudmFsdWUsCiAgICAvLyAgICAgdGhpcy5hcHJCYXNpc1BvaW50cy52YWx1ZSwKICAgIC8vICAgICB0aGlzLmxhc3REaXN0cmlidXRpb25UaW1lLnZhbHVlLAogICAgLy8gICAgIHRoaXMuZGlzdHJpYnV0aW9uUGVyaW9kUm91bmRzLnZhbHVlLAogICAgLy8gICAgIHRoaXMubWluaW11bVN0YWtlLnZhbHVlLAogICAgLy8gICAgIHRoaXMucmV3YXJkUG9vbC52YWx1ZSwKICAgIC8vICAgICB0aGlzLmdldEN1cnJlbnRQZXJpb2QoKSwKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1OAogICAgLy8gcHVibGljIGxhc3REaXN0cmlidXRpb25UaW1lID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgdW5jb3ZlciA1CiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU2LTQ4NwogICAgLy8gcHVibGljIHRvdGFsU3Rha2VkID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgLy8gcHVibGljIGFwckJhc2lzUG9pbnRzID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgLy8gcHVibGljIGxhc3REaXN0cmlidXRpb25UaW1lID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgLy8gcHVibGljIGRpc3RyaWJ1dGlvblBlcmlvZFJvdW5kcyA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIC8vIHB1YmxpYyBtaW5pbXVtU3Rha2UgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICAvLyBwdWJsaWMgcmV3YXJkUG9vbCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIC8vIAogICAgLy8gcHVibGljIHN0YWtlcnMgPSBCb3hNYXA8QWNjb3VudCwgVXNlclN0YWtlSW5mbz4oeyBrZXlQcmVmaXg6ICdzdGFrZXJzJyB9KQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIEhlbHBlciBmdW5jdGlvbiB0byByZWFkIHVzZXIgc3Rha2UgaW5mbyBmcm9tIGJveCBzdG9yYWdlCiAgICAvLyAgKi8KICAgIC8vIHB1YmxpYyBnZXRVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzOiBBY2NvdW50KTogVXNlclN0YWtlSW5mbyB7CiAgICAvLyAgIGNvbnN0IHVzZXJCb3ggPSB0aGlzLnN0YWtlcnModXNlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgaWYgKHVzZXJCb3guZXhpc3RzKSB7CiAgICAvLyAgICAgcmV0dXJuIHVzZXJCb3gudmFsdWUuY29weSgpCiAgICAvLyAgIH0gZWxzZSB7CiAgICAvLyAgICAgcmV0dXJuIG5ldyBVc2VyU3Rha2VJbmZvKHsKICAgIC8vICAgICAgIHN0YWtlZEFtb3VudDogbmV3IGFyYzQuVWludE42NCgwKSwKICAgIC8vICAgICAgIGZpcnN0U3Rha2VUaW1lOiBuZXcgYXJjNC5VaW50TjY0KDApLAogICAgLy8gICAgICAgbGFzdFN0YWtlVGltZTogbmV3IGFyYzQuVWludE42NCgwKSwKICAgIC8vICAgICAgIHRvdGFsUmV3YXJkc0Vhcm5lZDogbmV3IGFyYzQuVWludE42NCgwKSwKICAgIC8vICAgICAgIGxhc3RDbGFpbWVkUGVyaW9kOiBuZXcgYXJjNC5VaW50TjY0KDApLAogICAgLy8gICAgIH0pCiAgICAvLyAgIH0KICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gc3RvcmUgdXNlciBzdGFrZSBpbmZvIGluIGJveCBzdG9yYWdlCiAgICAvLyAgKi8KICAgIC8vIHB1YmxpYyBzdG9yZVVzZXJTdGFrZUluZm8odXNlckFkZHJlc3M6IEFjY291bnQsIHN0YWtlSW5mbzogVXNlclN0YWtlSW5mbyk6IHZvaWQgewogICAgLy8gICB0aGlzLnN0YWtlcnModXNlckFkZHJlc3MpLnZhbHVlID0gc3Rha2VJbmZvLmNvcHkoKQogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIENhbGN1bGF0ZSB0aGUgY3VycmVudCBkaXN0cmlidXRpb24gcGVyaW9kCiAgICAvLyAgKi8KICAgIC8vIHB1YmxpYyBnZXRDdXJyZW50UGVyaW9kKCk6IHVpbnQ2NCB7CiAgICAvLyAgIGNvbnN0IHBlcmlvZFNlY29uZHMgPSB0aGlzLmRpc3RyaWJ1dGlvblBlcmlvZFJvdW5kcy52YWx1ZQogICAgLy8gICBpZiAocGVyaW9kU2Vjb25kcyA9PT0gMCkgcmV0dXJuIDAKICAgIC8vICAgcmV0dXJuIEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgLyBwZXJpb2RTZWNvbmRzCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogSW5pdGlhbGl6ZSB0aGUgY29udHJhY3Qgd2l0aCB0aGUgQVNBIHRva2VuIElEIGFuZCBvdGhlciBwYXJhbWV0ZXJzCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIGluaXRpYWxpemUoCiAgICAvLyAgIGFzc2V0OiBBc3NldCwKICAgIC8vICAgYWRtaW5BZGRyZXNzOiBBY2NvdW50LAogICAgLy8gICBhcHJCYXNpc1BvaW50czogdWludDY0LAogICAgLy8gICBkaXN0cmlidXRpb25QZXJpb2RTZWNvbmRzOiB1aW50NjQsCiAgICAvLyAgIG1pbmltdW1TdGFrZTogdWludDY0LAogICAgLy8gKTogdm9pZCB7CiAgICAvLyAgIC8vIEVuc3VyZSB0aGlzIGlzIG9ubHkgY2FsbGVkIGR1cmluZyBjb250cmFjdCBjcmVhdGlvbgogICAgLy8gICBhc3NlcnQodGhpcy5hc3NldC52YWx1ZSA9PT0gQXNzZXQoKSwgJ0FscmVhZHkgaW5pdGlhbGl6ZWQnKQogICAgLy8gCiAgICAvLyAgIC8vIEVuc3VyZSBvbmx5IHRoZSBjcmVhdG9yIGNhbiBpbml0aWFsaXplCiAgICAvLyAgIGFzc2VydChUeG4uc2VuZGVyID09PSBHbG9iYWwuY3JlYXRvckFkZHJlc3MsICdPbmx5IGNyZWF0b3IgY2FuIGluaXRpYWxpemUnKQogICAgLy8gCiAgICAvLyAgIC8vIFN0b3JlIHRoZSBpbml0aWFsIHBhcmFtZXRlcnMKICAgIC8vICAgdGhpcy5hc3NldC52YWx1ZSA9IGFzc2V0CiAgICAvLyAgIHRoaXMuYWRtaW5BZGRyZXNzLnZhbHVlID0gYWRtaW5BZGRyZXNzCiAgICAvLyAgIHRoaXMudG90YWxTdGFrZWQudmFsdWUgPSAwCiAgICAvLyAgIHRoaXMuYXByQmFzaXNQb2ludHMudmFsdWUgPSBhcHJCYXNpc1BvaW50cwogICAgLy8gICB0aGlzLmxhc3REaXN0cmlidXRpb25UaW1lLnZhbHVlID0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcAogICAgLy8gICB0aGlzLmRpc3RyaWJ1dGlvblBlcmlvZFJvdW5kcy52YWx1ZSA9IGRpc3RyaWJ1dGlvblBlcmlvZFNlY29uZHMKICAgIC8vICAgdGhpcy5taW5pbXVtU3Rha2UudmFsdWUgPSBtaW5pbXVtU3Rha2UKICAgIC8vICAgdGhpcy5yZXdhcmRQb29sLnZhbHVlID0gMAogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIE9wdCB0aGUgY29udHJhY3QgaW50byB0aGUgQVNBCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIG9wdEluVG9Bc3NldCgpOiB2b2lkIHsKICAgIC8vICAgLy8gRW5zdXJlIG9ubHkgdGhlIGNyZWF0b3Igb3IgYWRtaW4gY2FuIG9wdCBpbgogICAgLy8gICBjb25zdCBhZG1pbkFkZHIgPSB0aGlzLmFkbWluQWRkcmVzcy52YWx1ZQogICAgLy8gICBhc3NlcnQoVHhuLnNlbmRlciA9PT0gR2xvYmFsLmNyZWF0b3JBZGRyZXNzIHx8IFR4bi5zZW5kZXIgPT09IGFkbWluQWRkciwgJ09ubHkgY3JlYXRvciBvciBhZG1pbiBjYW4gb3B0IGluJykKICAgIC8vIAogICAgLy8gICAvLyBPcHQgdGhlIGNvbnRyYWN0IGludG8gdGhlIEFTQQogICAgLy8gICBjb25zdCBhc3NldCA9IHRoaXMuYXNzZXQudmFsdWUKICAgIC8vICAgaXR4bgogICAgLy8gICAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICAgIH0pCiAgICAvLyAgICAgLnN1Ym1pdCgpCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogU3Rha2UgdG9rZW5zCiAgICAvLyAgKiBSZXF1aXJlcyBhIGNvbXBhbmlvbiBBU0EgdHJhbnNmZXIgdHJhbnNhY3Rpb24KICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgc3Rha2UoKTogdm9pZCB7CiAgICAvLyAgIC8vIEVuc3VyZSB0aGUgY29udHJhY3QgaGFzIG9wdGVkIGludG8gdGhlIEFTQQogICAgLy8gICBjb25zdCBhc3NldCA9IHRoaXMuYXNzZXQudmFsdWUKICAgIC8vICAgYXNzZXJ0KHRoaXMuYXNzZXQudmFsdWUgIT09IEFzc2V0KCksICdDb250cmFjdCBub3QgaW5pdGlhbGl6ZWQnKQogICAgLy8gCiAgICAvLyAgIC8vIEVuc3VyZSB0aGlzIGNhbGwgaGFzIGEgY29tcGFuaW9uIEFTQSB0cmFuc2ZlciB0cmFuc2FjdGlvbgogICAgLy8gICBhc3NlcnQoR2xvYmFsLmdyb3VwU2l6ZSA9PT0gMiwgJ0V4cGVjdGVkIDIgdHhucyBpbiBncm91cCcpCiAgICAvLyAKICAgIC8vICAgLy8gR2V0IHRoZSBBU0EgdHJhbnNmZXIgZGV0YWlscwogICAgLy8gICBjb25zdCB4ZmVyVHhuID0gZ3R4bi5Bc3NldFRyYW5zZmVyVHhuKDApCiAgICAvLyAgIGFzc2VydCh4ZmVyVHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5Bc3NldFRyYW5zZmVyLCAnVHJhbnNhY3Rpb24gMCBtdXN0IGJlIGFzc2V0IHRyYW5zZmVyJykKICAgIC8vICAgYXNzZXJ0KHhmZXJUeG4uYXNzZXRSZWNlaXZlciA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsICdBc3NldCB0cmFuc2ZlciBtdXN0IGJlIHRvIGNvbnRyYWN0JykKICAgIC8vICAgYXNzZXJ0KHhmZXJUeG4uYXNzZXRBbW91bnQgPiAwLCAnTXVzdCBzdGFrZSBub24temVybyBhbW91bnQnKQogICAgLy8gICBhc3NlcnQoeGZlclR4bi54ZmVyQXNzZXQgPT09IGFzc2V0LCAnSW5jb3JyZWN0IGFzc2V0IElEJykKICAgIC8vIAogICAgLy8gICAvLyBHZXQgdGhlIHN0YWtlIGFtb3VudCBmcm9tIHRoZSB0cmFuc2FjdGlvbgogICAgLy8gICBjb25zdCBzdGFrZUFtb3VudCA9IHhmZXJUeG4uYXNzZXRBbW91bnQKICAgIC8vICAgY29uc3QgbWluaW11bVN0YWtlID0gdGhpcy5taW5pbXVtU3Rha2UudmFsdWUKICAgIC8vIAogICAgLy8gICAvLyBHZXQgdGhlIGN1cnJlbnQgdXNlciBzdGFrZSBpbmZvCiAgICAvLyAgIGNvbnN0IHNlbmRlckFkZHJlc3MgPSBUeG4uc2VuZGVyCiAgICAvLyAgIGNvbnN0IHN0YWtlSW5mbyA9IHRoaXMuZ2V0VXNlclN0YWtlSW5mbyhzZW5kZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIC8vIElmIHRoaXMgaXMgYSBuZXcgc3Rha2UsIGVuc3VyZSBpdCBtZWV0cyBtaW5pbXVtCiAgICAvLyAgIGlmIChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSA9PT0gMCkgewogICAgLy8gICAgIGFzc2VydChzdGFrZUFtb3VudCA+PSBtaW5pbXVtU3Rha2UsICdJbml0aWFsIHN0YWtlIGJlbG93IG1pbmltdW0nKQogICAgLy8gICAgIC8vIFNldCB0aGUgaW5pdGlhbCBjbGFpbSBwZXJpb2QgdG8gY3VycmVudCBwZXJpb2QKICAgIC8vICAgICBzdGFrZUluZm8ubGFzdENsYWltZWRQZXJpb2QgPSBuZXcgYXJjNC5VaW50TjY0KHRoaXMuZ2V0Q3VycmVudFBlcmlvZCgpKQogICAgLy8gICAgIC8vIFNldCB0aGUgZmlyc3Qgc3Rha2UgdGltZSAodGhpcyBuZXZlciBjaGFuZ2VzIGFmdGVyIGluaXRpYWwgc3Rha2UpCiAgICAvLyAgICAgc3Rha2VJbmZvLmZpcnN0U3Rha2VUaW1lID0gbmV3IGFyYzQuVWludE42NChHbG9iYWwubGF0ZXN0VGltZXN0YW1wKQogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIHN0YWtlIGluZm8KICAgIC8vICAgc3Rha2VJbmZvLnN0YWtlZEFtb3VudCA9IG5ldyBhcmM0LlVpbnRONjQoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgKyBzdGFrZUFtb3VudCkKICAgIC8vICAgc3Rha2VJbmZvLmxhc3RTdGFrZVRpbWUgPSBuZXcgYXJjNC5VaW50TjY0KEdsb2JhbC5sYXRlc3RUaW1lc3RhbXApCiAgICAvLyAKICAgIC8vICAgLy8gU3RvcmUgdXBkYXRlZCBzdGFrZSBpbmZvCiAgICAvLyAgIHRoaXMuc3RvcmVVc2VyU3Rha2VJbmZvKHNlbmRlckFkZHJlc3MsIHN0YWtlSW5mbykKICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgZ2xvYmFsIHN0YXRlCiAgICAvLyAgIHRoaXMudG90YWxTdGFrZWQudmFsdWUgPSB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlICsgc3Rha2VBbW91bnQKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBXaXRoZHJhdyBzdGFrZWQgdG9rZW5zCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIHdpdGhkcmF3KGFtb3VudDogdWludDY0KTogdm9pZCB7CiAgICAvLyAgIGNvbnN0IHNlbmRlckFkZHJlc3MgPSBUeG4uc2VuZGVyCiAgICAvLyAgIGNvbnN0IHN0YWtlSW5mbyA9IHRoaXMuZ2V0VXNlclN0YWtlSW5mbyhzZW5kZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIC8vIEVuc3VyZSB1c2VyIGhhcyBlbm91Z2ggc3Rha2VkCiAgICAvLyAgIGFzc2VydChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSA+IDAsICdObyBzdGFrZSBmb3VuZCcpCiAgICAvLyAgIGFzc2VydChhbW91bnQgPD0gc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUsICdXaXRoZHJhd2FsIGFtb3VudCBleGNlZWRzIHN0YWtlJykKICAgIC8vICAgYXNzZXJ0KGFtb3VudCA+IDAsICdXaXRoZHJhd2FsIGFtb3VudCBtdXN0IGJlIHBvc2l0aXZlJykKICAgIC8vIAogICAgLy8gICAvLyBJZiB3aXRoZHJhd2luZyBhbGwsIG5vIG5lZWQgdG8gY2hlY2sgbWluaW11bSByZW1haW5pbmcKICAgIC8vICAgLy8gSWYgcGFydGlhbCB3aXRoZHJhd2FsLCBlbnN1cmUgcmVtYWluaW5nIHN0YWtlIG1lZXRzIG1pbmltdW0KICAgIC8vICAgaWYgKGFtb3VudCA8IHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlKSB7CiAgICAvLyAgICAgY29uc3QgcmVtYWluaW5nU3Rha2U6IHVpbnQ2NCA9IHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlIC0gYW1vdW50CiAgICAvLyAgICAgY29uc3QgbWluaW11bVN0YWtlID0gdGhpcy5taW5pbXVtU3Rha2UudmFsdWUKICAgIC8vICAgICBhc3NlcnQocmVtYWluaW5nU3Rha2UgPj0gbWluaW11bVN0YWtlLCAnUmVtYWluaW5nIHN0YWtlIHdvdWxkIGJlIGJlbG93IG1pbmltdW0nKQogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIHN0YWtlIGluZm8KICAgIC8vICAgc3Rha2VJbmZvLnN0YWtlZEFtb3VudCA9IG5ldyBhcmM0LlVpbnRONjQoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgLSBhbW91bnQpCiAgICAvLyAKICAgIC8vICAgLy8gU3RvcmUgdXBkYXRlZCBzdGFrZSBpbmZvCiAgICAvLyAgIHRoaXMuc3RvcmVVc2VyU3Rha2VJbmZvKHNlbmRlckFkZHJlc3MsIHN0YWtlSW5mbykKICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgZ2xvYmFsIHN0YXRlCiAgICAvLyAgIHRoaXMudG90YWxTdGFrZWQudmFsdWUgPSB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlIC0gYW1vdW50CiAgICAvLyAKICAgIC8vICAgLy8gVHJhbnNmZXIgdG9rZW5zIGJhY2sgdG8gdXNlcgogICAgLy8gICBjb25zdCBhc3NldCA9IHRoaXMuYXNzZXQudmFsdWUKICAgIC8vICAgaXR4bgogICAgLy8gICAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IFR4bi5zZW5kZXIsCiAgICAvLyAgICAgICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gICAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgICAgIGZlZTogMTAwMCwKICAgIC8vICAgICB9KQogICAgLy8gICAgIC5zdWJtaXQoKQogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIEFkZCByZXdhcmRzIHRvIHRoZSByZXdhcmQgcG9vbAogICAgLy8gICogT25seSB0aGUgYWRtaW4gY2FuIGNhbGwgdGhpcwogICAgLy8gICogUmVxdWlyZXMgYSBjb21wYW5pb24gQVNBIHRyYW5zZmVyIHRyYW5zYWN0aW9uIHdpdGggdGhlIHJld2FyZHMKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgYWRkUmV3YXJkcygpOiB2b2lkIHsKICAgIC8vICAgLy8gRW5zdXJlIG9ubHkgYWRtaW4gY2FuIGFkZCByZXdhcmRzCiAgICAvLyAgIGNvbnN0IGFkbWluQWRkciA9IHRoaXMuYWRtaW5BZGRyZXNzLnZhbHVlCiAgICAvLyAgIGFzc2VydChUeG4uc2VuZGVyID09PSBhZG1pbkFkZHIsICdPbmx5IGFkbWluIGNhbiBhZGQgcmV3YXJkcycpCiAgICAvLyAKICAgIC8vICAgLy8gRW5zdXJlIHRoaXMgY2FsbCBoYXMgYSBjb21wYW5pb24gQVNBIHRyYW5zZmVyIHRyYW5zYWN0aW9uIHdpdGggcmV3YXJkcwogICAgLy8gICBhc3NlcnQoR2xvYmFsLmdyb3VwU2l6ZSA9PT0gMiwgJ0V4cGVjdGVkIDIgdHhucyBpbiBncm91cCcpCiAgICAvLyAKICAgIC8vICAgLy8gR2V0IHRoZSBBU0EgdHJhbnNmZXIgZGV0YWlscwogICAgLy8gICBjb25zdCBhc3NldCA9IHRoaXMuYXNzZXQudmFsdWUKICAgIC8vICAgY29uc3QgeGZlclR4biA9IGd0eG4uQXNzZXRUcmFuc2ZlclR4bigwKQogICAgLy8gICBhc3NlcnQoeGZlclR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXNzZXRUcmFuc2ZlciwgJ1RyYW5zYWN0aW9uIDAgbXVzdCBiZSBhc3NldCB0cmFuc2ZlcicpCiAgICAvLyAgIGFzc2VydCh4ZmVyVHhuLmFzc2V0UmVjZWl2ZXIgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLCAnQXNzZXQgdHJhbnNmZXIgbXVzdCBiZSB0byBjb250cmFjdCcpCiAgICAvLyAgIGFzc2VydCh4ZmVyVHhuLmFzc2V0QW1vdW50ID4gMCwgJ011c3QgcHJvdmlkZSBub24temVybyByZXdhcmRzJykKICAgIC8vICAgYXNzZXJ0KHhmZXJUeG4ueGZlckFzc2V0ID09PSBhc3NldCwgJ0luY29ycmVjdCBhc3NldCBJRCcpCiAgICAvLyAKICAgIC8vICAgLy8gQWRkIHJld2FyZHMgdG8gdGhlIHBvb2wKICAgIC8vICAgdGhpcy5yZXdhcmRQb29sLnZhbHVlID0gdGhpcy5yZXdhcmRQb29sLnZhbHVlICsgeGZlclR4bi5hc3NldEFtb3VudAogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIENhbGN1bGF0ZSByZXdhcmRzIGZvciBhIHNwZWNpZmljIHVzZXIgZm9yIGEgZ2l2ZW4gcGVyaW9kCiAgICAvLyAgKiBUaGlzIGNhbGN1bGF0ZXMgcmV3YXJkcyBwZXIgZGlzdHJpYnV0aW9uIHBlcmlvZAogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIHB1YmxpYyBjYWxjdWxhdGVVc2VyUmV3YXJkc0ZvclBlcmlvZCh1c2VyQWRkcmVzczogQWNjb3VudCk6IHVpbnQ2NCB7CiAgICAvLyAgIGNvbnN0IGFwciA9IHRoaXMuYXByQmFzaXNQb2ludHMudmFsdWUKICAgIC8vICAgY29uc3QgdG90YWxTdGFrZWQgPSB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlCiAgICAvLyAgIGNvbnN0IHBlcmlvZFNlY29uZHMgPSB0aGlzLmRpc3RyaWJ1dGlvblBlcmlvZFJvdW5kcy52YWx1ZQogICAgLy8gCiAgICAvLyAgIC8vIElmIG5vIHRvdGFsIHN0YWtlIG9yIG5vIHBlcmlvZCBkZWZpbmVkLCByZXR1cm4gMAogICAgLy8gICBpZiAodG90YWxTdGFrZWQgPT09IDAgfHwgcGVyaW9kU2Vjb25kcyA9PT0gMCkgewogICAgLy8gICAgIHJldHVybiAwCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBHZXQgdGhlIHVzZXIncyBzdGFrZSBpbmZvCiAgICAvLyAgIGNvbnN0IHN0YWtlSW5mbyA9IHRoaXMuZ2V0VXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICAvLyBJZiB1c2VyIGhhcyBubyBzdGFrZSwgcmV0dXJuIDAKICAgIC8vICAgaWYgKHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlID09PSAwKSB7CiAgICAvLyAgICAgcmV0dXJuIDAKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIEdldCB1c2VyJ3Mgc3Rha2UgYW1vdW50IGFuZCBmaXJzdCBzdGFrZSB0aW1lCiAgICAvLyAgIGNvbnN0IHVzZXJTdGFrZSA9IHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlCiAgICAvLyAgIGNvbnN0IGZpcnN0U3Rha2VUaW1lID0gc3Rha2VJbmZvLmZpcnN0U3Rha2VUaW1lLm5hdGl2ZQogICAgLy8gCiAgICAvLyAgIC8vIENoZWNrIGlmIHVzZXIgaGFzIGJlZW4gc3Rha2VkIGZvciB0aGUgbWluaW11bSBwZXJpb2QgKHVzaW5nIGZpcnN0IHN0YWtlIHRpbWUpCiAgICAvLyAgIGNvbnN0IG1pbmltdW1TdGFrZVRpbWU6IHVpbnQ2NCA9IFJPVU5EU19QRVJfREFZCiAgICAvLyAgIGlmIChHbG9iYWwubGF0ZXN0VGltZXN0YW1wIDwgZmlyc3RTdGFrZVRpbWUgKyBtaW5pbXVtU3Rha2VUaW1lKSB7CiAgICAvLyAgICAgcmV0dXJuIDAKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIENhbGN1bGF0ZSByZXdhcmQgcmF0ZSBmb3IgdGhlIHBlcmlvZAogICAgLy8gICAvLyBBUFIgaXMgaW4gYmFzaXMgcG9pbnRzIChlLmcuLCA1MDAgPSA1JSkKICAgIC8vICAgLy8gQ29udmVydCBBUFIgdG8gcGVyaW9kIHJhdGU6IChBUFIgLyAxMDAwMCkgKiAocGVyaW9kU2Vjb25kcyAvIDMxNTM2MDAwKQogICAgLy8gICAvLyB3aGVyZSAzMTUzNjAwMCBpcyBzZWNvbmRzIGluIGEgeWVhcgogICAgLy8gICBjb25zdCB5ZWFySW5TZWNvbmRzOiB1aW50NjQgPSBST1VORFNfUEVSX1lFQVIKICAgIC8vICAgY29uc3QgcGVyaW9kUmF0ZU51bWVyYXRvcjogdWludDY0ID0gYXByICogcGVyaW9kU2Vjb25kcwogICAgLy8gICBjb25zdCBwZXJpb2RSYXRlRGVub21pbmF0b3I6IHVpbnQ2NCA9IDEwMDAwICogeWVhckluU2Vjb25kcwogICAgLy8gCiAgICAvLyAgIC8vIENhbGN1bGF0ZSByZXdhcmQ6IHVzZXJTdGFrZSAqIHBlcmlvZFJhdGUKICAgIC8vICAgY29uc3QgcmV3YXJkOiB1aW50NjQgPSAodXNlclN0YWtlICogcGVyaW9kUmF0ZU51bWVyYXRvcikgLyBwZXJpb2RSYXRlRGVub21pbmF0b3IKICAgIC8vIAogICAgLy8gICByZXR1cm4gcmV3YXJkCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogQ2FsY3VsYXRlIHBlbmRpbmcgcmV3YXJkcyBmb3IgYSB1c2VyIHNpbmNlIHRoZWlyIGxhc3QgY2xhaW0KICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICAvLyBwdWJsaWMgY2FsY3VsYXRlUGVuZGluZ1Jld2FyZHModXNlckFkZHJlc3M6IEFjY291bnQpOiB1aW50NjQgewogICAgLy8gICBjb25zdCBzdGFrZUluZm8gPSB0aGlzLmdldFVzZXJTdGFrZUluZm8odXNlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgaWYgKHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlID09PSAwKSB7CiAgICAvLyAgICAgcmV0dXJuIDAKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIGNvbnN0IGN1cnJlbnRQZXJpb2QgPSB0aGlzLmdldEN1cnJlbnRQZXJpb2QoKQogICAgLy8gICBjb25zdCBsYXN0Q2xhaW1lZFBlcmlvZCA9IHN0YWtlSW5mby5sYXN0Q2xhaW1lZFBlcmlvZC5uYXRpdmUKICAgIC8vIAogICAgLy8gICAvLyBDYWxjdWxhdGUgcGVyaW9kcyBzaW5jZSBsYXN0IGNsYWltCiAgICAvLyAgIGNvbnN0IHBlcmlvZHNTaW5jZUxhc3RDbGFpbTogdWludDY0ID0gY3VycmVudFBlcmlvZCA+IGxhc3RDbGFpbWVkUGVyaW9kID8gY3VycmVudFBlcmlvZCAtIGxhc3RDbGFpbWVkUGVyaW9kIDogMAogICAgLy8gCiAgICAvLyAgIGlmIChwZXJpb2RzU2luY2VMYXN0Q2xhaW0gPT09IDApIHsKICAgIC8vICAgICByZXR1cm4gMAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gQ2FsY3VsYXRlIHJld2FyZCBwZXIgcGVyaW9kCiAgICAvLyAgIGNvbnN0IHJld2FyZFBlclBlcmlvZCA9IHRoaXMuY2FsY3VsYXRlVXNlclJld2FyZHNGb3JQZXJpb2QodXNlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgcmV0dXJuIHJld2FyZFBlclBlcmlvZCAqIHBlcmlvZHNTaW5jZUxhc3RDbGFpbQogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIEhlbHBlciBmdW5jdGlvbiB0byBjb21wb3VuZCByZXdhcmRzIGZvciBhIHNpbmdsZSB1c2VyCiAgICAvLyAgKiBVc2VkIGJ5IHRoZSBhdXRvbWF0ZWQgZGlzdHJpYnV0aW9uIHN5c3RlbQogICAgLy8gICovCiAgICAvLyBwcml2YXRlIGNvbXBvdW5kUmV3YXJkc0ZvclVzZXIodXNlckFkZHJlc3M6IEFjY291bnQpOiB1aW50NjQgewogICAgLy8gICBjb25zdCBzdGFrZUluZm8gPSB0aGlzLmdldFVzZXJTdGFrZUluZm8odXNlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgLy8gU2tpcCBpZiB1c2VyIGhhcyBubyBzdGFrZQogICAgLy8gICBpZiAoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgPT09IDApIHsKICAgIC8vICAgICByZXR1cm4gMAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gQ2FsY3VsYXRlIHBlbmRpbmcgcmV3YXJkcwogICAgLy8gICBjb25zdCBwZW5kaW5nUmV3YXJkcyA9IHRoaXMuY2FsY3VsYXRlUGVuZGluZ1Jld2FyZHModXNlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgLy8gU2tpcCBpZiBubyByZXdhcmRzIHRvIGNvbXBvdW5kCiAgICAvLyAgIGlmIChwZW5kaW5nUmV3YXJkcyA9PT0gMCkgewogICAgLy8gICAgIHJldHVybiAwCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBTa2lwIGlmIHJld2FyZCBwb29sIGhhcyBpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIHRoaXMgdXNlcgogICAgLy8gICBpZiAodGhpcy5yZXdhcmRQb29sLnZhbHVlIDwgcGVuZGluZ1Jld2FyZHMpIHsKICAgIC8vICAgICByZXR1cm4gMAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gQXV0by1jb21wb3VuZDogQWRkIHJld2FyZHMgdG8gc3Rha2VkIGFtb3VudAogICAgLy8gICBzdGFrZUluZm8uc3Rha2VkQW1vdW50ID0gbmV3IGFyYzQuVWludE42NChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSArIHBlbmRpbmdSZXdhcmRzKQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSB0b3RhbCByZXdhcmRzIGVhcm5lZAogICAgLy8gICBzdGFrZUluZm8udG90YWxSZXdhcmRzRWFybmVkID0gbmV3IGFyYzQuVWludE42NChzdGFrZUluZm8udG90YWxSZXdhcmRzRWFybmVkLm5hdGl2ZSArIHBlbmRpbmdSZXdhcmRzKQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBsYXN0IGNsYWltZWQgcGVyaW9kIHRvIGN1cnJlbnQgcGVyaW9kCiAgICAvLyAgIHN0YWtlSW5mby5sYXN0Q2xhaW1lZFBlcmlvZCA9IG5ldyBhcmM0LlVpbnRONjQodGhpcy5nZXRDdXJyZW50UGVyaW9kKCkpCiAgICAvLyAKICAgIC8vICAgLy8gU3RvcmUgdXBkYXRlZCBzdGFrZSBpbmZvCiAgICAvLyAgIHRoaXMuc3RvcmVVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzLCBzdGFrZUluZm8pCiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIGdsb2JhbCBzdGF0ZQogICAgLy8gICB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlID0gdGhpcy50b3RhbFN0YWtlZC52YWx1ZSArIHBlbmRpbmdSZXdhcmRzCiAgICAvLyAgIHRoaXMucmV3YXJkUG9vbC52YWx1ZSA9IHRoaXMucmV3YXJkUG9vbC52YWx1ZSAtIHBlbmRpbmdSZXdhcmRzCiAgICAvLyAKICAgIC8vICAgcmV0dXJuIHBlbmRpbmdSZXdhcmRzCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogRGlzdHJpYnV0ZSBhbmQgY29tcG91bmQgcmV3YXJkcyBmb3IgbXVsdGlwbGUgc3Rha2VycwogICAgLy8gICogVGhpcyBtZXRob2QgaXMgZGVzaWduZWQgdG8gYmUgY2FsbGVkIGJ5IGEgY3JvbiBqb2Igb24gYSBkYWlseSBiYXNpcwogICAgLy8gICogT25seSBhZG1pbiBjYW4gY2FsbCB0aGlzIG1ldGhvZAogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyBkaXN0cmlidXRlUmV3YXJkcyhzdGFrZXJBZGRyZXNzZXM6IGFyYzQuQWRkcmVzc1tdKTogdm9pZCB7CiAgICAvLyAgIC8vIEVuc3VyZSBvbmx5IGFkbWluIGNhbiBkaXN0cmlidXRlIHJld2FyZHMKICAgIC8vICAgY29uc3QgYWRtaW5BZGRyID0gdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUKICAgIC8vICAgYXNzZXJ0KFR4bi5zZW5kZXIgPT09IGFkbWluQWRkciwgJ09ubHkgYWRtaW4gY2FuIGRpc3RyaWJ1dGUgcmV3YXJkcycpCiAgICAvLyAKICAgIC8vICAgLy8gRW5zdXJlIHdlIGRvbid0IHByb2Nlc3MgdG9vIG1hbnkgc3Rha2VycyBpbiBvbmUgY2FsbCAoZ2FzIGxpbWl0IHByb3RlY3Rpb24pCiAgICAvLyAgIGFzc2VydChzdGFrZXJBZGRyZXNzZXMubGVuZ3RoIDw9IDUwLCAnVG9vIG1hbnkgc3Rha2VycyBpbiBzaW5nbGUgYmF0Y2gnKQogICAgLy8gCiAgICAvLyAgIGxldCB0b3RhbERpc3RyaWJ1dGVkOiB1aW50NjQgPSAwCiAgICAvLyAKICAgIC8vICAgLy8gUHJvY2VzcyBlYWNoIHN0YWtlcgogICAgLy8gICBmb3IgKGNvbnN0IHN0YWtlciBvZiBzdGFrZXJBZGRyZXNzZXMpIHsKICAgIC8vICAgICBjb25zdCByZXdhcmRzQ29tcG91bmRlZCA9IHRoaXMuY29tcG91bmRSZXdhcmRzRm9yVXNlcihzdGFrZXIubmF0aXZlKQogICAgLy8gICAgIHRvdGFsRGlzdHJpYnV0ZWQgPSB0b3RhbERpc3RyaWJ1dGVkICsgcmV3YXJkc0NvbXBvdW5kZWQKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBsYXN0IGRpc3RyaWJ1dGlvbiB0aW1lCiAgICAvLyAgIHRoaXMubGFzdERpc3RyaWJ1dGlvblRpbWUudmFsdWUgPSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogR2V0IGFsbCBub24temVybyBzdGFrZXJzIGNvdW50IChmb3IgbW9uaXRvcmluZyBwdXJwb3NlcykKICAgIC8vICAqIE5vdGU6IFRoaXMgZG9lc24ndCByZXR1cm4gdGhlIGFjdHVhbCBhZGRyZXNzZXMgZHVlIHRvIGJveCBpdGVyYXRpb24gbGltaXRhdGlvbnMKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICAvLyBwdWJsaWMgZ2V0QWN0aXZlU3Rha2Vyc0NvdW50KHN0YWtlckFkZHJlc3NlczogYXJjNC5BZGRyZXNzW10pOiB1aW50NjQgewogICAgLy8gICBsZXQgYWN0aXZlQ291bnQ6IHVpbnQ2NCA9IDAKICAgIC8vIAogICAgLy8gICBmb3IgKGNvbnN0IHN0YWtlciBvZiBzdGFrZXJBZGRyZXNzZXMpIHsKICAgIC8vICAgICBjb25zdCBzdGFrZUluZm8gPSB0aGlzLmdldFVzZXJTdGFrZUluZm8oc3Rha2VyLm5hdGl2ZSkKICAgIC8vICAgICBpZiAoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgPiAwKSB7CiAgICAvLyAgICAgICBhY3RpdmVDb3VudCA9IGFjdGl2ZUNvdW50ICsgMQogICAgLy8gICAgIH0KICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIHJldHVybiBhY3RpdmVDb3VudAogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIFVwZGF0ZSB0aGUgQVBSIGJhc2lzIHBvaW50cwogICAgLy8gICogT25seSB0aGUgYWRtaW4gY2FuIGNhbGwgdGhpcwogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyB1cGRhdGVBUFIobmV3QXByQmFzaXNQb2ludHM6IHVpbnQ2NCk6IHZvaWQgewogICAgLy8gICAvLyBFbnN1cmUgb25seSBhZG1pbiBjYW4gdXBkYXRlIEFQUgogICAgLy8gICBjb25zdCBhZG1pbkFkZHIgPSB0aGlzLmFkbWluQWRkcmVzcy52YWx1ZQogICAgLy8gICBhc3NlcnQoVHhuLnNlbmRlciA9PT0gYWRtaW5BZGRyLCAnT25seSBhZG1pbiBjYW4gdXBkYXRlIEFQUicpCiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIEFQUgogICAgLy8gICB0aGlzLmFwckJhc2lzUG9pbnRzLnZhbHVlID0gbmV3QXByQmFzaXNQb2ludHMKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBVcGRhdGUgdGhlIGFkbWluIGFkZHJlc3MKICAgIC8vICAqIE9ubHkgdGhlIGN1cnJlbnQgYWRtaW4gY2FuIGNhbGwgdGhpcwogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyB1cGRhdGVBZG1pbihuZXdBZG1pbkFkZHJlc3M6IEFjY291bnQpOiB2b2lkIHsKICAgIC8vICAgLy8gRW5zdXJlIG9ubHkgYWRtaW4gY2FuIHVwZGF0ZSBhZG1pbgogICAgLy8gICBjb25zdCBhZG1pbkFkZHIgPSB0aGlzLmFkbWluQWRkcmVzcy52YWx1ZQogICAgLy8gICBhc3NlcnQoVHhuLnNlbmRlciA9PT0gYWRtaW5BZGRyLCAnT25seSBhZG1pbiBjYW4gdXBkYXRlIGFkbWluJykKICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgYWRtaW4gYWRkcmVzcwogICAgLy8gICB0aGlzLmFkbWluQWRkcmVzcy52YWx1ZSA9IG5ld0FkbWluQWRkcmVzcwogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIEdldCBjdXJyZW50IHN0YWtpbmcgc3RhdGlzdGljcyBmb3IgYSB1c2VyCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgLy8gcHVibGljIGdldFVzZXJTdGF0cyh1c2VyQWRkcmVzczogQWNjb3VudCk6IEFycmF5PHVpbnQ2ND4gewogICAgLy8gICBjb25zdCBzdGFrZUluZm8gPSB0aGlzLmdldFVzZXJTdGFrZUluZm8odXNlckFkZHJlc3MpCiAgICAvLyAgIGNvbnN0IHBlbmRpbmdSZXdhcmRzID0gdGhpcy5jYWxjdWxhdGVQZW5kaW5nUmV3YXJkcyh1c2VyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICBjb25zdCByZXN1bHQ6IHVpbnQ2NFtdID0gWwogICAgLy8gICAgIHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlLAogICAgLy8gICAgIHN0YWtlSW5mby5maXJzdFN0YWtlVGltZS5uYXRpdmUsCiAgICAvLyAgICAgc3Rha2VJbmZvLmxhc3RTdGFrZVRpbWUubmF0aXZlLAogICAgLy8gICAgIHN0YWtlSW5mby50b3RhbFJld2FyZHNFYXJuZWQubmF0aXZlLAogICAgLy8gICAgIHBlbmRpbmdSZXdhcmRzLAogICAgLy8gICAgIHN0YWtlSW5mby5sYXN0Q2xhaW1lZFBlcmlvZC5uYXRpdmUsCiAgICAvLyAgIF0KICAgIC8vIAogICAgLy8gICByZXR1cm4gcmVzdWx0CiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogR2V0IGNvbnRyYWN0IGdsb2JhbCBzdGF0aXN0aWNzCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgLy8gcHVibGljIGdldENvbnRyYWN0U3RhdHMoKTogQXJyYXk8dWludDY0PiB7CiAgICAvLyAgIGNvbnN0IHJlc3VsdDogdWludDY0W10gPSBbCiAgICAvLyAgICAgdGhpcy5hc3NldC52YWx1ZS5pZCwKICAgIC8vICAgICB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlLAogICAgLy8gICAgIHRoaXMuYXByQmFzaXNQb2ludHMudmFsdWUsCiAgICAvLyAgICAgdGhpcy5sYXN0RGlzdHJpYnV0aW9uVGltZS52YWx1ZSwKICAgIC8vICAgICB0aGlzLmRpc3RyaWJ1dGlvblBlcmlvZFJvdW5kcy52YWx1ZSwKICAgIC8vICAgICB0aGlzLm1pbmltdW1TdGFrZS52YWx1ZSwKICAgIC8vICAgICB0aGlzLnJld2FyZFBvb2wudmFsdWUsCiAgICAvLyAgICAgdGhpcy5nZXRDdXJyZW50UGVyaW9kKCksCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTkKICAgIC8vIHB1YmxpYyBkaXN0cmlidXRpb25QZXJpb2RSb3VuZHMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICB1bmNvdmVyIDQKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTYtNDg3CiAgICAvLyBwdWJsaWMgdG90YWxTdGFrZWQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICAvLyBwdWJsaWMgYXByQmFzaXNQb2ludHMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICAvLyBwdWJsaWMgbGFzdERpc3RyaWJ1dGlvblRpbWUgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICAvLyBwdWJsaWMgZGlzdHJpYnV0aW9uUGVyaW9kUm91bmRzID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgLy8gcHVibGljIG1pbmltdW1TdGFrZSA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIC8vIHB1YmxpYyByZXdhcmRQb29sID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgLy8gCiAgICAvLyBwdWJsaWMgc3Rha2VycyA9IEJveE1hcDxBY2NvdW50LCBVc2VyU3Rha2VJbmZvPih7IGtleVByZWZpeDogJ3N0YWtlcnMnIH0pCiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogSGVscGVyIGZ1bmN0aW9uIHRvIHJlYWQgdXNlciBzdGFrZSBpbmZvIGZyb20gYm94IHN0b3JhZ2UKICAgIC8vICAqLwogICAgLy8gcHVibGljIGdldFVzZXJTdGFrZUluZm8odXNlckFkZHJlc3M6IEFjY291bnQpOiBVc2VyU3Rha2VJbmZvIHsKICAgIC8vICAgY29uc3QgdXNlckJveCA9IHRoaXMuc3Rha2Vycyh1c2VyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICBpZiAodXNlckJveC5leGlzdHMpIHsKICAgIC8vICAgICByZXR1cm4gdXNlckJveC52YWx1ZS5jb3B5KCkKICAgIC8vICAgfSBlbHNlIHsKICAgIC8vICAgICByZXR1cm4gbmV3IFVzZXJTdGFrZUluZm8oewogICAgLy8gICAgICAgc3Rha2VkQW1vdW50OiBuZXcgYXJjNC5VaW50TjY0KDApLAogICAgLy8gICAgICAgZmlyc3RTdGFrZVRpbWU6IG5ldyBhcmM0LlVpbnRONjQoMCksCiAgICAvLyAgICAgICBsYXN0U3Rha2VUaW1lOiBuZXcgYXJjNC5VaW50TjY0KDApLAogICAgLy8gICAgICAgdG90YWxSZXdhcmRzRWFybmVkOiBuZXcgYXJjNC5VaW50TjY0KDApLAogICAgLy8gICAgICAgbGFzdENsYWltZWRQZXJpb2Q6IG5ldyBhcmM0LlVpbnRONjQoMCksCiAgICAvLyAgICAgfSkKICAgIC8vICAgfQogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIEhlbHBlciBmdW5jdGlvbiB0byBzdG9yZSB1c2VyIHN0YWtlIGluZm8gaW4gYm94IHN0b3JhZ2UKICAgIC8vICAqLwogICAgLy8gcHVibGljIHN0b3JlVXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzczogQWNjb3VudCwgc3Rha2VJbmZvOiBVc2VyU3Rha2VJbmZvKTogdm9pZCB7CiAgICAvLyAgIHRoaXMuc3Rha2Vycyh1c2VyQWRkcmVzcykudmFsdWUgPSBzdGFrZUluZm8uY29weSgpCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogQ2FsY3VsYXRlIHRoZSBjdXJyZW50IGRpc3RyaWJ1dGlvbiBwZXJpb2QKICAgIC8vICAqLwogICAgLy8gcHVibGljIGdldEN1cnJlbnRQZXJpb2QoKTogdWludDY0IHsKICAgIC8vICAgY29uc3QgcGVyaW9kU2Vjb25kcyA9IHRoaXMuZGlzdHJpYnV0aW9uUGVyaW9kUm91bmRzLnZhbHVlCiAgICAvLyAgIGlmIChwZXJpb2RTZWNvbmRzID09PSAwKSByZXR1cm4gMAogICAgLy8gICByZXR1cm4gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCAvIHBlcmlvZFNlY29uZHMKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBJbml0aWFsaXplIHRoZSBjb250cmFjdCB3aXRoIHRoZSBBU0EgdG9rZW4gSUQgYW5kIG90aGVyIHBhcmFtZXRlcnMKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgaW5pdGlhbGl6ZSgKICAgIC8vICAgYXNzZXQ6IEFzc2V0LAogICAgLy8gICBhZG1pbkFkZHJlc3M6IEFjY291bnQsCiAgICAvLyAgIGFwckJhc2lzUG9pbnRzOiB1aW50NjQsCiAgICAvLyAgIGRpc3RyaWJ1dGlvblBlcmlvZFNlY29uZHM6IHVpbnQ2NCwKICAgIC8vICAgbWluaW11bVN0YWtlOiB1aW50NjQsCiAgICAvLyApOiB2b2lkIHsKICAgIC8vICAgLy8gRW5zdXJlIHRoaXMgaXMgb25seSBjYWxsZWQgZHVyaW5nIGNvbnRyYWN0IGNyZWF0aW9uCiAgICAvLyAgIGFzc2VydCh0aGlzLmFzc2V0LnZhbHVlID09PSBBc3NldCgpLCAnQWxyZWFkeSBpbml0aWFsaXplZCcpCiAgICAvLyAKICAgIC8vICAgLy8gRW5zdXJlIG9ubHkgdGhlIGNyZWF0b3IgY2FuIGluaXRpYWxpemUKICAgIC8vICAgYXNzZXJ0KFR4bi5zZW5kZXIgPT09IEdsb2JhbC5jcmVhdG9yQWRkcmVzcywgJ09ubHkgY3JlYXRvciBjYW4gaW5pdGlhbGl6ZScpCiAgICAvLyAKICAgIC8vICAgLy8gU3RvcmUgdGhlIGluaXRpYWwgcGFyYW1ldGVycwogICAgLy8gICB0aGlzLmFzc2V0LnZhbHVlID0gYXNzZXQKICAgIC8vICAgdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUgPSBhZG1pbkFkZHJlc3MKICAgIC8vICAgdGhpcy50b3RhbFN0YWtlZC52YWx1ZSA9IDAKICAgIC8vICAgdGhpcy5hcHJCYXNpc1BvaW50cy52YWx1ZSA9IGFwckJhc2lzUG9pbnRzCiAgICAvLyAgIHRoaXMubGFzdERpc3RyaWJ1dGlvblRpbWUudmFsdWUgPSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wCiAgICAvLyAgIHRoaXMuZGlzdHJpYnV0aW9uUGVyaW9kUm91bmRzLnZhbHVlID0gZGlzdHJpYnV0aW9uUGVyaW9kU2Vjb25kcwogICAgLy8gICB0aGlzLm1pbmltdW1TdGFrZS52YWx1ZSA9IG1pbmltdW1TdGFrZQogICAgLy8gICB0aGlzLnJld2FyZFBvb2wudmFsdWUgPSAwCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogT3B0IHRoZSBjb250cmFjdCBpbnRvIHRoZSBBU0EKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgb3B0SW5Ub0Fzc2V0KCk6IHZvaWQgewogICAgLy8gICAvLyBFbnN1cmUgb25seSB0aGUgY3JlYXRvciBvciBhZG1pbiBjYW4gb3B0IGluCiAgICAvLyAgIGNvbnN0IGFkbWluQWRkciA9IHRoaXMuYWRtaW5BZGRyZXNzLnZhbHVlCiAgICAvLyAgIGFzc2VydChUeG4uc2VuZGVyID09PSBHbG9iYWwuY3JlYXRvckFkZHJlc3MgfHwgVHhuLnNlbmRlciA9PT0gYWRtaW5BZGRyLCAnT25seSBjcmVhdG9yIG9yIGFkbWluIGNhbiBvcHQgaW4nKQogICAgLy8gCiAgICAvLyAgIC8vIE9wdCB0aGUgY29udHJhY3QgaW50byB0aGUgQVNBCiAgICAvLyAgIGNvbnN0IGFzc2V0ID0gdGhpcy5hc3NldC52YWx1ZQogICAgLy8gICBpdHhuCiAgICAvLyAgICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgICAgYXNzZXRSZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgICBhc3NldEFtb3VudDogMCwKICAgIC8vICAgICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgICAgfSkKICAgIC8vICAgICAuc3VibWl0KCkKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBTdGFrZSB0b2tlbnMKICAgIC8vICAqIFJlcXVpcmVzIGEgY29tcGFuaW9uIEFTQSB0cmFuc2ZlciB0cmFuc2FjdGlvbgogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyBzdGFrZSgpOiB2b2lkIHsKICAgIC8vICAgLy8gRW5zdXJlIHRoZSBjb250cmFjdCBoYXMgb3B0ZWQgaW50byB0aGUgQVNBCiAgICAvLyAgIGNvbnN0IGFzc2V0ID0gdGhpcy5hc3NldC52YWx1ZQogICAgLy8gICBhc3NlcnQodGhpcy5hc3NldC52YWx1ZSAhPT0gQXNzZXQoKSwgJ0NvbnRyYWN0IG5vdCBpbml0aWFsaXplZCcpCiAgICAvLyAKICAgIC8vICAgLy8gRW5zdXJlIHRoaXMgY2FsbCBoYXMgYSBjb21wYW5pb24gQVNBIHRyYW5zZmVyIHRyYW5zYWN0aW9uCiAgICAvLyAgIGFzc2VydChHbG9iYWwuZ3JvdXBTaXplID09PSAyLCAnRXhwZWN0ZWQgMiB0eG5zIGluIGdyb3VwJykKICAgIC8vIAogICAgLy8gICAvLyBHZXQgdGhlIEFTQSB0cmFuc2ZlciBkZXRhaWxzCiAgICAvLyAgIGNvbnN0IHhmZXJUeG4gPSBndHhuLkFzc2V0VHJhbnNmZXJUeG4oMCkKICAgIC8vICAgYXNzZXJ0KHhmZXJUeG4udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFzc2V0VHJhbnNmZXIsICdUcmFuc2FjdGlvbiAwIG11c3QgYmUgYXNzZXQgdHJhbnNmZXInKQogICAgLy8gICBhc3NlcnQoeGZlclR4bi5hc3NldFJlY2VpdmVyID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywgJ0Fzc2V0IHRyYW5zZmVyIG11c3QgYmUgdG8gY29udHJhY3QnKQogICAgLy8gICBhc3NlcnQoeGZlclR4bi5hc3NldEFtb3VudCA+IDAsICdNdXN0IHN0YWtlIG5vbi16ZXJvIGFtb3VudCcpCiAgICAvLyAgIGFzc2VydCh4ZmVyVHhuLnhmZXJBc3NldCA9PT0gYXNzZXQsICdJbmNvcnJlY3QgYXNzZXQgSUQnKQogICAgLy8gCiAgICAvLyAgIC8vIEdldCB0aGUgc3Rha2UgYW1vdW50IGZyb20gdGhlIHRyYW5zYWN0aW9uCiAgICAvLyAgIGNvbnN0IHN0YWtlQW1vdW50ID0geGZlclR4bi5hc3NldEFtb3VudAogICAgLy8gICBjb25zdCBtaW5pbXVtU3Rha2UgPSB0aGlzLm1pbmltdW1TdGFrZS52YWx1ZQogICAgLy8gCiAgICAvLyAgIC8vIEdldCB0aGUgY3VycmVudCB1c2VyIHN0YWtlIGluZm8KICAgIC8vICAgY29uc3Qgc2VuZGVyQWRkcmVzcyA9IFR4bi5zZW5kZXIKICAgIC8vICAgY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHNlbmRlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgLy8gSWYgdGhpcyBpcyBhIG5ldyBzdGFrZSwgZW5zdXJlIGl0IG1lZXRzIG1pbmltdW0KICAgIC8vICAgaWYgKHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlID09PSAwKSB7CiAgICAvLyAgICAgYXNzZXJ0KHN0YWtlQW1vdW50ID49IG1pbmltdW1TdGFrZSwgJ0luaXRpYWwgc3Rha2UgYmVsb3cgbWluaW11bScpCiAgICAvLyAgICAgLy8gU2V0IHRoZSBpbml0aWFsIGNsYWltIHBlcmlvZCB0byBjdXJyZW50IHBlcmlvZAogICAgLy8gICAgIHN0YWtlSW5mby5sYXN0Q2xhaW1lZFBlcmlvZCA9IG5ldyBhcmM0LlVpbnRONjQodGhpcy5nZXRDdXJyZW50UGVyaW9kKCkpCiAgICAvLyAgICAgLy8gU2V0IHRoZSBmaXJzdCBzdGFrZSB0aW1lICh0aGlzIG5ldmVyIGNoYW5nZXMgYWZ0ZXIgaW5pdGlhbCBzdGFrZSkKICAgIC8vICAgICBzdGFrZUluZm8uZmlyc3RTdGFrZVRpbWUgPSBuZXcgYXJjNC5VaW50TjY0KEdsb2JhbC5sYXRlc3RUaW1lc3RhbXApCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgc3Rha2UgaW5mbwogICAgLy8gICBzdGFrZUluZm8uc3Rha2VkQW1vdW50ID0gbmV3IGFyYzQuVWludE42NChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSArIHN0YWtlQW1vdW50KQogICAgLy8gICBzdGFrZUluZm8ubGFzdFN0YWtlVGltZSA9IG5ldyBhcmM0LlVpbnRONjQoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCkKICAgIC8vIAogICAgLy8gICAvLyBTdG9yZSB1cGRhdGVkIHN0YWtlIGluZm8KICAgIC8vICAgdGhpcy5zdG9yZVVzZXJTdGFrZUluZm8oc2VuZGVyQWRkcmVzcywgc3Rha2VJbmZvKQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBnbG9iYWwgc3RhdGUKICAgIC8vICAgdGhpcy50b3RhbFN0YWtlZC52YWx1ZSA9IHRoaXMudG90YWxTdGFrZWQudmFsdWUgKyBzdGFrZUFtb3VudAogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIFdpdGhkcmF3IHN0YWtlZCB0b2tlbnMKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgd2l0aGRyYXcoYW1vdW50OiB1aW50NjQpOiB2b2lkIHsKICAgIC8vICAgY29uc3Qgc2VuZGVyQWRkcmVzcyA9IFR4bi5zZW5kZXIKICAgIC8vICAgY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHNlbmRlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgLy8gRW5zdXJlIHVzZXIgaGFzIGVub3VnaCBzdGFrZWQKICAgIC8vICAgYXNzZXJ0KHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlID4gMCwgJ05vIHN0YWtlIGZvdW5kJykKICAgIC8vICAgYXNzZXJ0KGFtb3VudCA8PSBzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSwgJ1dpdGhkcmF3YWwgYW1vdW50IGV4Y2VlZHMgc3Rha2UnKQogICAgLy8gICBhc3NlcnQoYW1vdW50ID4gMCwgJ1dpdGhkcmF3YWwgYW1vdW50IG11c3QgYmUgcG9zaXRpdmUnKQogICAgLy8gCiAgICAvLyAgIC8vIElmIHdpdGhkcmF3aW5nIGFsbCwgbm8gbmVlZCB0byBjaGVjayBtaW5pbXVtIHJlbWFpbmluZwogICAgLy8gICAvLyBJZiBwYXJ0aWFsIHdpdGhkcmF3YWwsIGVuc3VyZSByZW1haW5pbmcgc3Rha2UgbWVldHMgbWluaW11bQogICAgLy8gICBpZiAoYW1vdW50IDwgc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUpIHsKICAgIC8vICAgICBjb25zdCByZW1haW5pbmdTdGFrZTogdWludDY0ID0gc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgLSBhbW91bnQKICAgIC8vICAgICBjb25zdCBtaW5pbXVtU3Rha2UgPSB0aGlzLm1pbmltdW1TdGFrZS52YWx1ZQogICAgLy8gICAgIGFzc2VydChyZW1haW5pbmdTdGFrZSA+PSBtaW5pbXVtU3Rha2UsICdSZW1haW5pbmcgc3Rha2Ugd291bGQgYmUgYmVsb3cgbWluaW11bScpCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgc3Rha2UgaW5mbwogICAgLy8gICBzdGFrZUluZm8uc3Rha2VkQW1vdW50ID0gbmV3IGFyYzQuVWludE42NChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSAtIGFtb3VudCkKICAgIC8vIAogICAgLy8gICAvLyBTdG9yZSB1cGRhdGVkIHN0YWtlIGluZm8KICAgIC8vICAgdGhpcy5zdG9yZVVzZXJTdGFrZUluZm8oc2VuZGVyQWRkcmVzcywgc3Rha2VJbmZvKQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBnbG9iYWwgc3RhdGUKICAgIC8vICAgdGhpcy50b3RhbFN0YWtlZC52YWx1ZSA9IHRoaXMudG90YWxTdGFrZWQudmFsdWUgLSBhbW91bnQKICAgIC8vIAogICAgLy8gICAvLyBUcmFuc2ZlciB0b2tlbnMgYmFjayB0byB1c2VyCiAgICAvLyAgIGNvbnN0IGFzc2V0ID0gdGhpcy5hc3NldC52YWx1ZQogICAgLy8gICBpdHhuCiAgICAvLyAgICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgICAgYXNzZXRSZWNlaXZlcjogVHhuLnNlbmRlciwKICAgIC8vICAgICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICAgICAgZmVlOiAxMDAwLAogICAgLy8gICAgIH0pCiAgICAvLyAgICAgLnN1Ym1pdCgpCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogQWRkIHJld2FyZHMgdG8gdGhlIHJld2FyZCBwb29sCiAgICAvLyAgKiBPbmx5IHRoZSBhZG1pbiBjYW4gY2FsbCB0aGlzCiAgICAvLyAgKiBSZXF1aXJlcyBhIGNvbXBhbmlvbiBBU0EgdHJhbnNmZXIgdHJhbnNhY3Rpb24gd2l0aCB0aGUgcmV3YXJkcwogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyBhZGRSZXdhcmRzKCk6IHZvaWQgewogICAgLy8gICAvLyBFbnN1cmUgb25seSBhZG1pbiBjYW4gYWRkIHJld2FyZHMKICAgIC8vICAgY29uc3QgYWRtaW5BZGRyID0gdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUKICAgIC8vICAgYXNzZXJ0KFR4bi5zZW5kZXIgPT09IGFkbWluQWRkciwgJ09ubHkgYWRtaW4gY2FuIGFkZCByZXdhcmRzJykKICAgIC8vIAogICAgLy8gICAvLyBFbnN1cmUgdGhpcyBjYWxsIGhhcyBhIGNvbXBhbmlvbiBBU0EgdHJhbnNmZXIgdHJhbnNhY3Rpb24gd2l0aCByZXdhcmRzCiAgICAvLyAgIGFzc2VydChHbG9iYWwuZ3JvdXBTaXplID09PSAyLCAnRXhwZWN0ZWQgMiB0eG5zIGluIGdyb3VwJykKICAgIC8vIAogICAgLy8gICAvLyBHZXQgdGhlIEFTQSB0cmFuc2ZlciBkZXRhaWxzCiAgICAvLyAgIGNvbnN0IGFzc2V0ID0gdGhpcy5hc3NldC52YWx1ZQogICAgLy8gICBjb25zdCB4ZmVyVHhuID0gZ3R4bi5Bc3NldFRyYW5zZmVyVHhuKDApCiAgICAvLyAgIGFzc2VydCh4ZmVyVHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5Bc3NldFRyYW5zZmVyLCAnVHJhbnNhY3Rpb24gMCBtdXN0IGJlIGFzc2V0IHRyYW5zZmVyJykKICAgIC8vICAgYXNzZXJ0KHhmZXJUeG4uYXNzZXRSZWNlaXZlciA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsICdBc3NldCB0cmFuc2ZlciBtdXN0IGJlIHRvIGNvbnRyYWN0JykKICAgIC8vICAgYXNzZXJ0KHhmZXJUeG4uYXNzZXRBbW91bnQgPiAwLCAnTXVzdCBwcm92aWRlIG5vbi16ZXJvIHJld2FyZHMnKQogICAgLy8gICBhc3NlcnQoeGZlclR4bi54ZmVyQXNzZXQgPT09IGFzc2V0LCAnSW5jb3JyZWN0IGFzc2V0IElEJykKICAgIC8vIAogICAgLy8gICAvLyBBZGQgcmV3YXJkcyB0byB0aGUgcG9vbAogICAgLy8gICB0aGlzLnJld2FyZFBvb2wudmFsdWUgPSB0aGlzLnJld2FyZFBvb2wudmFsdWUgKyB4ZmVyVHhuLmFzc2V0QW1vdW50CiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogQ2FsY3VsYXRlIHJld2FyZHMgZm9yIGEgc3BlY2lmaWMgdXNlciBmb3IgYSBnaXZlbiBwZXJpb2QKICAgIC8vICAqIFRoaXMgY2FsY3VsYXRlcyByZXdhcmRzIHBlciBkaXN0cmlidXRpb24gcGVyaW9kCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgLy8gcHVibGljIGNhbGN1bGF0ZVVzZXJSZXdhcmRzRm9yUGVyaW9kKHVzZXJBZGRyZXNzOiBBY2NvdW50KTogdWludDY0IHsKICAgIC8vICAgY29uc3QgYXByID0gdGhpcy5hcHJCYXNpc1BvaW50cy52YWx1ZQogICAgLy8gICBjb25zdCB0b3RhbFN0YWtlZCA9IHRoaXMudG90YWxTdGFrZWQudmFsdWUKICAgIC8vICAgY29uc3QgcGVyaW9kU2Vjb25kcyA9IHRoaXMuZGlzdHJpYnV0aW9uUGVyaW9kUm91bmRzLnZhbHVlCiAgICAvLyAKICAgIC8vICAgLy8gSWYgbm8gdG90YWwgc3Rha2Ugb3Igbm8gcGVyaW9kIGRlZmluZWQsIHJldHVybiAwCiAgICAvLyAgIGlmICh0b3RhbFN0YWtlZCA9PT0gMCB8fCBwZXJpb2RTZWNvbmRzID09PSAwKSB7CiAgICAvLyAgICAgcmV0dXJuIDAKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIEdldCB0aGUgdXNlcidzIHN0YWtlIGluZm8KICAgIC8vICAgY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIC8vIElmIHVzZXIgaGFzIG5vIHN0YWtlLCByZXR1cm4gMAogICAgLy8gICBpZiAoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgPT09IDApIHsKICAgIC8vICAgICByZXR1cm4gMAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gR2V0IHVzZXIncyBzdGFrZSBhbW91bnQgYW5kIGZpcnN0IHN0YWtlIHRpbWUKICAgIC8vICAgY29uc3QgdXNlclN0YWtlID0gc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUKICAgIC8vICAgY29uc3QgZmlyc3RTdGFrZVRpbWUgPSBzdGFrZUluZm8uZmlyc3RTdGFrZVRpbWUubmF0aXZlCiAgICAvLyAKICAgIC8vICAgLy8gQ2hlY2sgaWYgdXNlciBoYXMgYmVlbiBzdGFrZWQgZm9yIHRoZSBtaW5pbXVtIHBlcmlvZCAodXNpbmcgZmlyc3Qgc3Rha2UgdGltZSkKICAgIC8vICAgY29uc3QgbWluaW11bVN0YWtlVGltZTogdWludDY0ID0gUk9VTkRTX1BFUl9EQVkKICAgIC8vICAgaWYgKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgPCBmaXJzdFN0YWtlVGltZSArIG1pbmltdW1TdGFrZVRpbWUpIHsKICAgIC8vICAgICByZXR1cm4gMAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gQ2FsY3VsYXRlIHJld2FyZCByYXRlIGZvciB0aGUgcGVyaW9kCiAgICAvLyAgIC8vIEFQUiBpcyBpbiBiYXNpcyBwb2ludHMgKGUuZy4sIDUwMCA9IDUlKQogICAgLy8gICAvLyBDb252ZXJ0IEFQUiB0byBwZXJpb2QgcmF0ZTogKEFQUiAvIDEwMDAwKSAqIChwZXJpb2RTZWNvbmRzIC8gMzE1MzYwMDApCiAgICAvLyAgIC8vIHdoZXJlIDMxNTM2MDAwIGlzIHNlY29uZHMgaW4gYSB5ZWFyCiAgICAvLyAgIGNvbnN0IHllYXJJblNlY29uZHM6IHVpbnQ2NCA9IFJPVU5EU19QRVJfWUVBUgogICAgLy8gICBjb25zdCBwZXJpb2RSYXRlTnVtZXJhdG9yOiB1aW50NjQgPSBhcHIgKiBwZXJpb2RTZWNvbmRzCiAgICAvLyAgIGNvbnN0IHBlcmlvZFJhdGVEZW5vbWluYXRvcjogdWludDY0ID0gMTAwMDAgKiB5ZWFySW5TZWNvbmRzCiAgICAvLyAKICAgIC8vICAgLy8gQ2FsY3VsYXRlIHJld2FyZDogdXNlclN0YWtlICogcGVyaW9kUmF0ZQogICAgLy8gICBjb25zdCByZXdhcmQ6IHVpbnQ2NCA9ICh1c2VyU3Rha2UgKiBwZXJpb2RSYXRlTnVtZXJhdG9yKSAvIHBlcmlvZFJhdGVEZW5vbWluYXRvcgogICAgLy8gCiAgICAvLyAgIHJldHVybiByZXdhcmQKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBDYWxjdWxhdGUgcGVuZGluZyByZXdhcmRzIGZvciBhIHVzZXIgc2luY2UgdGhlaXIgbGFzdCBjbGFpbQogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIHB1YmxpYyBjYWxjdWxhdGVQZW5kaW5nUmV3YXJkcyh1c2VyQWRkcmVzczogQWNjb3VudCk6IHVpbnQ2NCB7CiAgICAvLyAgIGNvbnN0IHN0YWtlSW5mbyA9IHRoaXMuZ2V0VXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICBpZiAoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgPT09IDApIHsKICAgIC8vICAgICByZXR1cm4gMAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgY29uc3QgY3VycmVudFBlcmlvZCA9IHRoaXMuZ2V0Q3VycmVudFBlcmlvZCgpCiAgICAvLyAgIGNvbnN0IGxhc3RDbGFpbWVkUGVyaW9kID0gc3Rha2VJbmZvLmxhc3RDbGFpbWVkUGVyaW9kLm5hdGl2ZQogICAgLy8gCiAgICAvLyAgIC8vIENhbGN1bGF0ZSBwZXJpb2RzIHNpbmNlIGxhc3QgY2xhaW0KICAgIC8vICAgY29uc3QgcGVyaW9kc1NpbmNlTGFzdENsYWltOiB1aW50NjQgPSBjdXJyZW50UGVyaW9kID4gbGFzdENsYWltZWRQZXJpb2QgPyBjdXJyZW50UGVyaW9kIC0gbGFzdENsYWltZWRQZXJpb2QgOiAwCiAgICAvLyAKICAgIC8vICAgaWYgKHBlcmlvZHNTaW5jZUxhc3RDbGFpbSA9PT0gMCkgewogICAgLy8gICAgIHJldHVybiAwCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBDYWxjdWxhdGUgcmV3YXJkIHBlciBwZXJpb2QKICAgIC8vICAgY29uc3QgcmV3YXJkUGVyUGVyaW9kID0gdGhpcy5jYWxjdWxhdGVVc2VyUmV3YXJkc0ZvclBlcmlvZCh1c2VyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICByZXR1cm4gcmV3YXJkUGVyUGVyaW9kICogcGVyaW9kc1NpbmNlTGFzdENsYWltCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbXBvdW5kIHJld2FyZHMgZm9yIGEgc2luZ2xlIHVzZXIKICAgIC8vICAqIFVzZWQgYnkgdGhlIGF1dG9tYXRlZCBkaXN0cmlidXRpb24gc3lzdGVtCiAgICAvLyAgKi8KICAgIC8vIHByaXZhdGUgY29tcG91bmRSZXdhcmRzRm9yVXNlcih1c2VyQWRkcmVzczogQWNjb3VudCk6IHVpbnQ2NCB7CiAgICAvLyAgIGNvbnN0IHN0YWtlSW5mbyA9IHRoaXMuZ2V0VXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICAvLyBTa2lwIGlmIHVzZXIgaGFzIG5vIHN0YWtlCiAgICAvLyAgIGlmIChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSA9PT0gMCkgewogICAgLy8gICAgIHJldHVybiAwCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBDYWxjdWxhdGUgcGVuZGluZyByZXdhcmRzCiAgICAvLyAgIGNvbnN0IHBlbmRpbmdSZXdhcmRzID0gdGhpcy5jYWxjdWxhdGVQZW5kaW5nUmV3YXJkcyh1c2VyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICAvLyBTa2lwIGlmIG5vIHJld2FyZHMgdG8gY29tcG91bmQKICAgIC8vICAgaWYgKHBlbmRpbmdSZXdhcmRzID09PSAwKSB7CiAgICAvLyAgICAgcmV0dXJuIDAKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIFNraXAgaWYgcmV3YXJkIHBvb2wgaGFzIGluc3VmZmljaWVudCBmdW5kcyBmb3IgdGhpcyB1c2VyCiAgICAvLyAgIGlmICh0aGlzLnJld2FyZFBvb2wudmFsdWUgPCBwZW5kaW5nUmV3YXJkcykgewogICAgLy8gICAgIHJldHVybiAwCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBBdXRvLWNvbXBvdW5kOiBBZGQgcmV3YXJkcyB0byBzdGFrZWQgYW1vdW50CiAgICAvLyAgIHN0YWtlSW5mby5zdGFrZWRBbW91bnQgPSBuZXcgYXJjNC5VaW50TjY0KHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlICsgcGVuZGluZ1Jld2FyZHMpCiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIHRvdGFsIHJld2FyZHMgZWFybmVkCiAgICAvLyAgIHN0YWtlSW5mby50b3RhbFJld2FyZHNFYXJuZWQgPSBuZXcgYXJjNC5VaW50TjY0KHN0YWtlSW5mby50b3RhbFJld2FyZHNFYXJuZWQubmF0aXZlICsgcGVuZGluZ1Jld2FyZHMpCiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIGxhc3QgY2xhaW1lZCBwZXJpb2QgdG8gY3VycmVudCBwZXJpb2QKICAgIC8vICAgc3Rha2VJbmZvLmxhc3RDbGFpbWVkUGVyaW9kID0gbmV3IGFyYzQuVWludE42NCh0aGlzLmdldEN1cnJlbnRQZXJpb2QoKSkKICAgIC8vIAogICAgLy8gICAvLyBTdG9yZSB1cGRhdGVkIHN0YWtlIGluZm8KICAgIC8vICAgdGhpcy5zdG9yZVVzZXJTdGFrZUluZm8odXNlckFkZHJlc3MsIHN0YWtlSW5mbykKICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgZ2xvYmFsIHN0YXRlCiAgICAvLyAgIHRoaXMudG90YWxTdGFrZWQudmFsdWUgPSB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlICsgcGVuZGluZ1Jld2FyZHMKICAgIC8vICAgdGhpcy5yZXdhcmRQb29sLnZhbHVlID0gdGhpcy5yZXdhcmRQb29sLnZhbHVlIC0gcGVuZGluZ1Jld2FyZHMKICAgIC8vIAogICAgLy8gICByZXR1cm4gcGVuZGluZ1Jld2FyZHMKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBEaXN0cmlidXRlIGFuZCBjb21wb3VuZCByZXdhcmRzIGZvciBtdWx0aXBsZSBzdGFrZXJzCiAgICAvLyAgKiBUaGlzIG1ldGhvZCBpcyBkZXNpZ25lZCB0byBiZSBjYWxsZWQgYnkgYSBjcm9uIGpvYiBvbiBhIGRhaWx5IGJhc2lzCiAgICAvLyAgKiBPbmx5IGFkbWluIGNhbiBjYWxsIHRoaXMgbWV0aG9kCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIGRpc3RyaWJ1dGVSZXdhcmRzKHN0YWtlckFkZHJlc3NlczogYXJjNC5BZGRyZXNzW10pOiB2b2lkIHsKICAgIC8vICAgLy8gRW5zdXJlIG9ubHkgYWRtaW4gY2FuIGRpc3RyaWJ1dGUgcmV3YXJkcwogICAgLy8gICBjb25zdCBhZG1pbkFkZHIgPSB0aGlzLmFkbWluQWRkcmVzcy52YWx1ZQogICAgLy8gICBhc3NlcnQoVHhuLnNlbmRlciA9PT0gYWRtaW5BZGRyLCAnT25seSBhZG1pbiBjYW4gZGlzdHJpYnV0ZSByZXdhcmRzJykKICAgIC8vIAogICAgLy8gICAvLyBFbnN1cmUgd2UgZG9uJ3QgcHJvY2VzcyB0b28gbWFueSBzdGFrZXJzIGluIG9uZSBjYWxsIChnYXMgbGltaXQgcHJvdGVjdGlvbikKICAgIC8vICAgYXNzZXJ0KHN0YWtlckFkZHJlc3Nlcy5sZW5ndGggPD0gNTAsICdUb28gbWFueSBzdGFrZXJzIGluIHNpbmdsZSBiYXRjaCcpCiAgICAvLyAKICAgIC8vICAgbGV0IHRvdGFsRGlzdHJpYnV0ZWQ6IHVpbnQ2NCA9IDAKICAgIC8vIAogICAgLy8gICAvLyBQcm9jZXNzIGVhY2ggc3Rha2VyCiAgICAvLyAgIGZvciAoY29uc3Qgc3Rha2VyIG9mIHN0YWtlckFkZHJlc3NlcykgewogICAgLy8gICAgIGNvbnN0IHJld2FyZHNDb21wb3VuZGVkID0gdGhpcy5jb21wb3VuZFJld2FyZHNGb3JVc2VyKHN0YWtlci5uYXRpdmUpCiAgICAvLyAgICAgdG90YWxEaXN0cmlidXRlZCA9IHRvdGFsRGlzdHJpYnV0ZWQgKyByZXdhcmRzQ29tcG91bmRlZAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIGxhc3QgZGlzdHJpYnV0aW9uIHRpbWUKICAgIC8vICAgdGhpcy5sYXN0RGlzdHJpYnV0aW9uVGltZS52YWx1ZSA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBHZXQgYWxsIG5vbi16ZXJvIHN0YWtlcnMgY291bnQgKGZvciBtb25pdG9yaW5nIHB1cnBvc2VzKQogICAgLy8gICogTm90ZTogVGhpcyBkb2Vzbid0IHJldHVybiB0aGUgYWN0dWFsIGFkZHJlc3NlcyBkdWUgdG8gYm94IGl0ZXJhdGlvbiBsaW1pdGF0aW9ucwogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIHB1YmxpYyBnZXRBY3RpdmVTdGFrZXJzQ291bnQoc3Rha2VyQWRkcmVzc2VzOiBhcmM0LkFkZHJlc3NbXSk6IHVpbnQ2NCB7CiAgICAvLyAgIGxldCBhY3RpdmVDb3VudDogdWludDY0ID0gMAogICAgLy8gCiAgICAvLyAgIGZvciAoY29uc3Qgc3Rha2VyIG9mIHN0YWtlckFkZHJlc3NlcykgewogICAgLy8gICAgIGNvbnN0IHN0YWtlSW5mbyA9IHRoaXMuZ2V0VXNlclN0YWtlSW5mbyhzdGFrZXIubmF0aXZlKQogICAgLy8gICAgIGlmIChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSA+IDApIHsKICAgIC8vICAgICAgIGFjdGl2ZUNvdW50ID0gYWN0aXZlQ291bnQgKyAxCiAgICAvLyAgICAgfQogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgcmV0dXJuIGFjdGl2ZUNvdW50CiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogVXBkYXRlIHRoZSBBUFIgYmFzaXMgcG9pbnRzCiAgICAvLyAgKiBPbmx5IHRoZSBhZG1pbiBjYW4gY2FsbCB0aGlzCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIHVwZGF0ZUFQUihuZXdBcHJCYXNpc1BvaW50czogdWludDY0KTogdm9pZCB7CiAgICAvLyAgIC8vIEVuc3VyZSBvbmx5IGFkbWluIGNhbiB1cGRhdGUgQVBSCiAgICAvLyAgIGNvbnN0IGFkbWluQWRkciA9IHRoaXMuYWRtaW5BZGRyZXNzLnZhbHVlCiAgICAvLyAgIGFzc2VydChUeG4uc2VuZGVyID09PSBhZG1pbkFkZHIsICdPbmx5IGFkbWluIGNhbiB1cGRhdGUgQVBSJykKICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgQVBSCiAgICAvLyAgIHRoaXMuYXByQmFzaXNQb2ludHMudmFsdWUgPSBuZXdBcHJCYXNpc1BvaW50cwogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIFVwZGF0ZSB0aGUgYWRtaW4gYWRkcmVzcwogICAgLy8gICogT25seSB0aGUgY3VycmVudCBhZG1pbiBjYW4gY2FsbCB0aGlzCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIHVwZGF0ZUFkbWluKG5ld0FkbWluQWRkcmVzczogQWNjb3VudCk6IHZvaWQgewogICAgLy8gICAvLyBFbnN1cmUgb25seSBhZG1pbiBjYW4gdXBkYXRlIGFkbWluCiAgICAvLyAgIGNvbnN0IGFkbWluQWRkciA9IHRoaXMuYWRtaW5BZGRyZXNzLnZhbHVlCiAgICAvLyAgIGFzc2VydChUeG4uc2VuZGVyID09PSBhZG1pbkFkZHIsICdPbmx5IGFkbWluIGNhbiB1cGRhdGUgYWRtaW4nKQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBhZG1pbiBhZGRyZXNzCiAgICAvLyAgIHRoaXMuYWRtaW5BZGRyZXNzLnZhbHVlID0gbmV3QWRtaW5BZGRyZXNzCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogR2V0IGN1cnJlbnQgc3Rha2luZyBzdGF0aXN0aWNzIGZvciBhIHVzZXIKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICAvLyBwdWJsaWMgZ2V0VXNlclN0YXRzKHVzZXJBZGRyZXNzOiBBY2NvdW50KTogQXJyYXk8dWludDY0PiB7CiAgICAvLyAgIGNvbnN0IHN0YWtlSW5mbyA9IHRoaXMuZ2V0VXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzcykKICAgIC8vICAgY29uc3QgcGVuZGluZ1Jld2FyZHMgPSB0aGlzLmNhbGN1bGF0ZVBlbmRpbmdSZXdhcmRzKHVzZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIGNvbnN0IHJlc3VsdDogdWludDY0W10gPSBbCiAgICAvLyAgICAgc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUsCiAgICAvLyAgICAgc3Rha2VJbmZvLmZpcnN0U3Rha2VUaW1lLm5hdGl2ZSwKICAgIC8vICAgICBzdGFrZUluZm8ubGFzdFN0YWtlVGltZS5uYXRpdmUsCiAgICAvLyAgICAgc3Rha2VJbmZvLnRvdGFsUmV3YXJkc0Vhcm5lZC5uYXRpdmUsCiAgICAvLyAgICAgcGVuZGluZ1Jld2FyZHMsCiAgICAvLyAgICAgc3Rha2VJbmZvLmxhc3RDbGFpbWVkUGVyaW9kLm5hdGl2ZSwKICAgIC8vICAgXQogICAgLy8gCiAgICAvLyAgIHJldHVybiByZXN1bHQKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBHZXQgY29udHJhY3QgZ2xvYmFsIHN0YXRpc3RpY3MKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICAvLyBwdWJsaWMgZ2V0Q29udHJhY3RTdGF0cygpOiBBcnJheTx1aW50NjQ+IHsKICAgIC8vICAgY29uc3QgcmVzdWx0OiB1aW50NjRbXSA9IFsKICAgIC8vICAgICB0aGlzLmFzc2V0LnZhbHVlLmlkLAogICAgLy8gICAgIHRoaXMudG90YWxTdGFrZWQudmFsdWUsCiAgICAvLyAgICAgdGhpcy5hcHJCYXNpc1BvaW50cy52YWx1ZSwKICAgIC8vICAgICB0aGlzLmxhc3REaXN0cmlidXRpb25UaW1lLnZhbHVlLAogICAgLy8gICAgIHRoaXMuZGlzdHJpYnV0aW9uUGVyaW9kUm91bmRzLnZhbHVlLAogICAgLy8gICAgIHRoaXMubWluaW11bVN0YWtlLnZhbHVlLAogICAgLy8gICAgIHRoaXMucmV3YXJkUG9vbC52YWx1ZSwKICAgIC8vICAgICB0aGlzLmdldEN1cnJlbnRQZXJpb2QoKSwKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2MAogICAgLy8gcHVibGljIG1pbmltdW1TdGFrZSA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIHVuY292ZXIgMwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1Ni00ODcKICAgIC8vIHB1YmxpYyB0b3RhbFN0YWtlZCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIC8vIHB1YmxpYyBhcHJCYXNpc1BvaW50cyA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIC8vIHB1YmxpYyBsYXN0RGlzdHJpYnV0aW9uVGltZSA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIC8vIHB1YmxpYyBkaXN0cmlidXRpb25QZXJpb2RSb3VuZHMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICAvLyBwdWJsaWMgbWluaW11bVN0YWtlID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgLy8gcHVibGljIHJld2FyZFBvb2wgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICAvLyAKICAgIC8vIHB1YmxpYyBzdGFrZXJzID0gQm94TWFwPEFjY291bnQsIFVzZXJTdGFrZUluZm8+KHsga2V5UHJlZml4OiAnc3Rha2VycycgfSkKICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gcmVhZCB1c2VyIHN0YWtlIGluZm8gZnJvbSBib3ggc3RvcmFnZQogICAgLy8gICovCiAgICAvLyBwdWJsaWMgZ2V0VXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzczogQWNjb3VudCk6IFVzZXJTdGFrZUluZm8gewogICAgLy8gICBjb25zdCB1c2VyQm94ID0gdGhpcy5zdGFrZXJzKHVzZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIGlmICh1c2VyQm94LmV4aXN0cykgewogICAgLy8gICAgIHJldHVybiB1c2VyQm94LnZhbHVlLmNvcHkoKQogICAgLy8gICB9IGVsc2UgewogICAgLy8gICAgIHJldHVybiBuZXcgVXNlclN0YWtlSW5mbyh7CiAgICAvLyAgICAgICBzdGFrZWRBbW91bnQ6IG5ldyBhcmM0LlVpbnRONjQoMCksCiAgICAvLyAgICAgICBmaXJzdFN0YWtlVGltZTogbmV3IGFyYzQuVWludE42NCgwKSwKICAgIC8vICAgICAgIGxhc3RTdGFrZVRpbWU6IG5ldyBhcmM0LlVpbnRONjQoMCksCiAgICAvLyAgICAgICB0b3RhbFJld2FyZHNFYXJuZWQ6IG5ldyBhcmM0LlVpbnRONjQoMCksCiAgICAvLyAgICAgICBsYXN0Q2xhaW1lZFBlcmlvZDogbmV3IGFyYzQuVWludE42NCgwKSwKICAgIC8vICAgICB9KQogICAgLy8gICB9CiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogSGVscGVyIGZ1bmN0aW9uIHRvIHN0b3JlIHVzZXIgc3Rha2UgaW5mbyBpbiBib3ggc3RvcmFnZQogICAgLy8gICovCiAgICAvLyBwdWJsaWMgc3RvcmVVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzOiBBY2NvdW50LCBzdGFrZUluZm86IFVzZXJTdGFrZUluZm8pOiB2b2lkIHsKICAgIC8vICAgdGhpcy5zdGFrZXJzKHVzZXJBZGRyZXNzKS52YWx1ZSA9IHN0YWtlSW5mby5jb3B5KCkKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBDYWxjdWxhdGUgdGhlIGN1cnJlbnQgZGlzdHJpYnV0aW9uIHBlcmlvZAogICAgLy8gICovCiAgICAvLyBwdWJsaWMgZ2V0Q3VycmVudFBlcmlvZCgpOiB1aW50NjQgewogICAgLy8gICBjb25zdCBwZXJpb2RTZWNvbmRzID0gdGhpcy5kaXN0cmlidXRpb25QZXJpb2RSb3VuZHMudmFsdWUKICAgIC8vICAgaWYgKHBlcmlvZFNlY29uZHMgPT09IDApIHJldHVybiAwCiAgICAvLyAgIHJldHVybiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wIC8gcGVyaW9kU2Vjb25kcwogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIEluaXRpYWxpemUgdGhlIGNvbnRyYWN0IHdpdGggdGhlIEFTQSB0b2tlbiBJRCBhbmQgb3RoZXIgcGFyYW1ldGVycwogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyBpbml0aWFsaXplKAogICAgLy8gICBhc3NldDogQXNzZXQsCiAgICAvLyAgIGFkbWluQWRkcmVzczogQWNjb3VudCwKICAgIC8vICAgYXByQmFzaXNQb2ludHM6IHVpbnQ2NCwKICAgIC8vICAgZGlzdHJpYnV0aW9uUGVyaW9kU2Vjb25kczogdWludDY0LAogICAgLy8gICBtaW5pbXVtU3Rha2U6IHVpbnQ2NCwKICAgIC8vICk6IHZvaWQgewogICAgLy8gICAvLyBFbnN1cmUgdGhpcyBpcyBvbmx5IGNhbGxlZCBkdXJpbmcgY29udHJhY3QgY3JlYXRpb24KICAgIC8vICAgYXNzZXJ0KHRoaXMuYXNzZXQudmFsdWUgPT09IEFzc2V0KCksICdBbHJlYWR5IGluaXRpYWxpemVkJykKICAgIC8vIAogICAgLy8gICAvLyBFbnN1cmUgb25seSB0aGUgY3JlYXRvciBjYW4gaW5pdGlhbGl6ZQogICAgLy8gICBhc3NlcnQoVHhuLnNlbmRlciA9PT0gR2xvYmFsLmNyZWF0b3JBZGRyZXNzLCAnT25seSBjcmVhdG9yIGNhbiBpbml0aWFsaXplJykKICAgIC8vIAogICAgLy8gICAvLyBTdG9yZSB0aGUgaW5pdGlhbCBwYXJhbWV0ZXJzCiAgICAvLyAgIHRoaXMuYXNzZXQudmFsdWUgPSBhc3NldAogICAgLy8gICB0aGlzLmFkbWluQWRkcmVzcy52YWx1ZSA9IGFkbWluQWRkcmVzcwogICAgLy8gICB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlID0gMAogICAgLy8gICB0aGlzLmFwckJhc2lzUG9pbnRzLnZhbHVlID0gYXByQmFzaXNQb2ludHMKICAgIC8vICAgdGhpcy5sYXN0RGlzdHJpYnV0aW9uVGltZS52YWx1ZSA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIC8vICAgdGhpcy5kaXN0cmlidXRpb25QZXJpb2RSb3VuZHMudmFsdWUgPSBkaXN0cmlidXRpb25QZXJpb2RTZWNvbmRzCiAgICAvLyAgIHRoaXMubWluaW11bVN0YWtlLnZhbHVlID0gbWluaW11bVN0YWtlCiAgICAvLyAgIHRoaXMucmV3YXJkUG9vbC52YWx1ZSA9IDAKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBPcHQgdGhlIGNvbnRyYWN0IGludG8gdGhlIEFTQQogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyBvcHRJblRvQXNzZXQoKTogdm9pZCB7CiAgICAvLyAgIC8vIEVuc3VyZSBvbmx5IHRoZSBjcmVhdG9yIG9yIGFkbWluIGNhbiBvcHQgaW4KICAgIC8vICAgY29uc3QgYWRtaW5BZGRyID0gdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUKICAgIC8vICAgYXNzZXJ0KFR4bi5zZW5kZXIgPT09IEdsb2JhbC5jcmVhdG9yQWRkcmVzcyB8fCBUeG4uc2VuZGVyID09PSBhZG1pbkFkZHIsICdPbmx5IGNyZWF0b3Igb3IgYWRtaW4gY2FuIG9wdCBpbicpCiAgICAvLyAKICAgIC8vICAgLy8gT3B0IHRoZSBjb250cmFjdCBpbnRvIHRoZSBBU0EKICAgIC8vICAgY29uc3QgYXNzZXQgPSB0aGlzLmFzc2V0LnZhbHVlCiAgICAvLyAgIGl0eG4KICAgIC8vICAgICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICAgIGFzc2V0QW1vdW50OiAwLAogICAgLy8gICAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgICB9KQogICAgLy8gICAgIC5zdWJtaXQoKQogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIFN0YWtlIHRva2VucwogICAgLy8gICogUmVxdWlyZXMgYSBjb21wYW5pb24gQVNBIHRyYW5zZmVyIHRyYW5zYWN0aW9uCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIHN0YWtlKCk6IHZvaWQgewogICAgLy8gICAvLyBFbnN1cmUgdGhlIGNvbnRyYWN0IGhhcyBvcHRlZCBpbnRvIHRoZSBBU0EKICAgIC8vICAgY29uc3QgYXNzZXQgPSB0aGlzLmFzc2V0LnZhbHVlCiAgICAvLyAgIGFzc2VydCh0aGlzLmFzc2V0LnZhbHVlICE9PSBBc3NldCgpLCAnQ29udHJhY3Qgbm90IGluaXRpYWxpemVkJykKICAgIC8vIAogICAgLy8gICAvLyBFbnN1cmUgdGhpcyBjYWxsIGhhcyBhIGNvbXBhbmlvbiBBU0EgdHJhbnNmZXIgdHJhbnNhY3Rpb24KICAgIC8vICAgYXNzZXJ0KEdsb2JhbC5ncm91cFNpemUgPT09IDIsICdFeHBlY3RlZCAyIHR4bnMgaW4gZ3JvdXAnKQogICAgLy8gCiAgICAvLyAgIC8vIEdldCB0aGUgQVNBIHRyYW5zZmVyIGRldGFpbHMKICAgIC8vICAgY29uc3QgeGZlclR4biA9IGd0eG4uQXNzZXRUcmFuc2ZlclR4bigwKQogICAgLy8gICBhc3NlcnQoeGZlclR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXNzZXRUcmFuc2ZlciwgJ1RyYW5zYWN0aW9uIDAgbXVzdCBiZSBhc3NldCB0cmFuc2ZlcicpCiAgICAvLyAgIGFzc2VydCh4ZmVyVHhuLmFzc2V0UmVjZWl2ZXIgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLCAnQXNzZXQgdHJhbnNmZXIgbXVzdCBiZSB0byBjb250cmFjdCcpCiAgICAvLyAgIGFzc2VydCh4ZmVyVHhuLmFzc2V0QW1vdW50ID4gMCwgJ011c3Qgc3Rha2Ugbm9uLXplcm8gYW1vdW50JykKICAgIC8vICAgYXNzZXJ0KHhmZXJUeG4ueGZlckFzc2V0ID09PSBhc3NldCwgJ0luY29ycmVjdCBhc3NldCBJRCcpCiAgICAvLyAKICAgIC8vICAgLy8gR2V0IHRoZSBzdGFrZSBhbW91bnQgZnJvbSB0aGUgdHJhbnNhY3Rpb24KICAgIC8vICAgY29uc3Qgc3Rha2VBbW91bnQgPSB4ZmVyVHhuLmFzc2V0QW1vdW50CiAgICAvLyAgIGNvbnN0IG1pbmltdW1TdGFrZSA9IHRoaXMubWluaW11bVN0YWtlLnZhbHVlCiAgICAvLyAKICAgIC8vICAgLy8gR2V0IHRoZSBjdXJyZW50IHVzZXIgc3Rha2UgaW5mbwogICAgLy8gICBjb25zdCBzZW5kZXJBZGRyZXNzID0gVHhuLnNlbmRlcgogICAgLy8gICBjb25zdCBzdGFrZUluZm8gPSB0aGlzLmdldFVzZXJTdGFrZUluZm8oc2VuZGVyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICAvLyBJZiB0aGlzIGlzIGEgbmV3IHN0YWtlLCBlbnN1cmUgaXQgbWVldHMgbWluaW11bQogICAgLy8gICBpZiAoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgPT09IDApIHsKICAgIC8vICAgICBhc3NlcnQoc3Rha2VBbW91bnQgPj0gbWluaW11bVN0YWtlLCAnSW5pdGlhbCBzdGFrZSBiZWxvdyBtaW5pbXVtJykKICAgIC8vICAgICAvLyBTZXQgdGhlIGluaXRpYWwgY2xhaW0gcGVyaW9kIHRvIGN1cnJlbnQgcGVyaW9kCiAgICAvLyAgICAgc3Rha2VJbmZvLmxhc3RDbGFpbWVkUGVyaW9kID0gbmV3IGFyYzQuVWludE42NCh0aGlzLmdldEN1cnJlbnRQZXJpb2QoKSkKICAgIC8vICAgICAvLyBTZXQgdGhlIGZpcnN0IHN0YWtlIHRpbWUgKHRoaXMgbmV2ZXIgY2hhbmdlcyBhZnRlciBpbml0aWFsIHN0YWtlKQogICAgLy8gICAgIHN0YWtlSW5mby5maXJzdFN0YWtlVGltZSA9IG5ldyBhcmM0LlVpbnRONjQoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCkKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBzdGFrZSBpbmZvCiAgICAvLyAgIHN0YWtlSW5mby5zdGFrZWRBbW91bnQgPSBuZXcgYXJjNC5VaW50TjY0KHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlICsgc3Rha2VBbW91bnQpCiAgICAvLyAgIHN0YWtlSW5mby5sYXN0U3Rha2VUaW1lID0gbmV3IGFyYzQuVWludE42NChHbG9iYWwubGF0ZXN0VGltZXN0YW1wKQogICAgLy8gCiAgICAvLyAgIC8vIFN0b3JlIHVwZGF0ZWQgc3Rha2UgaW5mbwogICAgLy8gICB0aGlzLnN0b3JlVXNlclN0YWtlSW5mbyhzZW5kZXJBZGRyZXNzLCBzdGFrZUluZm8pCiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIGdsb2JhbCBzdGF0ZQogICAgLy8gICB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlID0gdGhpcy50b3RhbFN0YWtlZC52YWx1ZSArIHN0YWtlQW1vdW50CiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogV2l0aGRyYXcgc3Rha2VkIHRva2VucwogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyB3aXRoZHJhdyhhbW91bnQ6IHVpbnQ2NCk6IHZvaWQgewogICAgLy8gICBjb25zdCBzZW5kZXJBZGRyZXNzID0gVHhuLnNlbmRlcgogICAgLy8gICBjb25zdCBzdGFrZUluZm8gPSB0aGlzLmdldFVzZXJTdGFrZUluZm8oc2VuZGVyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICAvLyBFbnN1cmUgdXNlciBoYXMgZW5vdWdoIHN0YWtlZAogICAgLy8gICBhc3NlcnQoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgPiAwLCAnTm8gc3Rha2UgZm91bmQnKQogICAgLy8gICBhc3NlcnQoYW1vdW50IDw9IHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlLCAnV2l0aGRyYXdhbCBhbW91bnQgZXhjZWVkcyBzdGFrZScpCiAgICAvLyAgIGFzc2VydChhbW91bnQgPiAwLCAnV2l0aGRyYXdhbCBhbW91bnQgbXVzdCBiZSBwb3NpdGl2ZScpCiAgICAvLyAKICAgIC8vICAgLy8gSWYgd2l0aGRyYXdpbmcgYWxsLCBubyBuZWVkIHRvIGNoZWNrIG1pbmltdW0gcmVtYWluaW5nCiAgICAvLyAgIC8vIElmIHBhcnRpYWwgd2l0aGRyYXdhbCwgZW5zdXJlIHJlbWFpbmluZyBzdGFrZSBtZWV0cyBtaW5pbXVtCiAgICAvLyAgIGlmIChhbW91bnQgPCBzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSkgewogICAgLy8gICAgIGNvbnN0IHJlbWFpbmluZ1N0YWtlOiB1aW50NjQgPSBzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSAtIGFtb3VudAogICAgLy8gICAgIGNvbnN0IG1pbmltdW1TdGFrZSA9IHRoaXMubWluaW11bVN0YWtlLnZhbHVlCiAgICAvLyAgICAgYXNzZXJ0KHJlbWFpbmluZ1N0YWtlID49IG1pbmltdW1TdGFrZSwgJ1JlbWFpbmluZyBzdGFrZSB3b3VsZCBiZSBiZWxvdyBtaW5pbXVtJykKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBzdGFrZSBpbmZvCiAgICAvLyAgIHN0YWtlSW5mby5zdGFrZWRBbW91bnQgPSBuZXcgYXJjNC5VaW50TjY0KHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlIC0gYW1vdW50KQogICAgLy8gCiAgICAvLyAgIC8vIFN0b3JlIHVwZGF0ZWQgc3Rha2UgaW5mbwogICAgLy8gICB0aGlzLnN0b3JlVXNlclN0YWtlSW5mbyhzZW5kZXJBZGRyZXNzLCBzdGFrZUluZm8pCiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIGdsb2JhbCBzdGF0ZQogICAgLy8gICB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlID0gdGhpcy50b3RhbFN0YWtlZC52YWx1ZSAtIGFtb3VudAogICAgLy8gCiAgICAvLyAgIC8vIFRyYW5zZmVyIHRva2VucyBiYWNrIHRvIHVzZXIKICAgIC8vICAgY29uc3QgYXNzZXQgPSB0aGlzLmFzc2V0LnZhbHVlCiAgICAvLyAgIGl0eG4KICAgIC8vICAgICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiBUeG4uc2VuZGVyLAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgICAgICBmZWU6IDEwMDAsCiAgICAvLyAgICAgfSkKICAgIC8vICAgICAuc3VibWl0KCkKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBBZGQgcmV3YXJkcyB0byB0aGUgcmV3YXJkIHBvb2wKICAgIC8vICAqIE9ubHkgdGhlIGFkbWluIGNhbiBjYWxsIHRoaXMKICAgIC8vICAqIFJlcXVpcmVzIGEgY29tcGFuaW9uIEFTQSB0cmFuc2ZlciB0cmFuc2FjdGlvbiB3aXRoIHRoZSByZXdhcmRzCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIGFkZFJld2FyZHMoKTogdm9pZCB7CiAgICAvLyAgIC8vIEVuc3VyZSBvbmx5IGFkbWluIGNhbiBhZGQgcmV3YXJkcwogICAgLy8gICBjb25zdCBhZG1pbkFkZHIgPSB0aGlzLmFkbWluQWRkcmVzcy52YWx1ZQogICAgLy8gICBhc3NlcnQoVHhuLnNlbmRlciA9PT0gYWRtaW5BZGRyLCAnT25seSBhZG1pbiBjYW4gYWRkIHJld2FyZHMnKQogICAgLy8gCiAgICAvLyAgIC8vIEVuc3VyZSB0aGlzIGNhbGwgaGFzIGEgY29tcGFuaW9uIEFTQSB0cmFuc2ZlciB0cmFuc2FjdGlvbiB3aXRoIHJld2FyZHMKICAgIC8vICAgYXNzZXJ0KEdsb2JhbC5ncm91cFNpemUgPT09IDIsICdFeHBlY3RlZCAyIHR4bnMgaW4gZ3JvdXAnKQogICAgLy8gCiAgICAvLyAgIC8vIEdldCB0aGUgQVNBIHRyYW5zZmVyIGRldGFpbHMKICAgIC8vICAgY29uc3QgYXNzZXQgPSB0aGlzLmFzc2V0LnZhbHVlCiAgICAvLyAgIGNvbnN0IHhmZXJUeG4gPSBndHhuLkFzc2V0VHJhbnNmZXJUeG4oMCkKICAgIC8vICAgYXNzZXJ0KHhmZXJUeG4udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFzc2V0VHJhbnNmZXIsICdUcmFuc2FjdGlvbiAwIG11c3QgYmUgYXNzZXQgdHJhbnNmZXInKQogICAgLy8gICBhc3NlcnQoeGZlclR4bi5hc3NldFJlY2VpdmVyID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywgJ0Fzc2V0IHRyYW5zZmVyIG11c3QgYmUgdG8gY29udHJhY3QnKQogICAgLy8gICBhc3NlcnQoeGZlclR4bi5hc3NldEFtb3VudCA+IDAsICdNdXN0IHByb3ZpZGUgbm9uLXplcm8gcmV3YXJkcycpCiAgICAvLyAgIGFzc2VydCh4ZmVyVHhuLnhmZXJBc3NldCA9PT0gYXNzZXQsICdJbmNvcnJlY3QgYXNzZXQgSUQnKQogICAgLy8gCiAgICAvLyAgIC8vIEFkZCByZXdhcmRzIHRvIHRoZSBwb29sCiAgICAvLyAgIHRoaXMucmV3YXJkUG9vbC52YWx1ZSA9IHRoaXMucmV3YXJkUG9vbC52YWx1ZSArIHhmZXJUeG4uYXNzZXRBbW91bnQKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBDYWxjdWxhdGUgcmV3YXJkcyBmb3IgYSBzcGVjaWZpYyB1c2VyIGZvciBhIGdpdmVuIHBlcmlvZAogICAgLy8gICogVGhpcyBjYWxjdWxhdGVzIHJld2FyZHMgcGVyIGRpc3RyaWJ1dGlvbiBwZXJpb2QKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICAvLyBwdWJsaWMgY2FsY3VsYXRlVXNlclJld2FyZHNGb3JQZXJpb2QodXNlckFkZHJlc3M6IEFjY291bnQpOiB1aW50NjQgewogICAgLy8gICBjb25zdCBhcHIgPSB0aGlzLmFwckJhc2lzUG9pbnRzLnZhbHVlCiAgICAvLyAgIGNvbnN0IHRvdGFsU3Rha2VkID0gdGhpcy50b3RhbFN0YWtlZC52YWx1ZQogICAgLy8gICBjb25zdCBwZXJpb2RTZWNvbmRzID0gdGhpcy5kaXN0cmlidXRpb25QZXJpb2RSb3VuZHMudmFsdWUKICAgIC8vIAogICAgLy8gICAvLyBJZiBubyB0b3RhbCBzdGFrZSBvciBubyBwZXJpb2QgZGVmaW5lZCwgcmV0dXJuIDAKICAgIC8vICAgaWYgKHRvdGFsU3Rha2VkID09PSAwIHx8IHBlcmlvZFNlY29uZHMgPT09IDApIHsKICAgIC8vICAgICByZXR1cm4gMAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gR2V0IHRoZSB1c2VyJ3Mgc3Rha2UgaW5mbwogICAgLy8gICBjb25zdCBzdGFrZUluZm8gPSB0aGlzLmdldFVzZXJTdGFrZUluZm8odXNlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgLy8gSWYgdXNlciBoYXMgbm8gc3Rha2UsIHJldHVybiAwCiAgICAvLyAgIGlmIChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSA9PT0gMCkgewogICAgLy8gICAgIHJldHVybiAwCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBHZXQgdXNlcidzIHN0YWtlIGFtb3VudCBhbmQgZmlyc3Qgc3Rha2UgdGltZQogICAgLy8gICBjb25zdCB1c2VyU3Rha2UgPSBzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZQogICAgLy8gICBjb25zdCBmaXJzdFN0YWtlVGltZSA9IHN0YWtlSW5mby5maXJzdFN0YWtlVGltZS5uYXRpdmUKICAgIC8vIAogICAgLy8gICAvLyBDaGVjayBpZiB1c2VyIGhhcyBiZWVuIHN0YWtlZCBmb3IgdGhlIG1pbmltdW0gcGVyaW9kICh1c2luZyBmaXJzdCBzdGFrZSB0aW1lKQogICAgLy8gICBjb25zdCBtaW5pbXVtU3Rha2VUaW1lOiB1aW50NjQgPSBST1VORFNfUEVSX0RBWQogICAgLy8gICBpZiAoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA8IGZpcnN0U3Rha2VUaW1lICsgbWluaW11bVN0YWtlVGltZSkgewogICAgLy8gICAgIHJldHVybiAwCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBDYWxjdWxhdGUgcmV3YXJkIHJhdGUgZm9yIHRoZSBwZXJpb2QKICAgIC8vICAgLy8gQVBSIGlzIGluIGJhc2lzIHBvaW50cyAoZS5nLiwgNTAwID0gNSUpCiAgICAvLyAgIC8vIENvbnZlcnQgQVBSIHRvIHBlcmlvZCByYXRlOiAoQVBSIC8gMTAwMDApICogKHBlcmlvZFNlY29uZHMgLyAzMTUzNjAwMCkKICAgIC8vICAgLy8gd2hlcmUgMzE1MzYwMDAgaXMgc2Vjb25kcyBpbiBhIHllYXIKICAgIC8vICAgY29uc3QgeWVhckluU2Vjb25kczogdWludDY0ID0gUk9VTkRTX1BFUl9ZRUFSCiAgICAvLyAgIGNvbnN0IHBlcmlvZFJhdGVOdW1lcmF0b3I6IHVpbnQ2NCA9IGFwciAqIHBlcmlvZFNlY29uZHMKICAgIC8vICAgY29uc3QgcGVyaW9kUmF0ZURlbm9taW5hdG9yOiB1aW50NjQgPSAxMDAwMCAqIHllYXJJblNlY29uZHMKICAgIC8vIAogICAgLy8gICAvLyBDYWxjdWxhdGUgcmV3YXJkOiB1c2VyU3Rha2UgKiBwZXJpb2RSYXRlCiAgICAvLyAgIGNvbnN0IHJld2FyZDogdWludDY0ID0gKHVzZXJTdGFrZSAqIHBlcmlvZFJhdGVOdW1lcmF0b3IpIC8gcGVyaW9kUmF0ZURlbm9taW5hdG9yCiAgICAvLyAKICAgIC8vICAgcmV0dXJuIHJld2FyZAogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIENhbGN1bGF0ZSBwZW5kaW5nIHJld2FyZHMgZm9yIGEgdXNlciBzaW5jZSB0aGVpciBsYXN0IGNsYWltCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgLy8gcHVibGljIGNhbGN1bGF0ZVBlbmRpbmdSZXdhcmRzKHVzZXJBZGRyZXNzOiBBY2NvdW50KTogdWludDY0IHsKICAgIC8vICAgY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIGlmIChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSA9PT0gMCkgewogICAgLy8gICAgIHJldHVybiAwCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICBjb25zdCBjdXJyZW50UGVyaW9kID0gdGhpcy5nZXRDdXJyZW50UGVyaW9kKCkKICAgIC8vICAgY29uc3QgbGFzdENsYWltZWRQZXJpb2QgPSBzdGFrZUluZm8ubGFzdENsYWltZWRQZXJpb2QubmF0aXZlCiAgICAvLyAKICAgIC8vICAgLy8gQ2FsY3VsYXRlIHBlcmlvZHMgc2luY2UgbGFzdCBjbGFpbQogICAgLy8gICBjb25zdCBwZXJpb2RzU2luY2VMYXN0Q2xhaW06IHVpbnQ2NCA9IGN1cnJlbnRQZXJpb2QgPiBsYXN0Q2xhaW1lZFBlcmlvZCA/IGN1cnJlbnRQZXJpb2QgLSBsYXN0Q2xhaW1lZFBlcmlvZCA6IDAKICAgIC8vIAogICAgLy8gICBpZiAocGVyaW9kc1NpbmNlTGFzdENsYWltID09PSAwKSB7CiAgICAvLyAgICAgcmV0dXJuIDAKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIENhbGN1bGF0ZSByZXdhcmQgcGVyIHBlcmlvZAogICAgLy8gICBjb25zdCByZXdhcmRQZXJQZXJpb2QgPSB0aGlzLmNhbGN1bGF0ZVVzZXJSZXdhcmRzRm9yUGVyaW9kKHVzZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIHJldHVybiByZXdhcmRQZXJQZXJpb2QgKiBwZXJpb2RzU2luY2VMYXN0Q2xhaW0KICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29tcG91bmQgcmV3YXJkcyBmb3IgYSBzaW5nbGUgdXNlcgogICAgLy8gICogVXNlZCBieSB0aGUgYXV0b21hdGVkIGRpc3RyaWJ1dGlvbiBzeXN0ZW0KICAgIC8vICAqLwogICAgLy8gcHJpdmF0ZSBjb21wb3VuZFJld2FyZHNGb3JVc2VyKHVzZXJBZGRyZXNzOiBBY2NvdW50KTogdWludDY0IHsKICAgIC8vICAgY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIC8vIFNraXAgaWYgdXNlciBoYXMgbm8gc3Rha2UKICAgIC8vICAgaWYgKHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlID09PSAwKSB7CiAgICAvLyAgICAgcmV0dXJuIDAKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIENhbGN1bGF0ZSBwZW5kaW5nIHJld2FyZHMKICAgIC8vICAgY29uc3QgcGVuZGluZ1Jld2FyZHMgPSB0aGlzLmNhbGN1bGF0ZVBlbmRpbmdSZXdhcmRzKHVzZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIC8vIFNraXAgaWYgbm8gcmV3YXJkcyB0byBjb21wb3VuZAogICAgLy8gICBpZiAocGVuZGluZ1Jld2FyZHMgPT09IDApIHsKICAgIC8vICAgICByZXR1cm4gMAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gU2tpcCBpZiByZXdhcmQgcG9vbCBoYXMgaW5zdWZmaWNpZW50IGZ1bmRzIGZvciB0aGlzIHVzZXIKICAgIC8vICAgaWYgKHRoaXMucmV3YXJkUG9vbC52YWx1ZSA8IHBlbmRpbmdSZXdhcmRzKSB7CiAgICAvLyAgICAgcmV0dXJuIDAKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIEF1dG8tY29tcG91bmQ6IEFkZCByZXdhcmRzIHRvIHN0YWtlZCBhbW91bnQKICAgIC8vICAgc3Rha2VJbmZvLnN0YWtlZEFtb3VudCA9IG5ldyBhcmM0LlVpbnRONjQoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgKyBwZW5kaW5nUmV3YXJkcykKICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgdG90YWwgcmV3YXJkcyBlYXJuZWQKICAgIC8vICAgc3Rha2VJbmZvLnRvdGFsUmV3YXJkc0Vhcm5lZCA9IG5ldyBhcmM0LlVpbnRONjQoc3Rha2VJbmZvLnRvdGFsUmV3YXJkc0Vhcm5lZC5uYXRpdmUgKyBwZW5kaW5nUmV3YXJkcykKICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgbGFzdCBjbGFpbWVkIHBlcmlvZCB0byBjdXJyZW50IHBlcmlvZAogICAgLy8gICBzdGFrZUluZm8ubGFzdENsYWltZWRQZXJpb2QgPSBuZXcgYXJjNC5VaW50TjY0KHRoaXMuZ2V0Q3VycmVudFBlcmlvZCgpKQogICAgLy8gCiAgICAvLyAgIC8vIFN0b3JlIHVwZGF0ZWQgc3Rha2UgaW5mbwogICAgLy8gICB0aGlzLnN0b3JlVXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzcywgc3Rha2VJbmZvKQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBnbG9iYWwgc3RhdGUKICAgIC8vICAgdGhpcy50b3RhbFN0YWtlZC52YWx1ZSA9IHRoaXMudG90YWxTdGFrZWQudmFsdWUgKyBwZW5kaW5nUmV3YXJkcwogICAgLy8gICB0aGlzLnJld2FyZFBvb2wudmFsdWUgPSB0aGlzLnJld2FyZFBvb2wudmFsdWUgLSBwZW5kaW5nUmV3YXJkcwogICAgLy8gCiAgICAvLyAgIHJldHVybiBwZW5kaW5nUmV3YXJkcwogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIERpc3RyaWJ1dGUgYW5kIGNvbXBvdW5kIHJld2FyZHMgZm9yIG11bHRpcGxlIHN0YWtlcnMKICAgIC8vICAqIFRoaXMgbWV0aG9kIGlzIGRlc2lnbmVkIHRvIGJlIGNhbGxlZCBieSBhIGNyb24gam9iIG9uIGEgZGFpbHkgYmFzaXMKICAgIC8vICAqIE9ubHkgYWRtaW4gY2FuIGNhbGwgdGhpcyBtZXRob2QKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgZGlzdHJpYnV0ZVJld2FyZHMoc3Rha2VyQWRkcmVzc2VzOiBhcmM0LkFkZHJlc3NbXSk6IHZvaWQgewogICAgLy8gICAvLyBFbnN1cmUgb25seSBhZG1pbiBjYW4gZGlzdHJpYnV0ZSByZXdhcmRzCiAgICAvLyAgIGNvbnN0IGFkbWluQWRkciA9IHRoaXMuYWRtaW5BZGRyZXNzLnZhbHVlCiAgICAvLyAgIGFzc2VydChUeG4uc2VuZGVyID09PSBhZG1pbkFkZHIsICdPbmx5IGFkbWluIGNhbiBkaXN0cmlidXRlIHJld2FyZHMnKQogICAgLy8gCiAgICAvLyAgIC8vIEVuc3VyZSB3ZSBkb24ndCBwcm9jZXNzIHRvbyBtYW55IHN0YWtlcnMgaW4gb25lIGNhbGwgKGdhcyBsaW1pdCBwcm90ZWN0aW9uKQogICAgLy8gICBhc3NlcnQoc3Rha2VyQWRkcmVzc2VzLmxlbmd0aCA8PSA1MCwgJ1RvbyBtYW55IHN0YWtlcnMgaW4gc2luZ2xlIGJhdGNoJykKICAgIC8vIAogICAgLy8gICBsZXQgdG90YWxEaXN0cmlidXRlZDogdWludDY0ID0gMAogICAgLy8gCiAgICAvLyAgIC8vIFByb2Nlc3MgZWFjaCBzdGFrZXIKICAgIC8vICAgZm9yIChjb25zdCBzdGFrZXIgb2Ygc3Rha2VyQWRkcmVzc2VzKSB7CiAgICAvLyAgICAgY29uc3QgcmV3YXJkc0NvbXBvdW5kZWQgPSB0aGlzLmNvbXBvdW5kUmV3YXJkc0ZvclVzZXIoc3Rha2VyLm5hdGl2ZSkKICAgIC8vICAgICB0b3RhbERpc3RyaWJ1dGVkID0gdG90YWxEaXN0cmlidXRlZCArIHJld2FyZHNDb21wb3VuZGVkCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgbGFzdCBkaXN0cmlidXRpb24gdGltZQogICAgLy8gICB0aGlzLmxhc3REaXN0cmlidXRpb25UaW1lLnZhbHVlID0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcAogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIEdldCBhbGwgbm9uLXplcm8gc3Rha2VycyBjb3VudCAoZm9yIG1vbml0b3JpbmcgcHVycG9zZXMpCiAgICAvLyAgKiBOb3RlOiBUaGlzIGRvZXNuJ3QgcmV0dXJuIHRoZSBhY3R1YWwgYWRkcmVzc2VzIGR1ZSB0byBib3ggaXRlcmF0aW9uIGxpbWl0YXRpb25zCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgLy8gcHVibGljIGdldEFjdGl2ZVN0YWtlcnNDb3VudChzdGFrZXJBZGRyZXNzZXM6IGFyYzQuQWRkcmVzc1tdKTogdWludDY0IHsKICAgIC8vICAgbGV0IGFjdGl2ZUNvdW50OiB1aW50NjQgPSAwCiAgICAvLyAKICAgIC8vICAgZm9yIChjb25zdCBzdGFrZXIgb2Ygc3Rha2VyQWRkcmVzc2VzKSB7CiAgICAvLyAgICAgY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHN0YWtlci5uYXRpdmUpCiAgICAvLyAgICAgaWYgKHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlID4gMCkgewogICAgLy8gICAgICAgYWN0aXZlQ291bnQgPSBhY3RpdmVDb3VudCArIDEKICAgIC8vICAgICB9CiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICByZXR1cm4gYWN0aXZlQ291bnQKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBVcGRhdGUgdGhlIEFQUiBiYXNpcyBwb2ludHMKICAgIC8vICAqIE9ubHkgdGhlIGFkbWluIGNhbiBjYWxsIHRoaXMKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgdXBkYXRlQVBSKG5ld0FwckJhc2lzUG9pbnRzOiB1aW50NjQpOiB2b2lkIHsKICAgIC8vICAgLy8gRW5zdXJlIG9ubHkgYWRtaW4gY2FuIHVwZGF0ZSBBUFIKICAgIC8vICAgY29uc3QgYWRtaW5BZGRyID0gdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUKICAgIC8vICAgYXNzZXJ0KFR4bi5zZW5kZXIgPT09IGFkbWluQWRkciwgJ09ubHkgYWRtaW4gY2FuIHVwZGF0ZSBBUFInKQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBBUFIKICAgIC8vICAgdGhpcy5hcHJCYXNpc1BvaW50cy52YWx1ZSA9IG5ld0FwckJhc2lzUG9pbnRzCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogVXBkYXRlIHRoZSBhZG1pbiBhZGRyZXNzCiAgICAvLyAgKiBPbmx5IHRoZSBjdXJyZW50IGFkbWluIGNhbiBjYWxsIHRoaXMKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgdXBkYXRlQWRtaW4obmV3QWRtaW5BZGRyZXNzOiBBY2NvdW50KTogdm9pZCB7CiAgICAvLyAgIC8vIEVuc3VyZSBvbmx5IGFkbWluIGNhbiB1cGRhdGUgYWRtaW4KICAgIC8vICAgY29uc3QgYWRtaW5BZGRyID0gdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUKICAgIC8vICAgYXNzZXJ0KFR4bi5zZW5kZXIgPT09IGFkbWluQWRkciwgJ09ubHkgYWRtaW4gY2FuIHVwZGF0ZSBhZG1pbicpCiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIGFkbWluIGFkZHJlc3MKICAgIC8vICAgdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUgPSBuZXdBZG1pbkFkZHJlc3MKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBHZXQgY3VycmVudCBzdGFraW5nIHN0YXRpc3RpY3MgZm9yIGEgdXNlcgogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIHB1YmxpYyBnZXRVc2VyU3RhdHModXNlckFkZHJlc3M6IEFjY291bnQpOiBBcnJheTx1aW50NjQ+IHsKICAgIC8vICAgY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzKQogICAgLy8gICBjb25zdCBwZW5kaW5nUmV3YXJkcyA9IHRoaXMuY2FsY3VsYXRlUGVuZGluZ1Jld2FyZHModXNlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgY29uc3QgcmVzdWx0OiB1aW50NjRbXSA9IFsKICAgIC8vICAgICBzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSwKICAgIC8vICAgICBzdGFrZUluZm8uZmlyc3RTdGFrZVRpbWUubmF0aXZlLAogICAgLy8gICAgIHN0YWtlSW5mby5sYXN0U3Rha2VUaW1lLm5hdGl2ZSwKICAgIC8vICAgICBzdGFrZUluZm8udG90YWxSZXdhcmRzRWFybmVkLm5hdGl2ZSwKICAgIC8vICAgICBwZW5kaW5nUmV3YXJkcywKICAgIC8vICAgICBzdGFrZUluZm8ubGFzdENsYWltZWRQZXJpb2QubmF0aXZlLAogICAgLy8gICBdCiAgICAvLyAKICAgIC8vICAgcmV0dXJuIHJlc3VsdAogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIEdldCBjb250cmFjdCBnbG9iYWwgc3RhdGlzdGljcwogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIHB1YmxpYyBnZXRDb250cmFjdFN0YXRzKCk6IEFycmF5PHVpbnQ2ND4gewogICAgLy8gICBjb25zdCByZXN1bHQ6IHVpbnQ2NFtdID0gWwogICAgLy8gICAgIHRoaXMuYXNzZXQudmFsdWUuaWQsCiAgICAvLyAgICAgdGhpcy50b3RhbFN0YWtlZC52YWx1ZSwKICAgIC8vICAgICB0aGlzLmFwckJhc2lzUG9pbnRzLnZhbHVlLAogICAgLy8gICAgIHRoaXMubGFzdERpc3RyaWJ1dGlvblRpbWUudmFsdWUsCiAgICAvLyAgICAgdGhpcy5kaXN0cmlidXRpb25QZXJpb2RSb3VuZHMudmFsdWUsCiAgICAvLyAgICAgdGhpcy5taW5pbXVtU3Rha2UudmFsdWUsCiAgICAvLyAgICAgdGhpcy5yZXdhcmRQb29sLnZhbHVlLAogICAgLy8gICAgIHRoaXMuZ2V0Q3VycmVudFBlcmlvZCgpLAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYxCiAgICAvLyBwdWJsaWMgcmV3YXJkUG9vbCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIHVuY292ZXIgMgogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1Ni00ODcKICAgIC8vIHB1YmxpYyB0b3RhbFN0YWtlZCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIC8vIHB1YmxpYyBhcHJCYXNpc1BvaW50cyA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIC8vIHB1YmxpYyBsYXN0RGlzdHJpYnV0aW9uVGltZSA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIC8vIHB1YmxpYyBkaXN0cmlidXRpb25QZXJpb2RSb3VuZHMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICAvLyBwdWJsaWMgbWluaW11bVN0YWtlID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgLy8gcHVibGljIHJld2FyZFBvb2wgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICAvLyAKICAgIC8vIHB1YmxpYyBzdGFrZXJzID0gQm94TWFwPEFjY291bnQsIFVzZXJTdGFrZUluZm8+KHsga2V5UHJlZml4OiAnc3Rha2VycycgfSkKICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gcmVhZCB1c2VyIHN0YWtlIGluZm8gZnJvbSBib3ggc3RvcmFnZQogICAgLy8gICovCiAgICAvLyBwdWJsaWMgZ2V0VXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzczogQWNjb3VudCk6IFVzZXJTdGFrZUluZm8gewogICAgLy8gICBjb25zdCB1c2VyQm94ID0gdGhpcy5zdGFrZXJzKHVzZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIGlmICh1c2VyQm94LmV4aXN0cykgewogICAgLy8gICAgIHJldHVybiB1c2VyQm94LnZhbHVlLmNvcHkoKQogICAgLy8gICB9IGVsc2UgewogICAgLy8gICAgIHJldHVybiBuZXcgVXNlclN0YWtlSW5mbyh7CiAgICAvLyAgICAgICBzdGFrZWRBbW91bnQ6IG5ldyBhcmM0LlVpbnRONjQoMCksCiAgICAvLyAgICAgICBmaXJzdFN0YWtlVGltZTogbmV3IGFyYzQuVWludE42NCgwKSwKICAgIC8vICAgICAgIGxhc3RTdGFrZVRpbWU6IG5ldyBhcmM0LlVpbnRONjQoMCksCiAgICAvLyAgICAgICB0b3RhbFJld2FyZHNFYXJuZWQ6IG5ldyBhcmM0LlVpbnRONjQoMCksCiAgICAvLyAgICAgICBsYXN0Q2xhaW1lZFBlcmlvZDogbmV3IGFyYzQuVWludE42NCgwKSwKICAgIC8vICAgICB9KQogICAgLy8gICB9CiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogSGVscGVyIGZ1bmN0aW9uIHRvIHN0b3JlIHVzZXIgc3Rha2UgaW5mbyBpbiBib3ggc3RvcmFnZQogICAgLy8gICovCiAgICAvLyBwdWJsaWMgc3RvcmVVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzOiBBY2NvdW50LCBzdGFrZUluZm86IFVzZXJTdGFrZUluZm8pOiB2b2lkIHsKICAgIC8vICAgdGhpcy5zdGFrZXJzKHVzZXJBZGRyZXNzKS52YWx1ZSA9IHN0YWtlSW5mby5jb3B5KCkKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBDYWxjdWxhdGUgdGhlIGN1cnJlbnQgZGlzdHJpYnV0aW9uIHBlcmlvZAogICAgLy8gICovCiAgICAvLyBwdWJsaWMgZ2V0Q3VycmVudFBlcmlvZCgpOiB1aW50NjQgewogICAgLy8gICBjb25zdCBwZXJpb2RTZWNvbmRzID0gdGhpcy5kaXN0cmlidXRpb25QZXJpb2RSb3VuZHMudmFsdWUKICAgIC8vICAgaWYgKHBlcmlvZFNlY29uZHMgPT09IDApIHJldHVybiAwCiAgICAvLyAgIHJldHVybiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wIC8gcGVyaW9kU2Vjb25kcwogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIEluaXRpYWxpemUgdGhlIGNvbnRyYWN0IHdpdGggdGhlIEFTQSB0b2tlbiBJRCBhbmQgb3RoZXIgcGFyYW1ldGVycwogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyBpbml0aWFsaXplKAogICAgLy8gICBhc3NldDogQXNzZXQsCiAgICAvLyAgIGFkbWluQWRkcmVzczogQWNjb3VudCwKICAgIC8vICAgYXByQmFzaXNQb2ludHM6IHVpbnQ2NCwKICAgIC8vICAgZGlzdHJpYnV0aW9uUGVyaW9kU2Vjb25kczogdWludDY0LAogICAgLy8gICBtaW5pbXVtU3Rha2U6IHVpbnQ2NCwKICAgIC8vICk6IHZvaWQgewogICAgLy8gICAvLyBFbnN1cmUgdGhpcyBpcyBvbmx5IGNhbGxlZCBkdXJpbmcgY29udHJhY3QgY3JlYXRpb24KICAgIC8vICAgYXNzZXJ0KHRoaXMuYXNzZXQudmFsdWUgPT09IEFzc2V0KCksICdBbHJlYWR5IGluaXRpYWxpemVkJykKICAgIC8vIAogICAgLy8gICAvLyBFbnN1cmUgb25seSB0aGUgY3JlYXRvciBjYW4gaW5pdGlhbGl6ZQogICAgLy8gICBhc3NlcnQoVHhuLnNlbmRlciA9PT0gR2xvYmFsLmNyZWF0b3JBZGRyZXNzLCAnT25seSBjcmVhdG9yIGNhbiBpbml0aWFsaXplJykKICAgIC8vIAogICAgLy8gICAvLyBTdG9yZSB0aGUgaW5pdGlhbCBwYXJhbWV0ZXJzCiAgICAvLyAgIHRoaXMuYXNzZXQudmFsdWUgPSBhc3NldAogICAgLy8gICB0aGlzLmFkbWluQWRkcmVzcy52YWx1ZSA9IGFkbWluQWRkcmVzcwogICAgLy8gICB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlID0gMAogICAgLy8gICB0aGlzLmFwckJhc2lzUG9pbnRzLnZhbHVlID0gYXByQmFzaXNQb2ludHMKICAgIC8vICAgdGhpcy5sYXN0RGlzdHJpYnV0aW9uVGltZS52YWx1ZSA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIC8vICAgdGhpcy5kaXN0cmlidXRpb25QZXJpb2RSb3VuZHMudmFsdWUgPSBkaXN0cmlidXRpb25QZXJpb2RTZWNvbmRzCiAgICAvLyAgIHRoaXMubWluaW11bVN0YWtlLnZhbHVlID0gbWluaW11bVN0YWtlCiAgICAvLyAgIHRoaXMucmV3YXJkUG9vbC52YWx1ZSA9IDAKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBPcHQgdGhlIGNvbnRyYWN0IGludG8gdGhlIEFTQQogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyBvcHRJblRvQXNzZXQoKTogdm9pZCB7CiAgICAvLyAgIC8vIEVuc3VyZSBvbmx5IHRoZSBjcmVhdG9yIG9yIGFkbWluIGNhbiBvcHQgaW4KICAgIC8vICAgY29uc3QgYWRtaW5BZGRyID0gdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUKICAgIC8vICAgYXNzZXJ0KFR4bi5zZW5kZXIgPT09IEdsb2JhbC5jcmVhdG9yQWRkcmVzcyB8fCBUeG4uc2VuZGVyID09PSBhZG1pbkFkZHIsICdPbmx5IGNyZWF0b3Igb3IgYWRtaW4gY2FuIG9wdCBpbicpCiAgICAvLyAKICAgIC8vICAgLy8gT3B0IHRoZSBjb250cmFjdCBpbnRvIHRoZSBBU0EKICAgIC8vICAgY29uc3QgYXNzZXQgPSB0aGlzLmFzc2V0LnZhbHVlCiAgICAvLyAgIGl0eG4KICAgIC8vICAgICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICAgIGFzc2V0QW1vdW50OiAwLAogICAgLy8gICAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgICB9KQogICAgLy8gICAgIC5zdWJtaXQoKQogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIFN0YWtlIHRva2VucwogICAgLy8gICogUmVxdWlyZXMgYSBjb21wYW5pb24gQVNBIHRyYW5zZmVyIHRyYW5zYWN0aW9uCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIHN0YWtlKCk6IHZvaWQgewogICAgLy8gICAvLyBFbnN1cmUgdGhlIGNvbnRyYWN0IGhhcyBvcHRlZCBpbnRvIHRoZSBBU0EKICAgIC8vICAgY29uc3QgYXNzZXQgPSB0aGlzLmFzc2V0LnZhbHVlCiAgICAvLyAgIGFzc2VydCh0aGlzLmFzc2V0LnZhbHVlICE9PSBBc3NldCgpLCAnQ29udHJhY3Qgbm90IGluaXRpYWxpemVkJykKICAgIC8vIAogICAgLy8gICAvLyBFbnN1cmUgdGhpcyBjYWxsIGhhcyBhIGNvbXBhbmlvbiBBU0EgdHJhbnNmZXIgdHJhbnNhY3Rpb24KICAgIC8vICAgYXNzZXJ0KEdsb2JhbC5ncm91cFNpemUgPT09IDIsICdFeHBlY3RlZCAyIHR4bnMgaW4gZ3JvdXAnKQogICAgLy8gCiAgICAvLyAgIC8vIEdldCB0aGUgQVNBIHRyYW5zZmVyIGRldGFpbHMKICAgIC8vICAgY29uc3QgeGZlclR4biA9IGd0eG4uQXNzZXRUcmFuc2ZlclR4bigwKQogICAgLy8gICBhc3NlcnQoeGZlclR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXNzZXRUcmFuc2ZlciwgJ1RyYW5zYWN0aW9uIDAgbXVzdCBiZSBhc3NldCB0cmFuc2ZlcicpCiAgICAvLyAgIGFzc2VydCh4ZmVyVHhuLmFzc2V0UmVjZWl2ZXIgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLCAnQXNzZXQgdHJhbnNmZXIgbXVzdCBiZSB0byBjb250cmFjdCcpCiAgICAvLyAgIGFzc2VydCh4ZmVyVHhuLmFzc2V0QW1vdW50ID4gMCwgJ011c3Qgc3Rha2Ugbm9uLXplcm8gYW1vdW50JykKICAgIC8vICAgYXNzZXJ0KHhmZXJUeG4ueGZlckFzc2V0ID09PSBhc3NldCwgJ0luY29ycmVjdCBhc3NldCBJRCcpCiAgICAvLyAKICAgIC8vICAgLy8gR2V0IHRoZSBzdGFrZSBhbW91bnQgZnJvbSB0aGUgdHJhbnNhY3Rpb24KICAgIC8vICAgY29uc3Qgc3Rha2VBbW91bnQgPSB4ZmVyVHhuLmFzc2V0QW1vdW50CiAgICAvLyAgIGNvbnN0IG1pbmltdW1TdGFrZSA9IHRoaXMubWluaW11bVN0YWtlLnZhbHVlCiAgICAvLyAKICAgIC8vICAgLy8gR2V0IHRoZSBjdXJyZW50IHVzZXIgc3Rha2UgaW5mbwogICAgLy8gICBjb25zdCBzZW5kZXJBZGRyZXNzID0gVHhuLnNlbmRlcgogICAgLy8gICBjb25zdCBzdGFrZUluZm8gPSB0aGlzLmdldFVzZXJTdGFrZUluZm8oc2VuZGVyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICAvLyBJZiB0aGlzIGlzIGEgbmV3IHN0YWtlLCBlbnN1cmUgaXQgbWVldHMgbWluaW11bQogICAgLy8gICBpZiAoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgPT09IDApIHsKICAgIC8vICAgICBhc3NlcnQoc3Rha2VBbW91bnQgPj0gbWluaW11bVN0YWtlLCAnSW5pdGlhbCBzdGFrZSBiZWxvdyBtaW5pbXVtJykKICAgIC8vICAgICAvLyBTZXQgdGhlIGluaXRpYWwgY2xhaW0gcGVyaW9kIHRvIGN1cnJlbnQgcGVyaW9kCiAgICAvLyAgICAgc3Rha2VJbmZvLmxhc3RDbGFpbWVkUGVyaW9kID0gbmV3IGFyYzQuVWludE42NCh0aGlzLmdldEN1cnJlbnRQZXJpb2QoKSkKICAgIC8vICAgICAvLyBTZXQgdGhlIGZpcnN0IHN0YWtlIHRpbWUgKHRoaXMgbmV2ZXIgY2hhbmdlcyBhZnRlciBpbml0aWFsIHN0YWtlKQogICAgLy8gICAgIHN0YWtlSW5mby5maXJzdFN0YWtlVGltZSA9IG5ldyBhcmM0LlVpbnRONjQoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCkKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBzdGFrZSBpbmZvCiAgICAvLyAgIHN0YWtlSW5mby5zdGFrZWRBbW91bnQgPSBuZXcgYXJjNC5VaW50TjY0KHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlICsgc3Rha2VBbW91bnQpCiAgICAvLyAgIHN0YWtlSW5mby5sYXN0U3Rha2VUaW1lID0gbmV3IGFyYzQuVWludE42NChHbG9iYWwubGF0ZXN0VGltZXN0YW1wKQogICAgLy8gCiAgICAvLyAgIC8vIFN0b3JlIHVwZGF0ZWQgc3Rha2UgaW5mbwogICAgLy8gICB0aGlzLnN0b3JlVXNlclN0YWtlSW5mbyhzZW5kZXJBZGRyZXNzLCBzdGFrZUluZm8pCiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIGdsb2JhbCBzdGF0ZQogICAgLy8gICB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlID0gdGhpcy50b3RhbFN0YWtlZC52YWx1ZSArIHN0YWtlQW1vdW50CiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogV2l0aGRyYXcgc3Rha2VkIHRva2VucwogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyB3aXRoZHJhdyhhbW91bnQ6IHVpbnQ2NCk6IHZvaWQgewogICAgLy8gICBjb25zdCBzZW5kZXJBZGRyZXNzID0gVHhuLnNlbmRlcgogICAgLy8gICBjb25zdCBzdGFrZUluZm8gPSB0aGlzLmdldFVzZXJTdGFrZUluZm8oc2VuZGVyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICAvLyBFbnN1cmUgdXNlciBoYXMgZW5vdWdoIHN0YWtlZAogICAgLy8gICBhc3NlcnQoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgPiAwLCAnTm8gc3Rha2UgZm91bmQnKQogICAgLy8gICBhc3NlcnQoYW1vdW50IDw9IHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlLCAnV2l0aGRyYXdhbCBhbW91bnQgZXhjZWVkcyBzdGFrZScpCiAgICAvLyAgIGFzc2VydChhbW91bnQgPiAwLCAnV2l0aGRyYXdhbCBhbW91bnQgbXVzdCBiZSBwb3NpdGl2ZScpCiAgICAvLyAKICAgIC8vICAgLy8gSWYgd2l0aGRyYXdpbmcgYWxsLCBubyBuZWVkIHRvIGNoZWNrIG1pbmltdW0gcmVtYWluaW5nCiAgICAvLyAgIC8vIElmIHBhcnRpYWwgd2l0aGRyYXdhbCwgZW5zdXJlIHJlbWFpbmluZyBzdGFrZSBtZWV0cyBtaW5pbXVtCiAgICAvLyAgIGlmIChhbW91bnQgPCBzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSkgewogICAgLy8gICAgIGNvbnN0IHJlbWFpbmluZ1N0YWtlOiB1aW50NjQgPSBzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSAtIGFtb3VudAogICAgLy8gICAgIGNvbnN0IG1pbmltdW1TdGFrZSA9IHRoaXMubWluaW11bVN0YWtlLnZhbHVlCiAgICAvLyAgICAgYXNzZXJ0KHJlbWFpbmluZ1N0YWtlID49IG1pbmltdW1TdGFrZSwgJ1JlbWFpbmluZyBzdGFrZSB3b3VsZCBiZSBiZWxvdyBtaW5pbXVtJykKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBzdGFrZSBpbmZvCiAgICAvLyAgIHN0YWtlSW5mby5zdGFrZWRBbW91bnQgPSBuZXcgYXJjNC5VaW50TjY0KHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlIC0gYW1vdW50KQogICAgLy8gCiAgICAvLyAgIC8vIFN0b3JlIHVwZGF0ZWQgc3Rha2UgaW5mbwogICAgLy8gICB0aGlzLnN0b3JlVXNlclN0YWtlSW5mbyhzZW5kZXJBZGRyZXNzLCBzdGFrZUluZm8pCiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIGdsb2JhbCBzdGF0ZQogICAgLy8gICB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlID0gdGhpcy50b3RhbFN0YWtlZC52YWx1ZSAtIGFtb3VudAogICAgLy8gCiAgICAvLyAgIC8vIFRyYW5zZmVyIHRva2VucyBiYWNrIHRvIHVzZXIKICAgIC8vICAgY29uc3QgYXNzZXQgPSB0aGlzLmFzc2V0LnZhbHVlCiAgICAvLyAgIGl0eG4KICAgIC8vICAgICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiBUeG4uc2VuZGVyLAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgICAgICBmZWU6IDEwMDAsCiAgICAvLyAgICAgfSkKICAgIC8vICAgICAuc3VibWl0KCkKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBBZGQgcmV3YXJkcyB0byB0aGUgcmV3YXJkIHBvb2wKICAgIC8vICAqIE9ubHkgdGhlIGFkbWluIGNhbiBjYWxsIHRoaXMKICAgIC8vICAqIFJlcXVpcmVzIGEgY29tcGFuaW9uIEFTQSB0cmFuc2ZlciB0cmFuc2FjdGlvbiB3aXRoIHRoZSByZXdhcmRzCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIGFkZFJld2FyZHMoKTogdm9pZCB7CiAgICAvLyAgIC8vIEVuc3VyZSBvbmx5IGFkbWluIGNhbiBhZGQgcmV3YXJkcwogICAgLy8gICBjb25zdCBhZG1pbkFkZHIgPSB0aGlzLmFkbWluQWRkcmVzcy52YWx1ZQogICAgLy8gICBhc3NlcnQoVHhuLnNlbmRlciA9PT0gYWRtaW5BZGRyLCAnT25seSBhZG1pbiBjYW4gYWRkIHJld2FyZHMnKQogICAgLy8gCiAgICAvLyAgIC8vIEVuc3VyZSB0aGlzIGNhbGwgaGFzIGEgY29tcGFuaW9uIEFTQSB0cmFuc2ZlciB0cmFuc2FjdGlvbiB3aXRoIHJld2FyZHMKICAgIC8vICAgYXNzZXJ0KEdsb2JhbC5ncm91cFNpemUgPT09IDIsICdFeHBlY3RlZCAyIHR4bnMgaW4gZ3JvdXAnKQogICAgLy8gCiAgICAvLyAgIC8vIEdldCB0aGUgQVNBIHRyYW5zZmVyIGRldGFpbHMKICAgIC8vICAgY29uc3QgYXNzZXQgPSB0aGlzLmFzc2V0LnZhbHVlCiAgICAvLyAgIGNvbnN0IHhmZXJUeG4gPSBndHhuLkFzc2V0VHJhbnNmZXJUeG4oMCkKICAgIC8vICAgYXNzZXJ0KHhmZXJUeG4udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFzc2V0VHJhbnNmZXIsICdUcmFuc2FjdGlvbiAwIG11c3QgYmUgYXNzZXQgdHJhbnNmZXInKQogICAgLy8gICBhc3NlcnQoeGZlclR4bi5hc3NldFJlY2VpdmVyID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywgJ0Fzc2V0IHRyYW5zZmVyIG11c3QgYmUgdG8gY29udHJhY3QnKQogICAgLy8gICBhc3NlcnQoeGZlclR4bi5hc3NldEFtb3VudCA+IDAsICdNdXN0IHByb3ZpZGUgbm9uLXplcm8gcmV3YXJkcycpCiAgICAvLyAgIGFzc2VydCh4ZmVyVHhuLnhmZXJBc3NldCA9PT0gYXNzZXQsICdJbmNvcnJlY3QgYXNzZXQgSUQnKQogICAgLy8gCiAgICAvLyAgIC8vIEFkZCByZXdhcmRzIHRvIHRoZSBwb29sCiAgICAvLyAgIHRoaXMucmV3YXJkUG9vbC52YWx1ZSA9IHRoaXMucmV3YXJkUG9vbC52YWx1ZSArIHhmZXJUeG4uYXNzZXRBbW91bnQKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBDYWxjdWxhdGUgcmV3YXJkcyBmb3IgYSBzcGVjaWZpYyB1c2VyIGZvciBhIGdpdmVuIHBlcmlvZAogICAgLy8gICogVGhpcyBjYWxjdWxhdGVzIHJld2FyZHMgcGVyIGRpc3RyaWJ1dGlvbiBwZXJpb2QKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICAvLyBwdWJsaWMgY2FsY3VsYXRlVXNlclJld2FyZHNGb3JQZXJpb2QodXNlckFkZHJlc3M6IEFjY291bnQpOiB1aW50NjQgewogICAgLy8gICBjb25zdCBhcHIgPSB0aGlzLmFwckJhc2lzUG9pbnRzLnZhbHVlCiAgICAvLyAgIGNvbnN0IHRvdGFsU3Rha2VkID0gdGhpcy50b3RhbFN0YWtlZC52YWx1ZQogICAgLy8gICBjb25zdCBwZXJpb2RTZWNvbmRzID0gdGhpcy5kaXN0cmlidXRpb25QZXJpb2RSb3VuZHMudmFsdWUKICAgIC8vIAogICAgLy8gICAvLyBJZiBubyB0b3RhbCBzdGFrZSBvciBubyBwZXJpb2QgZGVmaW5lZCwgcmV0dXJuIDAKICAgIC8vICAgaWYgKHRvdGFsU3Rha2VkID09PSAwIHx8IHBlcmlvZFNlY29uZHMgPT09IDApIHsKICAgIC8vICAgICByZXR1cm4gMAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gR2V0IHRoZSB1c2VyJ3Mgc3Rha2UgaW5mbwogICAgLy8gICBjb25zdCBzdGFrZUluZm8gPSB0aGlzLmdldFVzZXJTdGFrZUluZm8odXNlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgLy8gSWYgdXNlciBoYXMgbm8gc3Rha2UsIHJldHVybiAwCiAgICAvLyAgIGlmIChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSA9PT0gMCkgewogICAgLy8gICAgIHJldHVybiAwCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBHZXQgdXNlcidzIHN0YWtlIGFtb3VudCBhbmQgZmlyc3Qgc3Rha2UgdGltZQogICAgLy8gICBjb25zdCB1c2VyU3Rha2UgPSBzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZQogICAgLy8gICBjb25zdCBmaXJzdFN0YWtlVGltZSA9IHN0YWtlSW5mby5maXJzdFN0YWtlVGltZS5uYXRpdmUKICAgIC8vIAogICAgLy8gICAvLyBDaGVjayBpZiB1c2VyIGhhcyBiZWVuIHN0YWtlZCBmb3IgdGhlIG1pbmltdW0gcGVyaW9kICh1c2luZyBmaXJzdCBzdGFrZSB0aW1lKQogICAgLy8gICBjb25zdCBtaW5pbXVtU3Rha2VUaW1lOiB1aW50NjQgPSBST1VORFNfUEVSX0RBWQogICAgLy8gICBpZiAoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCA8IGZpcnN0U3Rha2VUaW1lICsgbWluaW11bVN0YWtlVGltZSkgewogICAgLy8gICAgIHJldHVybiAwCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBDYWxjdWxhdGUgcmV3YXJkIHJhdGUgZm9yIHRoZSBwZXJpb2QKICAgIC8vICAgLy8gQVBSIGlzIGluIGJhc2lzIHBvaW50cyAoZS5nLiwgNTAwID0gNSUpCiAgICAvLyAgIC8vIENvbnZlcnQgQVBSIHRvIHBlcmlvZCByYXRlOiAoQVBSIC8gMTAwMDApICogKHBlcmlvZFNlY29uZHMgLyAzMTUzNjAwMCkKICAgIC8vICAgLy8gd2hlcmUgMzE1MzYwMDAgaXMgc2Vjb25kcyBpbiBhIHllYXIKICAgIC8vICAgY29uc3QgeWVhckluU2Vjb25kczogdWludDY0ID0gUk9VTkRTX1BFUl9ZRUFSCiAgICAvLyAgIGNvbnN0IHBlcmlvZFJhdGVOdW1lcmF0b3I6IHVpbnQ2NCA9IGFwciAqIHBlcmlvZFNlY29uZHMKICAgIC8vICAgY29uc3QgcGVyaW9kUmF0ZURlbm9taW5hdG9yOiB1aW50NjQgPSAxMDAwMCAqIHllYXJJblNlY29uZHMKICAgIC8vIAogICAgLy8gICAvLyBDYWxjdWxhdGUgcmV3YXJkOiB1c2VyU3Rha2UgKiBwZXJpb2RSYXRlCiAgICAvLyAgIGNvbnN0IHJld2FyZDogdWludDY0ID0gKHVzZXJTdGFrZSAqIHBlcmlvZFJhdGVOdW1lcmF0b3IpIC8gcGVyaW9kUmF0ZURlbm9taW5hdG9yCiAgICAvLyAKICAgIC8vICAgcmV0dXJuIHJld2FyZAogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIENhbGN1bGF0ZSBwZW5kaW5nIHJld2FyZHMgZm9yIGEgdXNlciBzaW5jZSB0aGVpciBsYXN0IGNsYWltCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgLy8gcHVibGljIGNhbGN1bGF0ZVBlbmRpbmdSZXdhcmRzKHVzZXJBZGRyZXNzOiBBY2NvdW50KTogdWludDY0IHsKICAgIC8vICAgY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIGlmIChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSA9PT0gMCkgewogICAgLy8gICAgIHJldHVybiAwCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICBjb25zdCBjdXJyZW50UGVyaW9kID0gdGhpcy5nZXRDdXJyZW50UGVyaW9kKCkKICAgIC8vICAgY29uc3QgbGFzdENsYWltZWRQZXJpb2QgPSBzdGFrZUluZm8ubGFzdENsYWltZWRQZXJpb2QubmF0aXZlCiAgICAvLyAKICAgIC8vICAgLy8gQ2FsY3VsYXRlIHBlcmlvZHMgc2luY2UgbGFzdCBjbGFpbQogICAgLy8gICBjb25zdCBwZXJpb2RzU2luY2VMYXN0Q2xhaW06IHVpbnQ2NCA9IGN1cnJlbnRQZXJpb2QgPiBsYXN0Q2xhaW1lZFBlcmlvZCA/IGN1cnJlbnRQZXJpb2QgLSBsYXN0Q2xhaW1lZFBlcmlvZCA6IDAKICAgIC8vIAogICAgLy8gICBpZiAocGVyaW9kc1NpbmNlTGFzdENsYWltID09PSAwKSB7CiAgICAvLyAgICAgcmV0dXJuIDAKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIENhbGN1bGF0ZSByZXdhcmQgcGVyIHBlcmlvZAogICAgLy8gICBjb25zdCByZXdhcmRQZXJQZXJpb2QgPSB0aGlzLmNhbGN1bGF0ZVVzZXJSZXdhcmRzRm9yUGVyaW9kKHVzZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIHJldHVybiByZXdhcmRQZXJQZXJpb2QgKiBwZXJpb2RzU2luY2VMYXN0Q2xhaW0KICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29tcG91bmQgcmV3YXJkcyBmb3IgYSBzaW5nbGUgdXNlcgogICAgLy8gICogVXNlZCBieSB0aGUgYXV0b21hdGVkIGRpc3RyaWJ1dGlvbiBzeXN0ZW0KICAgIC8vICAqLwogICAgLy8gcHJpdmF0ZSBjb21wb3VuZFJld2FyZHNGb3JVc2VyKHVzZXJBZGRyZXNzOiBBY2NvdW50KTogdWludDY0IHsKICAgIC8vICAgY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIC8vIFNraXAgaWYgdXNlciBoYXMgbm8gc3Rha2UKICAgIC8vICAgaWYgKHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlID09PSAwKSB7CiAgICAvLyAgICAgcmV0dXJuIDAKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIENhbGN1bGF0ZSBwZW5kaW5nIHJld2FyZHMKICAgIC8vICAgY29uc3QgcGVuZGluZ1Jld2FyZHMgPSB0aGlzLmNhbGN1bGF0ZVBlbmRpbmdSZXdhcmRzKHVzZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIC8vIFNraXAgaWYgbm8gcmV3YXJkcyB0byBjb21wb3VuZAogICAgLy8gICBpZiAocGVuZGluZ1Jld2FyZHMgPT09IDApIHsKICAgIC8vICAgICByZXR1cm4gMAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gU2tpcCBpZiByZXdhcmQgcG9vbCBoYXMgaW5zdWZmaWNpZW50IGZ1bmRzIGZvciB0aGlzIHVzZXIKICAgIC8vICAgaWYgKHRoaXMucmV3YXJkUG9vbC52YWx1ZSA8IHBlbmRpbmdSZXdhcmRzKSB7CiAgICAvLyAgICAgcmV0dXJuIDAKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIEF1dG8tY29tcG91bmQ6IEFkZCByZXdhcmRzIHRvIHN0YWtlZCBhbW91bnQKICAgIC8vICAgc3Rha2VJbmZvLnN0YWtlZEFtb3VudCA9IG5ldyBhcmM0LlVpbnRONjQoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgKyBwZW5kaW5nUmV3YXJkcykKICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgdG90YWwgcmV3YXJkcyBlYXJuZWQKICAgIC8vICAgc3Rha2VJbmZvLnRvdGFsUmV3YXJkc0Vhcm5lZCA9IG5ldyBhcmM0LlVpbnRONjQoc3Rha2VJbmZvLnRvdGFsUmV3YXJkc0Vhcm5lZC5uYXRpdmUgKyBwZW5kaW5nUmV3YXJkcykKICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgbGFzdCBjbGFpbWVkIHBlcmlvZCB0byBjdXJyZW50IHBlcmlvZAogICAgLy8gICBzdGFrZUluZm8ubGFzdENsYWltZWRQZXJpb2QgPSBuZXcgYXJjNC5VaW50TjY0KHRoaXMuZ2V0Q3VycmVudFBlcmlvZCgpKQogICAgLy8gCiAgICAvLyAgIC8vIFN0b3JlIHVwZGF0ZWQgc3Rha2UgaW5mbwogICAgLy8gICB0aGlzLnN0b3JlVXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzcywgc3Rha2VJbmZvKQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBnbG9iYWwgc3RhdGUKICAgIC8vICAgdGhpcy50b3RhbFN0YWtlZC52YWx1ZSA9IHRoaXMudG90YWxTdGFrZWQudmFsdWUgKyBwZW5kaW5nUmV3YXJkcwogICAgLy8gICB0aGlzLnJld2FyZFBvb2wudmFsdWUgPSB0aGlzLnJld2FyZFBvb2wudmFsdWUgLSBwZW5kaW5nUmV3YXJkcwogICAgLy8gCiAgICAvLyAgIHJldHVybiBwZW5kaW5nUmV3YXJkcwogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIERpc3RyaWJ1dGUgYW5kIGNvbXBvdW5kIHJld2FyZHMgZm9yIG11bHRpcGxlIHN0YWtlcnMKICAgIC8vICAqIFRoaXMgbWV0aG9kIGlzIGRlc2lnbmVkIHRvIGJlIGNhbGxlZCBieSBhIGNyb24gam9iIG9uIGEgZGFpbHkgYmFzaXMKICAgIC8vICAqIE9ubHkgYWRtaW4gY2FuIGNhbGwgdGhpcyBtZXRob2QKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgZGlzdHJpYnV0ZVJld2FyZHMoc3Rha2VyQWRkcmVzc2VzOiBhcmM0LkFkZHJlc3NbXSk6IHZvaWQgewogICAgLy8gICAvLyBFbnN1cmUgb25seSBhZG1pbiBjYW4gZGlzdHJpYnV0ZSByZXdhcmRzCiAgICAvLyAgIGNvbnN0IGFkbWluQWRkciA9IHRoaXMuYWRtaW5BZGRyZXNzLnZhbHVlCiAgICAvLyAgIGFzc2VydChUeG4uc2VuZGVyID09PSBhZG1pbkFkZHIsICdPbmx5IGFkbWluIGNhbiBkaXN0cmlidXRlIHJld2FyZHMnKQogICAgLy8gCiAgICAvLyAgIC8vIEVuc3VyZSB3ZSBkb24ndCBwcm9jZXNzIHRvbyBtYW55IHN0YWtlcnMgaW4gb25lIGNhbGwgKGdhcyBsaW1pdCBwcm90ZWN0aW9uKQogICAgLy8gICBhc3NlcnQoc3Rha2VyQWRkcmVzc2VzLmxlbmd0aCA8PSA1MCwgJ1RvbyBtYW55IHN0YWtlcnMgaW4gc2luZ2xlIGJhdGNoJykKICAgIC8vIAogICAgLy8gICBsZXQgdG90YWxEaXN0cmlidXRlZDogdWludDY0ID0gMAogICAgLy8gCiAgICAvLyAgIC8vIFByb2Nlc3MgZWFjaCBzdGFrZXIKICAgIC8vICAgZm9yIChjb25zdCBzdGFrZXIgb2Ygc3Rha2VyQWRkcmVzc2VzKSB7CiAgICAvLyAgICAgY29uc3QgcmV3YXJkc0NvbXBvdW5kZWQgPSB0aGlzLmNvbXBvdW5kUmV3YXJkc0ZvclVzZXIoc3Rha2VyLm5hdGl2ZSkKICAgIC8vICAgICB0b3RhbERpc3RyaWJ1dGVkID0gdG90YWxEaXN0cmlidXRlZCArIHJld2FyZHNDb21wb3VuZGVkCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgbGFzdCBkaXN0cmlidXRpb24gdGltZQogICAgLy8gICB0aGlzLmxhc3REaXN0cmlidXRpb25UaW1lLnZhbHVlID0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcAogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIEdldCBhbGwgbm9uLXplcm8gc3Rha2VycyBjb3VudCAoZm9yIG1vbml0b3JpbmcgcHVycG9zZXMpCiAgICAvLyAgKiBOb3RlOiBUaGlzIGRvZXNuJ3QgcmV0dXJuIHRoZSBhY3R1YWwgYWRkcmVzc2VzIGR1ZSB0byBib3ggaXRlcmF0aW9uIGxpbWl0YXRpb25zCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgLy8gcHVibGljIGdldEFjdGl2ZVN0YWtlcnNDb3VudChzdGFrZXJBZGRyZXNzZXM6IGFyYzQuQWRkcmVzc1tdKTogdWludDY0IHsKICAgIC8vICAgbGV0IGFjdGl2ZUNvdW50OiB1aW50NjQgPSAwCiAgICAvLyAKICAgIC8vICAgZm9yIChjb25zdCBzdGFrZXIgb2Ygc3Rha2VyQWRkcmVzc2VzKSB7CiAgICAvLyAgICAgY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHN0YWtlci5uYXRpdmUpCiAgICAvLyAgICAgaWYgKHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlID4gMCkgewogICAgLy8gICAgICAgYWN0aXZlQ291bnQgPSBhY3RpdmVDb3VudCArIDEKICAgIC8vICAgICB9CiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICByZXR1cm4gYWN0aXZlQ291bnQKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBVcGRhdGUgdGhlIEFQUiBiYXNpcyBwb2ludHMKICAgIC8vICAqIE9ubHkgdGhlIGFkbWluIGNhbiBjYWxsIHRoaXMKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgdXBkYXRlQVBSKG5ld0FwckJhc2lzUG9pbnRzOiB1aW50NjQpOiB2b2lkIHsKICAgIC8vICAgLy8gRW5zdXJlIG9ubHkgYWRtaW4gY2FuIHVwZGF0ZSBBUFIKICAgIC8vICAgY29uc3QgYWRtaW5BZGRyID0gdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUKICAgIC8vICAgYXNzZXJ0KFR4bi5zZW5kZXIgPT09IGFkbWluQWRkciwgJ09ubHkgYWRtaW4gY2FuIHVwZGF0ZSBBUFInKQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBBUFIKICAgIC8vICAgdGhpcy5hcHJCYXNpc1BvaW50cy52YWx1ZSA9IG5ld0FwckJhc2lzUG9pbnRzCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogVXBkYXRlIHRoZSBhZG1pbiBhZGRyZXNzCiAgICAvLyAgKiBPbmx5IHRoZSBjdXJyZW50IGFkbWluIGNhbiBjYWxsIHRoaXMKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgdXBkYXRlQWRtaW4obmV3QWRtaW5BZGRyZXNzOiBBY2NvdW50KTogdm9pZCB7CiAgICAvLyAgIC8vIEVuc3VyZSBvbmx5IGFkbWluIGNhbiB1cGRhdGUgYWRtaW4KICAgIC8vICAgY29uc3QgYWRtaW5BZGRyID0gdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUKICAgIC8vICAgYXNzZXJ0KFR4bi5zZW5kZXIgPT09IGFkbWluQWRkciwgJ09ubHkgYWRtaW4gY2FuIHVwZGF0ZSBhZG1pbicpCiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIGFkbWluIGFkZHJlc3MKICAgIC8vICAgdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUgPSBuZXdBZG1pbkFkZHJlc3MKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBHZXQgY3VycmVudCBzdGFraW5nIHN0YXRpc3RpY3MgZm9yIGEgdXNlcgogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIHB1YmxpYyBnZXRVc2VyU3RhdHModXNlckFkZHJlc3M6IEFjY291bnQpOiBBcnJheTx1aW50NjQ+IHsKICAgIC8vICAgY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzKQogICAgLy8gICBjb25zdCBwZW5kaW5nUmV3YXJkcyA9IHRoaXMuY2FsY3VsYXRlUGVuZGluZ1Jld2FyZHModXNlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgY29uc3QgcmVzdWx0OiB1aW50NjRbXSA9IFsKICAgIC8vICAgICBzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSwKICAgIC8vICAgICBzdGFrZUluZm8uZmlyc3RTdGFrZVRpbWUubmF0aXZlLAogICAgLy8gICAgIHN0YWtlSW5mby5sYXN0U3Rha2VUaW1lLm5hdGl2ZSwKICAgIC8vICAgICBzdGFrZUluZm8udG90YWxSZXdhcmRzRWFybmVkLm5hdGl2ZSwKICAgIC8vICAgICBwZW5kaW5nUmV3YXJkcywKICAgIC8vICAgICBzdGFrZUluZm8ubGFzdENsYWltZWRQZXJpb2QubmF0aXZlLAogICAgLy8gICBdCiAgICAvLyAKICAgIC8vICAgcmV0dXJuIHJlc3VsdAogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIEdldCBjb250cmFjdCBnbG9iYWwgc3RhdGlzdGljcwogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIHB1YmxpYyBnZXRDb250cmFjdFN0YXRzKCk6IEFycmF5PHVpbnQ2ND4gewogICAgLy8gICBjb25zdCByZXN1bHQ6IHVpbnQ2NFtdID0gWwogICAgLy8gICAgIHRoaXMuYXNzZXQudmFsdWUuaWQsCiAgICAvLyAgICAgdGhpcy50b3RhbFN0YWtlZC52YWx1ZSwKICAgIC8vICAgICB0aGlzLmFwckJhc2lzUG9pbnRzLnZhbHVlLAogICAgLy8gICAgIHRoaXMubGFzdERpc3RyaWJ1dGlvblRpbWUudmFsdWUsCiAgICAvLyAgICAgdGhpcy5kaXN0cmlidXRpb25QZXJpb2RSb3VuZHMudmFsdWUsCiAgICAvLyAgICAgdGhpcy5taW5pbXVtU3Rha2UudmFsdWUsCiAgICAvLyAgICAgdGhpcy5yZXdhcmRQb29sLnZhbHVlLAogICAgLy8gICAgIHRoaXMuZ2V0Q3VycmVudFBlcmlvZCgpLAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ4NwogICAgLy8gdGhpcy5nZXRDdXJyZW50UGVyaW9kKCksCiAgICBzd2FwCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjU2LTQ4NwogICAgLy8gcHVibGljIHRvdGFsU3Rha2VkID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgLy8gcHVibGljIGFwckJhc2lzUG9pbnRzID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgLy8gcHVibGljIGxhc3REaXN0cmlidXRpb25UaW1lID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCB9KQogICAgLy8gcHVibGljIGRpc3RyaWJ1dGlvblBlcmlvZFJvdW5kcyA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIC8vIHB1YmxpYyBtaW5pbXVtU3Rha2UgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICAvLyBwdWJsaWMgcmV3YXJkUG9vbCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIC8vIAogICAgLy8gcHVibGljIHN0YWtlcnMgPSBCb3hNYXA8QWNjb3VudCwgVXNlclN0YWtlSW5mbz4oeyBrZXlQcmVmaXg6ICdzdGFrZXJzJyB9KQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIEhlbHBlciBmdW5jdGlvbiB0byByZWFkIHVzZXIgc3Rha2UgaW5mbyBmcm9tIGJveCBzdG9yYWdlCiAgICAvLyAgKi8KICAgIC8vIHB1YmxpYyBnZXRVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzOiBBY2NvdW50KTogVXNlclN0YWtlSW5mbyB7CiAgICAvLyAgIGNvbnN0IHVzZXJCb3ggPSB0aGlzLnN0YWtlcnModXNlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgaWYgKHVzZXJCb3guZXhpc3RzKSB7CiAgICAvLyAgICAgcmV0dXJuIHVzZXJCb3gudmFsdWUuY29weSgpCiAgICAvLyAgIH0gZWxzZSB7CiAgICAvLyAgICAgcmV0dXJuIG5ldyBVc2VyU3Rha2VJbmZvKHsKICAgIC8vICAgICAgIHN0YWtlZEFtb3VudDogbmV3IGFyYzQuVWludE42NCgwKSwKICAgIC8vICAgICAgIGZpcnN0U3Rha2VUaW1lOiBuZXcgYXJjNC5VaW50TjY0KDApLAogICAgLy8gICAgICAgbGFzdFN0YWtlVGltZTogbmV3IGFyYzQuVWludE42NCgwKSwKICAgIC8vICAgICAgIHRvdGFsUmV3YXJkc0Vhcm5lZDogbmV3IGFyYzQuVWludE42NCgwKSwKICAgIC8vICAgICAgIGxhc3RDbGFpbWVkUGVyaW9kOiBuZXcgYXJjNC5VaW50TjY0KDApLAogICAgLy8gICAgIH0pCiAgICAvLyAgIH0KICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gc3RvcmUgdXNlciBzdGFrZSBpbmZvIGluIGJveCBzdG9yYWdlCiAgICAvLyAgKi8KICAgIC8vIHB1YmxpYyBzdG9yZVVzZXJTdGFrZUluZm8odXNlckFkZHJlc3M6IEFjY291bnQsIHN0YWtlSW5mbzogVXNlclN0YWtlSW5mbyk6IHZvaWQgewogICAgLy8gICB0aGlzLnN0YWtlcnModXNlckFkZHJlc3MpLnZhbHVlID0gc3Rha2VJbmZvLmNvcHkoKQogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIENhbGN1bGF0ZSB0aGUgY3VycmVudCBkaXN0cmlidXRpb24gcGVyaW9kCiAgICAvLyAgKi8KICAgIC8vIHB1YmxpYyBnZXRDdXJyZW50UGVyaW9kKCk6IHVpbnQ2NCB7CiAgICAvLyAgIGNvbnN0IHBlcmlvZFNlY29uZHMgPSB0aGlzLmRpc3RyaWJ1dGlvblBlcmlvZFJvdW5kcy52YWx1ZQogICAgLy8gICBpZiAocGVyaW9kU2Vjb25kcyA9PT0gMCkgcmV0dXJuIDAKICAgIC8vICAgcmV0dXJuIEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgLyBwZXJpb2RTZWNvbmRzCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogSW5pdGlhbGl6ZSB0aGUgY29udHJhY3Qgd2l0aCB0aGUgQVNBIHRva2VuIElEIGFuZCBvdGhlciBwYXJhbWV0ZXJzCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIGluaXRpYWxpemUoCiAgICAvLyAgIGFzc2V0OiBBc3NldCwKICAgIC8vICAgYWRtaW5BZGRyZXNzOiBBY2NvdW50LAogICAgLy8gICBhcHJCYXNpc1BvaW50czogdWludDY0LAogICAgLy8gICBkaXN0cmlidXRpb25QZXJpb2RTZWNvbmRzOiB1aW50NjQsCiAgICAvLyAgIG1pbmltdW1TdGFrZTogdWludDY0LAogICAgLy8gKTogdm9pZCB7CiAgICAvLyAgIC8vIEVuc3VyZSB0aGlzIGlzIG9ubHkgY2FsbGVkIGR1cmluZyBjb250cmFjdCBjcmVhdGlvbgogICAgLy8gICBhc3NlcnQodGhpcy5hc3NldC52YWx1ZSA9PT0gQXNzZXQoKSwgJ0FscmVhZHkgaW5pdGlhbGl6ZWQnKQogICAgLy8gCiAgICAvLyAgIC8vIEVuc3VyZSBvbmx5IHRoZSBjcmVhdG9yIGNhbiBpbml0aWFsaXplCiAgICAvLyAgIGFzc2VydChUeG4uc2VuZGVyID09PSBHbG9iYWwuY3JlYXRvckFkZHJlc3MsICdPbmx5IGNyZWF0b3IgY2FuIGluaXRpYWxpemUnKQogICAgLy8gCiAgICAvLyAgIC8vIFN0b3JlIHRoZSBpbml0aWFsIHBhcmFtZXRlcnMKICAgIC8vICAgdGhpcy5hc3NldC52YWx1ZSA9IGFzc2V0CiAgICAvLyAgIHRoaXMuYWRtaW5BZGRyZXNzLnZhbHVlID0gYWRtaW5BZGRyZXNzCiAgICAvLyAgIHRoaXMudG90YWxTdGFrZWQudmFsdWUgPSAwCiAgICAvLyAgIHRoaXMuYXByQmFzaXNQb2ludHMudmFsdWUgPSBhcHJCYXNpc1BvaW50cwogICAgLy8gICB0aGlzLmxhc3REaXN0cmlidXRpb25UaW1lLnZhbHVlID0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcAogICAgLy8gICB0aGlzLmRpc3RyaWJ1dGlvblBlcmlvZFJvdW5kcy52YWx1ZSA9IGRpc3RyaWJ1dGlvblBlcmlvZFNlY29uZHMKICAgIC8vICAgdGhpcy5taW5pbXVtU3Rha2UudmFsdWUgPSBtaW5pbXVtU3Rha2UKICAgIC8vICAgdGhpcy5yZXdhcmRQb29sLnZhbHVlID0gMAogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIE9wdCB0aGUgY29udHJhY3QgaW50byB0aGUgQVNBCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIG9wdEluVG9Bc3NldCgpOiB2b2lkIHsKICAgIC8vICAgLy8gRW5zdXJlIG9ubHkgdGhlIGNyZWF0b3Igb3IgYWRtaW4gY2FuIG9wdCBpbgogICAgLy8gICBjb25zdCBhZG1pbkFkZHIgPSB0aGlzLmFkbWluQWRkcmVzcy52YWx1ZQogICAgLy8gICBhc3NlcnQoVHhuLnNlbmRlciA9PT0gR2xvYmFsLmNyZWF0b3JBZGRyZXNzIHx8IFR4bi5zZW5kZXIgPT09IGFkbWluQWRkciwgJ09ubHkgY3JlYXRvciBvciBhZG1pbiBjYW4gb3B0IGluJykKICAgIC8vIAogICAgLy8gICAvLyBPcHQgdGhlIGNvbnRyYWN0IGludG8gdGhlIEFTQQogICAgLy8gICBjb25zdCBhc3NldCA9IHRoaXMuYXNzZXQudmFsdWUKICAgIC8vICAgaXR4bgogICAgLy8gICAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICAgIH0pCiAgICAvLyAgICAgLnN1Ym1pdCgpCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogU3Rha2UgdG9rZW5zCiAgICAvLyAgKiBSZXF1aXJlcyBhIGNvbXBhbmlvbiBBU0EgdHJhbnNmZXIgdHJhbnNhY3Rpb24KICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgc3Rha2UoKTogdm9pZCB7CiAgICAvLyAgIC8vIEVuc3VyZSB0aGUgY29udHJhY3QgaGFzIG9wdGVkIGludG8gdGhlIEFTQQogICAgLy8gICBjb25zdCBhc3NldCA9IHRoaXMuYXNzZXQudmFsdWUKICAgIC8vICAgYXNzZXJ0KHRoaXMuYXNzZXQudmFsdWUgIT09IEFzc2V0KCksICdDb250cmFjdCBub3QgaW5pdGlhbGl6ZWQnKQogICAgLy8gCiAgICAvLyAgIC8vIEVuc3VyZSB0aGlzIGNhbGwgaGFzIGEgY29tcGFuaW9uIEFTQSB0cmFuc2ZlciB0cmFuc2FjdGlvbgogICAgLy8gICBhc3NlcnQoR2xvYmFsLmdyb3VwU2l6ZSA9PT0gMiwgJ0V4cGVjdGVkIDIgdHhucyBpbiBncm91cCcpCiAgICAvLyAKICAgIC8vICAgLy8gR2V0IHRoZSBBU0EgdHJhbnNmZXIgZGV0YWlscwogICAgLy8gICBjb25zdCB4ZmVyVHhuID0gZ3R4bi5Bc3NldFRyYW5zZmVyVHhuKDApCiAgICAvLyAgIGFzc2VydCh4ZmVyVHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5Bc3NldFRyYW5zZmVyLCAnVHJhbnNhY3Rpb24gMCBtdXN0IGJlIGFzc2V0IHRyYW5zZmVyJykKICAgIC8vICAgYXNzZXJ0KHhmZXJUeG4uYXNzZXRSZWNlaXZlciA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsICdBc3NldCB0cmFuc2ZlciBtdXN0IGJlIHRvIGNvbnRyYWN0JykKICAgIC8vICAgYXNzZXJ0KHhmZXJUeG4uYXNzZXRBbW91bnQgPiAwLCAnTXVzdCBzdGFrZSBub24temVybyBhbW91bnQnKQogICAgLy8gICBhc3NlcnQoeGZlclR4bi54ZmVyQXNzZXQgPT09IGFzc2V0LCAnSW5jb3JyZWN0IGFzc2V0IElEJykKICAgIC8vIAogICAgLy8gICAvLyBHZXQgdGhlIHN0YWtlIGFtb3VudCBmcm9tIHRoZSB0cmFuc2FjdGlvbgogICAgLy8gICBjb25zdCBzdGFrZUFtb3VudCA9IHhmZXJUeG4uYXNzZXRBbW91bnQKICAgIC8vICAgY29uc3QgbWluaW11bVN0YWtlID0gdGhpcy5taW5pbXVtU3Rha2UudmFsdWUKICAgIC8vIAogICAgLy8gICAvLyBHZXQgdGhlIGN1cnJlbnQgdXNlciBzdGFrZSBpbmZvCiAgICAvLyAgIGNvbnN0IHNlbmRlckFkZHJlc3MgPSBUeG4uc2VuZGVyCiAgICAvLyAgIGNvbnN0IHN0YWtlSW5mbyA9IHRoaXMuZ2V0VXNlclN0YWtlSW5mbyhzZW5kZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIC8vIElmIHRoaXMgaXMgYSBuZXcgc3Rha2UsIGVuc3VyZSBpdCBtZWV0cyBtaW5pbXVtCiAgICAvLyAgIGlmIChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSA9PT0gMCkgewogICAgLy8gICAgIGFzc2VydChzdGFrZUFtb3VudCA+PSBtaW5pbXVtU3Rha2UsICdJbml0aWFsIHN0YWtlIGJlbG93IG1pbmltdW0nKQogICAgLy8gICAgIC8vIFNldCB0aGUgaW5pdGlhbCBjbGFpbSBwZXJpb2QgdG8gY3VycmVudCBwZXJpb2QKICAgIC8vICAgICBzdGFrZUluZm8ubGFzdENsYWltZWRQZXJpb2QgPSBuZXcgYXJjNC5VaW50TjY0KHRoaXMuZ2V0Q3VycmVudFBlcmlvZCgpKQogICAgLy8gICAgIC8vIFNldCB0aGUgZmlyc3Qgc3Rha2UgdGltZSAodGhpcyBuZXZlciBjaGFuZ2VzIGFmdGVyIGluaXRpYWwgc3Rha2UpCiAgICAvLyAgICAgc3Rha2VJbmZvLmZpcnN0U3Rha2VUaW1lID0gbmV3IGFyYzQuVWludE42NChHbG9iYWwubGF0ZXN0VGltZXN0YW1wKQogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIHN0YWtlIGluZm8KICAgIC8vICAgc3Rha2VJbmZvLnN0YWtlZEFtb3VudCA9IG5ldyBhcmM0LlVpbnRONjQoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgKyBzdGFrZUFtb3VudCkKICAgIC8vICAgc3Rha2VJbmZvLmxhc3RTdGFrZVRpbWUgPSBuZXcgYXJjNC5VaW50TjY0KEdsb2JhbC5sYXRlc3RUaW1lc3RhbXApCiAgICAvLyAKICAgIC8vICAgLy8gU3RvcmUgdXBkYXRlZCBzdGFrZSBpbmZvCiAgICAvLyAgIHRoaXMuc3RvcmVVc2VyU3Rha2VJbmZvKHNlbmRlckFkZHJlc3MsIHN0YWtlSW5mbykKICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgZ2xvYmFsIHN0YXRlCiAgICAvLyAgIHRoaXMudG90YWxTdGFrZWQudmFsdWUgPSB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlICsgc3Rha2VBbW91bnQKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBXaXRoZHJhdyBzdGFrZWQgdG9rZW5zCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gcHVibGljIHdpdGhkcmF3KGFtb3VudDogdWludDY0KTogdm9pZCB7CiAgICAvLyAgIGNvbnN0IHNlbmRlckFkZHJlc3MgPSBUeG4uc2VuZGVyCiAgICAvLyAgIGNvbnN0IHN0YWtlSW5mbyA9IHRoaXMuZ2V0VXNlclN0YWtlSW5mbyhzZW5kZXJBZGRyZXNzKQogICAgLy8gCiAgICAvLyAgIC8vIEVuc3VyZSB1c2VyIGhhcyBlbm91Z2ggc3Rha2VkCiAgICAvLyAgIGFzc2VydChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSA+IDAsICdObyBzdGFrZSBmb3VuZCcpCiAgICAvLyAgIGFzc2VydChhbW91bnQgPD0gc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUsICdXaXRoZHJhd2FsIGFtb3VudCBleGNlZWRzIHN0YWtlJykKICAgIC8vICAgYXNzZXJ0KGFtb3VudCA+IDAsICdXaXRoZHJhd2FsIGFtb3VudCBtdXN0IGJlIHBvc2l0aXZlJykKICAgIC8vIAogICAgLy8gICAvLyBJZiB3aXRoZHJhd2luZyBhbGwsIG5vIG5lZWQgdG8gY2hlY2sgbWluaW11bSByZW1haW5pbmcKICAgIC8vICAgLy8gSWYgcGFydGlhbCB3aXRoZHJhd2FsLCBlbnN1cmUgcmVtYWluaW5nIHN0YWtlIG1lZXRzIG1pbmltdW0KICAgIC8vICAgaWYgKGFtb3VudCA8IHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlKSB7CiAgICAvLyAgICAgY29uc3QgcmVtYWluaW5nU3Rha2U6IHVpbnQ2NCA9IHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlIC0gYW1vdW50CiAgICAvLyAgICAgY29uc3QgbWluaW11bVN0YWtlID0gdGhpcy5taW5pbXVtU3Rha2UudmFsdWUKICAgIC8vICAgICBhc3NlcnQocmVtYWluaW5nU3Rha2UgPj0gbWluaW11bVN0YWtlLCAnUmVtYWluaW5nIHN0YWtlIHdvdWxkIGJlIGJlbG93IG1pbmltdW0nKQogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIHN0YWtlIGluZm8KICAgIC8vICAgc3Rha2VJbmZvLnN0YWtlZEFtb3VudCA9IG5ldyBhcmM0LlVpbnRONjQoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgLSBhbW91bnQpCiAgICAvLyAKICAgIC8vICAgLy8gU3RvcmUgdXBkYXRlZCBzdGFrZSBpbmZvCiAgICAvLyAgIHRoaXMuc3RvcmVVc2VyU3Rha2VJbmZvKHNlbmRlckFkZHJlc3MsIHN0YWtlSW5mbykKICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgZ2xvYmFsIHN0YXRlCiAgICAvLyAgIHRoaXMudG90YWxTdGFrZWQudmFsdWUgPSB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlIC0gYW1vdW50CiAgICAvLyAKICAgIC8vICAgLy8gVHJhbnNmZXIgdG9rZW5zIGJhY2sgdG8gdXNlcgogICAgLy8gICBjb25zdCBhc3NldCA9IHRoaXMuYXNzZXQudmFsdWUKICAgIC8vICAgaXR4bgogICAgLy8gICAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IFR4bi5zZW5kZXIsCiAgICAvLyAgICAgICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gICAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgICAgIGZlZTogMTAwMCwKICAgIC8vICAgICB9KQogICAgLy8gICAgIC5zdWJtaXQoKQogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIEFkZCByZXdhcmRzIHRvIHRoZSByZXdhcmQgcG9vbAogICAgLy8gICogT25seSB0aGUgYWRtaW4gY2FuIGNhbGwgdGhpcwogICAgLy8gICogUmVxdWlyZXMgYSBjb21wYW5pb24gQVNBIHRyYW5zZmVyIHRyYW5zYWN0aW9uIHdpdGggdGhlIHJld2FyZHMKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgYWRkUmV3YXJkcygpOiB2b2lkIHsKICAgIC8vICAgLy8gRW5zdXJlIG9ubHkgYWRtaW4gY2FuIGFkZCByZXdhcmRzCiAgICAvLyAgIGNvbnN0IGFkbWluQWRkciA9IHRoaXMuYWRtaW5BZGRyZXNzLnZhbHVlCiAgICAvLyAgIGFzc2VydChUeG4uc2VuZGVyID09PSBhZG1pbkFkZHIsICdPbmx5IGFkbWluIGNhbiBhZGQgcmV3YXJkcycpCiAgICAvLyAKICAgIC8vICAgLy8gRW5zdXJlIHRoaXMgY2FsbCBoYXMgYSBjb21wYW5pb24gQVNBIHRyYW5zZmVyIHRyYW5zYWN0aW9uIHdpdGggcmV3YXJkcwogICAgLy8gICBhc3NlcnQoR2xvYmFsLmdyb3VwU2l6ZSA9PT0gMiwgJ0V4cGVjdGVkIDIgdHhucyBpbiBncm91cCcpCiAgICAvLyAKICAgIC8vICAgLy8gR2V0IHRoZSBBU0EgdHJhbnNmZXIgZGV0YWlscwogICAgLy8gICBjb25zdCBhc3NldCA9IHRoaXMuYXNzZXQudmFsdWUKICAgIC8vICAgY29uc3QgeGZlclR4biA9IGd0eG4uQXNzZXRUcmFuc2ZlclR4bigwKQogICAgLy8gICBhc3NlcnQoeGZlclR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXNzZXRUcmFuc2ZlciwgJ1RyYW5zYWN0aW9uIDAgbXVzdCBiZSBhc3NldCB0cmFuc2ZlcicpCiAgICAvLyAgIGFzc2VydCh4ZmVyVHhuLmFzc2V0UmVjZWl2ZXIgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLCAnQXNzZXQgdHJhbnNmZXIgbXVzdCBiZSB0byBjb250cmFjdCcpCiAgICAvLyAgIGFzc2VydCh4ZmVyVHhuLmFzc2V0QW1vdW50ID4gMCwgJ011c3QgcHJvdmlkZSBub24temVybyByZXdhcmRzJykKICAgIC8vICAgYXNzZXJ0KHhmZXJUeG4ueGZlckFzc2V0ID09PSBhc3NldCwgJ0luY29ycmVjdCBhc3NldCBJRCcpCiAgICAvLyAKICAgIC8vICAgLy8gQWRkIHJld2FyZHMgdG8gdGhlIHBvb2wKICAgIC8vICAgdGhpcy5yZXdhcmRQb29sLnZhbHVlID0gdGhpcy5yZXdhcmRQb29sLnZhbHVlICsgeGZlclR4bi5hc3NldEFtb3VudAogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIENhbGN1bGF0ZSByZXdhcmRzIGZvciBhIHNwZWNpZmljIHVzZXIgZm9yIGEgZ2l2ZW4gcGVyaW9kCiAgICAvLyAgKiBUaGlzIGNhbGN1bGF0ZXMgcmV3YXJkcyBwZXIgZGlzdHJpYnV0aW9uIHBlcmlvZAogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIC8vIHB1YmxpYyBjYWxjdWxhdGVVc2VyUmV3YXJkc0ZvclBlcmlvZCh1c2VyQWRkcmVzczogQWNjb3VudCk6IHVpbnQ2NCB7CiAgICAvLyAgIGNvbnN0IGFwciA9IHRoaXMuYXByQmFzaXNQb2ludHMudmFsdWUKICAgIC8vICAgY29uc3QgdG90YWxTdGFrZWQgPSB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlCiAgICAvLyAgIGNvbnN0IHBlcmlvZFNlY29uZHMgPSB0aGlzLmRpc3RyaWJ1dGlvblBlcmlvZFJvdW5kcy52YWx1ZQogICAgLy8gCiAgICAvLyAgIC8vIElmIG5vIHRvdGFsIHN0YWtlIG9yIG5vIHBlcmlvZCBkZWZpbmVkLCByZXR1cm4gMAogICAgLy8gICBpZiAodG90YWxTdGFrZWQgPT09IDAgfHwgcGVyaW9kU2Vjb25kcyA9PT0gMCkgewogICAgLy8gICAgIHJldHVybiAwCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBHZXQgdGhlIHVzZXIncyBzdGFrZSBpbmZvCiAgICAvLyAgIGNvbnN0IHN0YWtlSW5mbyA9IHRoaXMuZ2V0VXNlclN0YWtlSW5mbyh1c2VyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICAvLyBJZiB1c2VyIGhhcyBubyBzdGFrZSwgcmV0dXJuIDAKICAgIC8vICAgaWYgKHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlID09PSAwKSB7CiAgICAvLyAgICAgcmV0dXJuIDAKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIEdldCB1c2VyJ3Mgc3Rha2UgYW1vdW50IGFuZCBmaXJzdCBzdGFrZSB0aW1lCiAgICAvLyAgIGNvbnN0IHVzZXJTdGFrZSA9IHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlCiAgICAvLyAgIGNvbnN0IGZpcnN0U3Rha2VUaW1lID0gc3Rha2VJbmZvLmZpcnN0U3Rha2VUaW1lLm5hdGl2ZQogICAgLy8gCiAgICAvLyAgIC8vIENoZWNrIGlmIHVzZXIgaGFzIGJlZW4gc3Rha2VkIGZvciB0aGUgbWluaW11bSBwZXJpb2QgKHVzaW5nIGZpcnN0IHN0YWtlIHRpbWUpCiAgICAvLyAgIGNvbnN0IG1pbmltdW1TdGFrZVRpbWU6IHVpbnQ2NCA9IFJPVU5EU19QRVJfREFZCiAgICAvLyAgIGlmIChHbG9iYWwubGF0ZXN0VGltZXN0YW1wIDwgZmlyc3RTdGFrZVRpbWUgKyBtaW5pbXVtU3Rha2VUaW1lKSB7CiAgICAvLyAgICAgcmV0dXJuIDAKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIENhbGN1bGF0ZSByZXdhcmQgcmF0ZSBmb3IgdGhlIHBlcmlvZAogICAgLy8gICAvLyBBUFIgaXMgaW4gYmFzaXMgcG9pbnRzIChlLmcuLCA1MDAgPSA1JSkKICAgIC8vICAgLy8gQ29udmVydCBBUFIgdG8gcGVyaW9kIHJhdGU6IChBUFIgLyAxMDAwMCkgKiAocGVyaW9kU2Vjb25kcyAvIDMxNTM2MDAwKQogICAgLy8gICAvLyB3aGVyZSAzMTUzNjAwMCBpcyBzZWNvbmRzIGluIGEgeWVhcgogICAgLy8gICBjb25zdCB5ZWFySW5TZWNvbmRzOiB1aW50NjQgPSBST1VORFNfUEVSX1lFQVIKICAgIC8vICAgY29uc3QgcGVyaW9kUmF0ZU51bWVyYXRvcjogdWludDY0ID0gYXByICogcGVyaW9kU2Vjb25kcwogICAgLy8gICBjb25zdCBwZXJpb2RSYXRlRGVub21pbmF0b3I6IHVpbnQ2NCA9IDEwMDAwICogeWVhckluU2Vjb25kcwogICAgLy8gCiAgICAvLyAgIC8vIENhbGN1bGF0ZSByZXdhcmQ6IHVzZXJTdGFrZSAqIHBlcmlvZFJhdGUKICAgIC8vICAgY29uc3QgcmV3YXJkOiB1aW50NjQgPSAodXNlclN0YWtlICogcGVyaW9kUmF0ZU51bWVyYXRvcikgLyBwZXJpb2RSYXRlRGVub21pbmF0b3IKICAgIC8vIAogICAgLy8gICByZXR1cm4gcmV3YXJkCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogQ2FsY3VsYXRlIHBlbmRpbmcgcmV3YXJkcyBmb3IgYSB1c2VyIHNpbmNlIHRoZWlyIGxhc3QgY2xhaW0KICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICAvLyBwdWJsaWMgY2FsY3VsYXRlUGVuZGluZ1Jld2FyZHModXNlckFkZHJlc3M6IEFjY291bnQpOiB1aW50NjQgewogICAgLy8gICBjb25zdCBzdGFrZUluZm8gPSB0aGlzLmdldFVzZXJTdGFrZUluZm8odXNlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgaWYgKHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlID09PSAwKSB7CiAgICAvLyAgICAgcmV0dXJuIDAKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIGNvbnN0IGN1cnJlbnRQZXJpb2QgPSB0aGlzLmdldEN1cnJlbnRQZXJpb2QoKQogICAgLy8gICBjb25zdCBsYXN0Q2xhaW1lZFBlcmlvZCA9IHN0YWtlSW5mby5sYXN0Q2xhaW1lZFBlcmlvZC5uYXRpdmUKICAgIC8vIAogICAgLy8gICAvLyBDYWxjdWxhdGUgcGVyaW9kcyBzaW5jZSBsYXN0IGNsYWltCiAgICAvLyAgIGNvbnN0IHBlcmlvZHNTaW5jZUxhc3RDbGFpbTogdWludDY0ID0gY3VycmVudFBlcmlvZCA+IGxhc3RDbGFpbWVkUGVyaW9kID8gY3VycmVudFBlcmlvZCAtIGxhc3RDbGFpbWVkUGVyaW9kIDogMAogICAgLy8gCiAgICAvLyAgIGlmIChwZXJpb2RzU2luY2VMYXN0Q2xhaW0gPT09IDApIHsKICAgIC8vICAgICByZXR1cm4gMAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gQ2FsY3VsYXRlIHJld2FyZCBwZXIgcGVyaW9kCiAgICAvLyAgIGNvbnN0IHJld2FyZFBlclBlcmlvZCA9IHRoaXMuY2FsY3VsYXRlVXNlclJld2FyZHNGb3JQZXJpb2QodXNlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgcmV0dXJuIHJld2FyZFBlclBlcmlvZCAqIHBlcmlvZHNTaW5jZUxhc3RDbGFpbQogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIEhlbHBlciBmdW5jdGlvbiB0byBjb21wb3VuZCByZXdhcmRzIGZvciBhIHNpbmdsZSB1c2VyCiAgICAvLyAgKiBVc2VkIGJ5IHRoZSBhdXRvbWF0ZWQgZGlzdHJpYnV0aW9uIHN5c3RlbQogICAgLy8gICovCiAgICAvLyBwcml2YXRlIGNvbXBvdW5kUmV3YXJkc0ZvclVzZXIodXNlckFkZHJlc3M6IEFjY291bnQpOiB1aW50NjQgewogICAgLy8gICBjb25zdCBzdGFrZUluZm8gPSB0aGlzLmdldFVzZXJTdGFrZUluZm8odXNlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgLy8gU2tpcCBpZiB1c2VyIGhhcyBubyBzdGFrZQogICAgLy8gICBpZiAoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgPT09IDApIHsKICAgIC8vICAgICByZXR1cm4gMAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gQ2FsY3VsYXRlIHBlbmRpbmcgcmV3YXJkcwogICAgLy8gICBjb25zdCBwZW5kaW5nUmV3YXJkcyA9IHRoaXMuY2FsY3VsYXRlUGVuZGluZ1Jld2FyZHModXNlckFkZHJlc3MpCiAgICAvLyAKICAgIC8vICAgLy8gU2tpcCBpZiBubyByZXdhcmRzIHRvIGNvbXBvdW5kCiAgICAvLyAgIGlmIChwZW5kaW5nUmV3YXJkcyA9PT0gMCkgewogICAgLy8gICAgIHJldHVybiAwCiAgICAvLyAgIH0KICAgIC8vIAogICAgLy8gICAvLyBTa2lwIGlmIHJld2FyZCBwb29sIGhhcyBpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIHRoaXMgdXNlcgogICAgLy8gICBpZiAodGhpcy5yZXdhcmRQb29sLnZhbHVlIDwgcGVuZGluZ1Jld2FyZHMpIHsKICAgIC8vICAgICByZXR1cm4gMAogICAgLy8gICB9CiAgICAvLyAKICAgIC8vICAgLy8gQXV0by1jb21wb3VuZDogQWRkIHJld2FyZHMgdG8gc3Rha2VkIGFtb3VudAogICAgLy8gICBzdGFrZUluZm8uc3Rha2VkQW1vdW50ID0gbmV3IGFyYzQuVWludE42NChzdGFrZUluZm8uc3Rha2VkQW1vdW50Lm5hdGl2ZSArIHBlbmRpbmdSZXdhcmRzKQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSB0b3RhbCByZXdhcmRzIGVhcm5lZAogICAgLy8gICBzdGFrZUluZm8udG90YWxSZXdhcmRzRWFybmVkID0gbmV3IGFyYzQuVWludE42NChzdGFrZUluZm8udG90YWxSZXdhcmRzRWFybmVkLm5hdGl2ZSArIHBlbmRpbmdSZXdhcmRzKQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBsYXN0IGNsYWltZWQgcGVyaW9kIHRvIGN1cnJlbnQgcGVyaW9kCiAgICAvLyAgIHN0YWtlSW5mby5sYXN0Q2xhaW1lZFBlcmlvZCA9IG5ldyBhcmM0LlVpbnRONjQodGhpcy5nZXRDdXJyZW50UGVyaW9kKCkpCiAgICAvLyAKICAgIC8vICAgLy8gU3RvcmUgdXBkYXRlZCBzdGFrZSBpbmZvCiAgICAvLyAgIHRoaXMuc3RvcmVVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzLCBzdGFrZUluZm8pCiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIGdsb2JhbCBzdGF0ZQogICAgLy8gICB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlID0gdGhpcy50b3RhbFN0YWtlZC52YWx1ZSArIHBlbmRpbmdSZXdhcmRzCiAgICAvLyAgIHRoaXMucmV3YXJkUG9vbC52YWx1ZSA9IHRoaXMucmV3YXJkUG9vbC52YWx1ZSAtIHBlbmRpbmdSZXdhcmRzCiAgICAvLyAKICAgIC8vICAgcmV0dXJuIHBlbmRpbmdSZXdhcmRzCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogRGlzdHJpYnV0ZSBhbmQgY29tcG91bmQgcmV3YXJkcyBmb3IgbXVsdGlwbGUgc3Rha2VycwogICAgLy8gICogVGhpcyBtZXRob2QgaXMgZGVzaWduZWQgdG8gYmUgY2FsbGVkIGJ5IGEgY3JvbiBqb2Igb24gYSBkYWlseSBiYXNpcwogICAgLy8gICogT25seSBhZG1pbiBjYW4gY2FsbCB0aGlzIG1ldGhvZAogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyBkaXN0cmlidXRlUmV3YXJkcyhzdGFrZXJBZGRyZXNzZXM6IGFyYzQuQWRkcmVzc1tdKTogdm9pZCB7CiAgICAvLyAgIC8vIEVuc3VyZSBvbmx5IGFkbWluIGNhbiBkaXN0cmlidXRlIHJld2FyZHMKICAgIC8vICAgY29uc3QgYWRtaW5BZGRyID0gdGhpcy5hZG1pbkFkZHJlc3MudmFsdWUKICAgIC8vICAgYXNzZXJ0KFR4bi5zZW5kZXIgPT09IGFkbWluQWRkciwgJ09ubHkgYWRtaW4gY2FuIGRpc3RyaWJ1dGUgcmV3YXJkcycpCiAgICAvLyAKICAgIC8vICAgLy8gRW5zdXJlIHdlIGRvbid0IHByb2Nlc3MgdG9vIG1hbnkgc3Rha2VycyBpbiBvbmUgY2FsbCAoZ2FzIGxpbWl0IHByb3RlY3Rpb24pCiAgICAvLyAgIGFzc2VydChzdGFrZXJBZGRyZXNzZXMubGVuZ3RoIDw9IDUwLCAnVG9vIG1hbnkgc3Rha2VycyBpbiBzaW5nbGUgYmF0Y2gnKQogICAgLy8gCiAgICAvLyAgIGxldCB0b3RhbERpc3RyaWJ1dGVkOiB1aW50NjQgPSAwCiAgICAvLyAKICAgIC8vICAgLy8gUHJvY2VzcyBlYWNoIHN0YWtlcgogICAgLy8gICBmb3IgKGNvbnN0IHN0YWtlciBvZiBzdGFrZXJBZGRyZXNzZXMpIHsKICAgIC8vICAgICBjb25zdCByZXdhcmRzQ29tcG91bmRlZCA9IHRoaXMuY29tcG91bmRSZXdhcmRzRm9yVXNlcihzdGFrZXIubmF0aXZlKQogICAgLy8gICAgIHRvdGFsRGlzdHJpYnV0ZWQgPSB0b3RhbERpc3RyaWJ1dGVkICsgcmV3YXJkc0NvbXBvdW5kZWQKICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIC8vIFVwZGF0ZSBsYXN0IGRpc3RyaWJ1dGlvbiB0aW1lCiAgICAvLyAgIHRoaXMubGFzdERpc3RyaWJ1dGlvblRpbWUudmFsdWUgPSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wCiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogR2V0IGFsbCBub24temVybyBzdGFrZXJzIGNvdW50IChmb3IgbW9uaXRvcmluZyBwdXJwb3NlcykKICAgIC8vICAqIE5vdGU6IFRoaXMgZG9lc24ndCByZXR1cm4gdGhlIGFjdHVhbCBhZGRyZXNzZXMgZHVlIHRvIGJveCBpdGVyYXRpb24gbGltaXRhdGlvbnMKICAgIC8vICAqLwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICAvLyBwdWJsaWMgZ2V0QWN0aXZlU3Rha2Vyc0NvdW50KHN0YWtlckFkZHJlc3NlczogYXJjNC5BZGRyZXNzW10pOiB1aW50NjQgewogICAgLy8gICBsZXQgYWN0aXZlQ291bnQ6IHVpbnQ2NCA9IDAKICAgIC8vIAogICAgLy8gICBmb3IgKGNvbnN0IHN0YWtlciBvZiBzdGFrZXJBZGRyZXNzZXMpIHsKICAgIC8vICAgICBjb25zdCBzdGFrZUluZm8gPSB0aGlzLmdldFVzZXJTdGFrZUluZm8oc3Rha2VyLm5hdGl2ZSkKICAgIC8vICAgICBpZiAoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgPiAwKSB7CiAgICAvLyAgICAgICBhY3RpdmVDb3VudCA9IGFjdGl2ZUNvdW50ICsgMQogICAgLy8gICAgIH0KICAgIC8vICAgfQogICAgLy8gCiAgICAvLyAgIHJldHVybiBhY3RpdmVDb3VudAogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIFVwZGF0ZSB0aGUgQVBSIGJhc2lzIHBvaW50cwogICAgLy8gICogT25seSB0aGUgYWRtaW4gY2FuIGNhbGwgdGhpcwogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyB1cGRhdGVBUFIobmV3QXByQmFzaXNQb2ludHM6IHVpbnQ2NCk6IHZvaWQgewogICAgLy8gICAvLyBFbnN1cmUgb25seSBhZG1pbiBjYW4gdXBkYXRlIEFQUgogICAgLy8gICBjb25zdCBhZG1pbkFkZHIgPSB0aGlzLmFkbWluQWRkcmVzcy52YWx1ZQogICAgLy8gICBhc3NlcnQoVHhuLnNlbmRlciA9PT0gYWRtaW5BZGRyLCAnT25seSBhZG1pbiBjYW4gdXBkYXRlIEFQUicpCiAgICAvLyAKICAgIC8vICAgLy8gVXBkYXRlIEFQUgogICAgLy8gICB0aGlzLmFwckJhc2lzUG9pbnRzLnZhbHVlID0gbmV3QXByQmFzaXNQb2ludHMKICAgIC8vIH0KICAgIC8vIAogICAgLy8gLyoqCiAgICAvLyAgKiBVcGRhdGUgdGhlIGFkbWluIGFkZHJlc3MKICAgIC8vICAqIE9ubHkgdGhlIGN1cnJlbnQgYWRtaW4gY2FuIGNhbGwgdGhpcwogICAgLy8gICovCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIHB1YmxpYyB1cGRhdGVBZG1pbihuZXdBZG1pbkFkZHJlc3M6IEFjY291bnQpOiB2b2lkIHsKICAgIC8vICAgLy8gRW5zdXJlIG9ubHkgYWRtaW4gY2FuIHVwZGF0ZSBhZG1pbgogICAgLy8gICBjb25zdCBhZG1pbkFkZHIgPSB0aGlzLmFkbWluQWRkcmVzcy52YWx1ZQogICAgLy8gICBhc3NlcnQoVHhuLnNlbmRlciA9PT0gYWRtaW5BZGRyLCAnT25seSBhZG1pbiBjYW4gdXBkYXRlIGFkbWluJykKICAgIC8vIAogICAgLy8gICAvLyBVcGRhdGUgYWRtaW4gYWRkcmVzcwogICAgLy8gICB0aGlzLmFkbWluQWRkcmVzcy52YWx1ZSA9IG5ld0FkbWluQWRkcmVzcwogICAgLy8gfQogICAgLy8gCiAgICAvLyAvKioKICAgIC8vICAqIEdldCBjdXJyZW50IHN0YWtpbmcgc3RhdGlzdGljcyBmb3IgYSB1c2VyCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgLy8gcHVibGljIGdldFVzZXJTdGF0cyh1c2VyQWRkcmVzczogQWNjb3VudCk6IEFycmF5PHVpbnQ2ND4gewogICAgLy8gICBjb25zdCBzdGFrZUluZm8gPSB0aGlzLmdldFVzZXJTdGFrZUluZm8odXNlckFkZHJlc3MpCiAgICAvLyAgIGNvbnN0IHBlbmRpbmdSZXdhcmRzID0gdGhpcy5jYWxjdWxhdGVQZW5kaW5nUmV3YXJkcyh1c2VyQWRkcmVzcykKICAgIC8vIAogICAgLy8gICBjb25zdCByZXN1bHQ6IHVpbnQ2NFtdID0gWwogICAgLy8gICAgIHN0YWtlSW5mby5zdGFrZWRBbW91bnQubmF0aXZlLAogICAgLy8gICAgIHN0YWtlSW5mby5maXJzdFN0YWtlVGltZS5uYXRpdmUsCiAgICAvLyAgICAgc3Rha2VJbmZvLmxhc3RTdGFrZVRpbWUubmF0aXZlLAogICAgLy8gICAgIHN0YWtlSW5mby50b3RhbFJld2FyZHNFYXJuZWQubmF0aXZlLAogICAgLy8gICAgIHBlbmRpbmdSZXdhcmRzLAogICAgLy8gICAgIHN0YWtlSW5mby5sYXN0Q2xhaW1lZFBlcmlvZC5uYXRpdmUsCiAgICAvLyAgIF0KICAgIC8vIAogICAgLy8gICByZXR1cm4gcmVzdWx0CiAgICAvLyB9CiAgICAvLyAKICAgIC8vIC8qKgogICAgLy8gICogR2V0IGNvbnRyYWN0IGdsb2JhbCBzdGF0aXN0aWNzCiAgICAvLyAgKi8KICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgLy8gcHVibGljIGdldENvbnRyYWN0U3RhdHMoKTogQXJyYXk8dWludDY0PiB7CiAgICAvLyAgIGNvbnN0IHJlc3VsdDogdWludDY0W10gPSBbCiAgICAvLyAgICAgdGhpcy5hc3NldC52YWx1ZS5pZCwKICAgIC8vICAgICB0aGlzLnRvdGFsU3Rha2VkLnZhbHVlLAogICAgLy8gICAgIHRoaXMuYXByQmFzaXNQb2ludHMudmFsdWUsCiAgICAvLyAgICAgdGhpcy5sYXN0RGlzdHJpYnV0aW9uVGltZS52YWx1ZSwKICAgIC8vICAgICB0aGlzLmRpc3RyaWJ1dGlvblBlcmlvZFJvdW5kcy52YWx1ZSwKICAgIC8vICAgICB0aGlzLm1pbmltdW1TdGFrZS52YWx1ZSwKICAgIC8vICAgICB0aGlzLnJld2FyZFBvb2wudmFsdWUsCiAgICAvLyAgICAgdGhpcy5nZXRDdXJyZW50UGVyaW9kKCksCiAgICBjb25jYXQKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDggLy8gOAogICAgLwogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0OTAKICAgIC8vIHJldHVybiByZXN1bHQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OkFTQVN0YWtpbmdDb250cmFjdC5lbWVyZ2VuY3lXaXRoZHJhd1Jld2FyZHMoYW1vdW50OiB1aW50NjQpIC0+IHZvaWQ6CmVtZXJnZW5jeVdpdGhkcmF3UmV3YXJkczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDk2LTQ5NwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgZW1lcmdlbmN5V2l0aGRyYXdSZXdhcmRzKGFtb3VudDogdWludDY0KTogdm9pZCB7CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTUKICAgIC8vIHB1YmxpYyBhZG1pbkFkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGluaXRpYWxWYWx1ZTogQWNjb3VudCgpfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJhZG1pbkFkZHJlc3MiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1MDAKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSBhZG1pbkFkZHIsICdPbmx5IGFkbWluIGNhbiBlbWVyZ2VuY3kgd2l0aGRyYXcnKQogICAgdHhuIFNlbmRlcgogICAgZGlnIDEKICAgID09CiAgICBhc3NlcnQgLy8gT25seSBhZG1pbiBjYW4gZW1lcmdlbmN5IHdpdGhkcmF3CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYxCiAgICAvLyBwdWJsaWMgcmV3YXJkUG9vbCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJyZXdhcmRQb29sIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTAzCiAgICAvLyBhc3NlcnQodGhpcy5yZXdhcmRQb29sLnZhbHVlID49IGFtb3VudCwgJ0luc3VmZmljaWVudCByZXdhcmQgcG9vbCcpCiAgICBmcmFtZV9kaWcgLTEKICAgID49CiAgICBhc3NlcnQgLy8gSW5zdWZmaWNpZW50IHJld2FyZCBwb29sCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYxCiAgICAvLyBwdWJsaWMgcmV3YXJkUG9vbCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAgfSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJyZXdhcmRQb29sIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTA2CiAgICAvLyB0aGlzLnJld2FyZFBvb2wudmFsdWUgPSB0aGlzLnJld2FyZFBvb2wudmFsdWUgLSBhbW91bnQKICAgIGZyYW1lX2RpZyAtMQogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo2MQogICAgLy8gcHVibGljIHJld2FyZFBvb2wgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsgaW5pdGlhbFZhbHVlOiAwIH0pCiAgICBieXRlY18wIC8vICJyZXdhcmRQb29sIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1MDYKICAgIC8vIHRoaXMucmV3YXJkUG9vbC52YWx1ZSA9IHRoaXMucmV3YXJkUG9vbC52YWx1ZSAtIGFtb3VudAogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTQKICAgIC8vIHB1YmxpYyBhc3NldCA9IEdsb2JhbFN0YXRlPEFzc2V0Pih7IGluaXRpYWxWYWx1ZTogQXNzZXQoKSB9KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImFzc2V0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTEwLTUxNwogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogYWRtaW5BZGRyLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgICBmZWU6IDEwMDAsCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjUxMC01MTYKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IGFkbWluQWRkciwKICAgIC8vICAgICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgICAgZmVlOiAxMDAwLAogICAgLy8gICB9KQogICAgaW50Y18yIC8vIDQKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTE1CiAgICAvLyBmZWU6IDEwMDAsCiAgICBwdXNoaW50IDEwMDAgLy8gMTAwMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTEwLTUxNwogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogYWRtaW5BZGRyLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgICBmZWU6IDEwMDAsCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OkFTQVN0YWtpbmdDb250cmFjdC5kZWxldGVVc2VyQm94KHVzZXJBZGRyZXNzOiBieXRlcykgLT4gdm9pZDoKZGVsZXRlVXNlckJveDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTI0LTUyNQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBwdWJsaWMgZGVsZXRlVXNlckJveCh1c2VyQWRkcmVzczogQWNjb3VudCk6IHZvaWQgewogICAgcHJvdG8gMSAwCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1NQogICAgLy8gcHVibGljIGFkbWluQWRkcmVzcyA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsgaW5pdGlhbFZhbHVlOiBBY2NvdW50KCl9KQogICAgZHVwCiAgICBieXRlY18yIC8vICJhZG1pbkFkZHJlc3MiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1MzAKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSBib3hPd25lciB8fCBUeG4uc2VuZGVyID09PSBhZG1pbkFkZHIsICdPbmx5IGJveCBvd25lciBvciBhZG1pbiBjYW4gZGVsZXRlIGJveCcpCiAgICB0eG4gU2VuZGVyCiAgICBmcmFtZV9kaWcgLTEKICAgID09CiAgICBibnogZGVsZXRlVXNlckJveF9ib29sX3RydWVAMgogICAgdHhuIFNlbmRlcgogICAgZnJhbWVfZGlnIDEKICAgID09CiAgICBieiBkZWxldGVVc2VyQm94X2Jvb2xfZmFsc2VAMwoKZGVsZXRlVXNlckJveF9ib29sX3RydWVAMjoKICAgIGludGNfMSAvLyAxCgpkZWxldGVVc2VyQm94X2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTMwCiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gYm94T3duZXIgfHwgVHhuLnNlbmRlciA9PT0gYWRtaW5BZGRyLCAnT25seSBib3ggb3duZXIgb3IgYWRtaW4gY2FuIGRlbGV0ZSBib3gnKQogICAgYXNzZXJ0IC8vIE9ubHkgYm94IG93bmVyIG9yIGFkbWluIGNhbiBkZWxldGUgYm94CiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjUzMwogICAgLy8gY29uc3Qgc3Rha2VJbmZvID0gdGhpcy5nZXRVc2VyU3Rha2VJbmZvKHVzZXJBZGRyZXNzKQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIGdldFVzZXJTdGFrZUluZm8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTM0CiAgICAvLyBhc3NlcnQoc3Rha2VJbmZvLnN0YWtlZEFtb3VudC5uYXRpdmUgPT09IDAsICdVc2VyIHN0aWxsIGhhcyBhY3RpdmUgc3Rha2UnKQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAhCiAgICBhc3NlcnQgLy8gVXNlciBzdGlsbCBoYXMgYWN0aXZlIHN0YWtlCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjYzCiAgICAvLyBwdWJsaWMgc3Rha2VycyA9IEJveE1hcDxBY2NvdW50LCBVc2VyU3Rha2VJbmZvPih7IGtleVByZWZpeDogJ3N0YWtlcnMnIH0pCiAgICBieXRlYyA5IC8vICJzdGFrZXJzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1MzcKICAgIC8vIGNvbnN0IHVzZXJCb3ggPSB0aGlzLnN0YWtlcnModXNlckFkZHJlc3MpCiAgICBmcmFtZV9kaWcgLTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjMKICAgIC8vIHB1YmxpYyBzdGFrZXJzID0gQm94TWFwPEFjY291bnQsIFVzZXJTdGFrZUluZm8+KHsga2V5UHJlZml4OiAnc3Rha2VycycgfSkKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1MzcKICAgIC8vIGNvbnN0IHVzZXJCb3ggPSB0aGlzLnN0YWtlcnModXNlckFkZHJlc3MpCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1MzgKICAgIC8vIGlmICh1c2VyQm94LmV4aXN0cykgewogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBieiBkZWxldGVVc2VyQm94X2FmdGVyX2lmX2Vsc2VANgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1MzkKICAgIC8vIHVzZXJCb3guZGVsZXRlKCkKICAgIGZyYW1lX2RpZyAwCiAgICBib3hfZGVsCiAgICBwb3AKCmRlbGV0ZVVzZXJCb3hfYWZ0ZXJfaWZfZWxzZUA2OgogICAgcmV0c3ViCgpkZWxldGVVc2VyQm94X2Jvb2xfZmFsc2VAMzoKICAgIGludGNfMCAvLyAwCiAgICBiIGRlbGV0ZVVzZXJCb3hfYm9vbF9tZXJnZUA0Cg==","clear":"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg=="},"byteCode":{"approval":"CiAEAAEEICYKCnJld2FyZFBvb2wFYXNzZXQMYWRtaW5BZGRyZXNzC3RvdGFsU3Rha2VkBBUffHUOYXByQmFzaXNQb2ludHMYZGlzdHJpYnV0aW9uUGVyaW9kUm91bmRzDG1pbmltdW1TdGFrZRRsYXN0RGlzdHJpYnV0aW9uVGltZQdzdGFrZXJzMRhAAB0pImcqMgNnKyJnJwUiZycIImcnBiJnJwciZygiZzEbQQHeghIEXXiVIQQID27NBA6T/eYEZnxdMASf/T5TBAiQvVgEIfHd/wSztwFGBAvYz2AEaQSsWgQrh/V8BPg+610EHmYSvQSCqx7EBBV2awkEv+MVZATOljsdBNyaKgU2GgCOEgFCASwBGgD2AOoA3gDOAMIAqgCSAIMAbgBeAEwANQAkABQAAiJDMRkURDEYRDYaARfAHIgFsiNDMRkURDEYRDYaAReIBWwjQzEZFEQxGESIBRMnBExQsCNDMRkURDEYRDYaARfAHIgEticETFCwI0MxGRREMRhENhoBF8AciASPI0MxGRREMRhENhoBF4gEbiNDMRkURDEYRDYaAYgEHRYnBExQsCNDMRkURDEYRDYaAYgDWyNDMRkURDEYRDYaARfAHIgDARYnBExQsCNDMRkURDEYRDYaARfAHIgCihYnBExQsCNDMRkURDEYRIgCQCNDMRkURDEYRDYaAReIAdAjQzEZFEQxGESIAUojQzEZFEQxGESIAQojQzEZFEQxGEQ2GgEXwDA2GgIXwBw2GgMXNhoEFzYaBReIALQjQzEZFEQxGESIAI8WJwRMULAjQzEZFEQxGEQ2GgEXwBw2GgKIAGZII0MxGRREMRhENhoBF8AciAASJwRMULAjQzEZQP6iMRgURCNDigEBJwmL/1BJvUUBQQAGiwC+REyJgCgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATImKAgEnCYv+UIv/v4v/iYoAASInBmVMSU8CREAAAyJMiTIHiwAKTImKBQAiKWVEFEQxADIJEkQpi/tnKov8ZysiZycFi/1nJwgyB2cnBov+ZycHi/9nKCJniYoAACIqZUQxADIJEkAACDEAiwASQQAZI0QiKWVEsTIKTLIRIrISshQkshAisgGziSJC/+SKAAAiKWVEIillREQyBIECEkQiOBBJJBJEJBJEIjgUMgoSRCI4EklOAkQiOBESRCInB2VEMQBJiP74RwIiW0AAFosAiwEPRIj/NxaLA0xcIDIHFlwIjASLBEkiW4sASU4DCBZcADIHFlwQiwJMiP8DSCIrZUQIK0xniYoBADEASYj+r0kiW0cCRIv/SwEORIv/RIv/DUEADIsCi/8JIicHZUQPRIsCi/8JFosBTFwAiwBMiP6+SCIrZUSL/wkrTGciKWVEsTEATLIRi/+yErIUJLIQgegHsgGziSIqZUQxABJEMgSBAhJEIillRCI4EEkkEkQkEkQiOBQyChJEIjgSSUQiOBFPAhJEIihlRAgoTGeJigEBIoAAIicFZUQiK2VEIicGZUxOAkRBAAWLA0AABCKMAImL/4j9+EmMACJbSYwBQAAEIowAiYsAgQhbMgdMgYnxAQgMQQAEIowAiYsCiwMLiwELgZCvvsmjAwqMAImKAQGAAEcCi/+I/bVJIltAAAQijACJiP33SYwAiwMlW0mMAQ1BABuLAIsBCYwCiwJAAAQijACJi/+I/2WLAguMAIkijAJC/+aKAQAiSYAASSIqZUQxABJEi/8iWUmBMg5EIkmLBosEDEEAhIv/VwIAiwYlCyVYSYwBiP1FSYwAIltJjANAAA8iiwUIjAWLBiMIjAZC/82LAYj/ZUmMAkAABCJC/+MiKGVEiwIMQQAEIkL/1YsDiwJJTgIIFosATFwASYEYW0sCCBZcGIj9QhZcIIsBTIj9K0giK2VESwEIK0xnIihlREsBCShMZ0L/mScIMgdniYoBAYAAIov/IlkiiwOLAgxBACqL/1cCAIsDJQslWIj8qyJbiwGMAEEABosBIwiMAIsAjAGLAyMIjANC/86LAYwAiYoBACIqZUQxABJEJwWL/2eJigEAIiplRDEAEkQqi/9niYoBAYv/iPxhi/+I/ptLASJbSwKBCFtLA4EQW0sEgRhbTwUlW08EFk8EFlBPAxZQTwIWUE8CFlBMFlBJFYEIChZXBgJMUIkiKWVEIitlRCInBWVEIicIZUQiJwZlRCInB2VEIihlRIj8T08HFk8HFlBPBhZQTwUWUE8EFlBPAxZQTwIWUEwWUEkVgQgKFlcGAkxQiYoBACIqZUQxAEsBEkQiKGVEi/8PRCIoZUSL/wkoTGciKWVEsbIRi/+yErIUJLIQgegHsgGziYoBACJJKmVEMQCL/xJAAAgxAIsBEkEAHiNEi/+I+4EiWxREJwmL/1BJjAC9RQFBAASLALxIiSJC/98=","clear":"CoEBQw=="},"compilerInfo":{"compiler":"puya","compilerVersion":{"major":4,"minor":7,"patch":0}},"events":[],"templateVariables":{}} as unknown as Arc56Contract

/**
 * A state record containing binary data
 */
export interface BinaryState {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array | undefined
  /**
   * Gets the state value as a string
   */
  asString(): string | undefined
}

class BinaryStateValue implements BinaryState {
  constructor(private value: Uint8Array | undefined) {}

  asByteArray(): Uint8Array | undefined {
    return this.value
  }

  asString(): string | undefined {
    return this.value !== undefined ? Buffer.from(this.value).toString('utf-8') : undefined
  }
}

/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R
  ? (...args: Expand<A>) => Expand<R>
  : T extends infer O
    ? { [K in keyof O]: O[K] }
    : never


// Type definitions for ARC-56 structs

export type UserStakeInfo = {
  stakedAmount: bigint,
  firstStakeTime: bigint,
  lastStakeTime: bigint,
  totalRewardsEarned: bigint,
  lastClaimedPeriod: bigint
}


/**
 * Converts the ABI tuple representation of a UserStakeInfo to the struct representation
 */
export function UserStakeInfoFromTuple(abiTuple: [bigint, bigint, bigint, bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.UserStakeInfo, APP_SPEC.structs) as UserStakeInfo
}

/**
 * The argument types for the AsaStakingContract contract
 */
export type AsaStakingContractArgs = {
  /**
   * The object representation of the arguments for each method
   */
  obj: {
    'getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)': {
      userAddress: Uint8Array | string
    }
    'storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void': {
      userAddress: Uint8Array | string
      stakeInfo: UserStakeInfo
    }
    'getCurrentPeriod()uint64': Record<string, never>
    'initialize(asset,account,uint64,uint64,uint64)void': {
      asset: bigint
      adminAddress: Uint8Array | string
      aprBasisPoints: bigint | number
      distributionPeriodSeconds: bigint | number
      minimumStake: bigint | number
    }
    'optInToAsset()void': Record<string, never>
    'stake()void': Record<string, never>
    'withdraw(uint64)void': {
      amount: bigint | number
    }
    'addRewards()void': Record<string, never>
    'calculateUserRewardsForPeriod(account)uint64': {
      userAddress: Uint8Array | string
    }
    'calculatePendingRewards(account)uint64': {
      userAddress: Uint8Array | string
    }
    'distributeRewards(address[])void': {
      stakerAddresses: string[]
    }
    'getActiveStakersCount(address[])uint64': {
      stakerAddresses: string[]
    }
    'updateAPR(uint64)void': {
      newAprBasisPoints: bigint | number
    }
    'updateAdmin(account)void': {
      newAdminAddress: Uint8Array | string
    }
    'getUserStats(account)uint64[]': {
      userAddress: Uint8Array | string
    }
    'getContractStats()uint64[]': Record<string, never>
    'emergencyWithdrawRewards(uint64)void': {
      amount: bigint | number
    }
    'deleteUserBox(account)void': {
      userAddress: Uint8Array | string
    }
  }
  /**
   * The tuple representation of the arguments for each method
   */
  tuple: {
    'getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)': [userAddress: Uint8Array | string]
    'storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void': [userAddress: Uint8Array | string, stakeInfo: UserStakeInfo]
    'getCurrentPeriod()uint64': []
    'initialize(asset,account,uint64,uint64,uint64)void': [asset: bigint, adminAddress: Uint8Array | string, aprBasisPoints: bigint | number, distributionPeriodSeconds: bigint | number, minimumStake: bigint | number]
    'optInToAsset()void': []
    'stake()void': []
    'withdraw(uint64)void': [amount: bigint | number]
    'addRewards()void': []
    'calculateUserRewardsForPeriod(account)uint64': [userAddress: Uint8Array | string]
    'calculatePendingRewards(account)uint64': [userAddress: Uint8Array | string]
    'distributeRewards(address[])void': [stakerAddresses: string[]]
    'getActiveStakersCount(address[])uint64': [stakerAddresses: string[]]
    'updateAPR(uint64)void': [newAprBasisPoints: bigint | number]
    'updateAdmin(account)void': [newAdminAddress: Uint8Array | string]
    'getUserStats(account)uint64[]': [userAddress: Uint8Array | string]
    'getContractStats()uint64[]': []
    'emergencyWithdrawRewards(uint64)void': [amount: bigint | number]
    'deleteUserBox(account)void': [userAddress: Uint8Array | string]
  }
}

/**
 * The return type for each method
 */
export type AsaStakingContractReturns = {
  'getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)': UserStakeInfo
  'storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void': void
  'getCurrentPeriod()uint64': bigint
  'initialize(asset,account,uint64,uint64,uint64)void': void
  'optInToAsset()void': void
  'stake()void': void
  'withdraw(uint64)void': void
  'addRewards()void': void
  'calculateUserRewardsForPeriod(account)uint64': bigint
  'calculatePendingRewards(account)uint64': bigint
  'distributeRewards(address[])void': void
  'getActiveStakersCount(address[])uint64': bigint
  'updateAPR(uint64)void': void
  'updateAdmin(account)void': void
  'getUserStats(account)uint64[]': bigint[]
  'getContractStats()uint64[]': bigint[]
  'emergencyWithdrawRewards(uint64)void': void
  'deleteUserBox(account)void': void
}

/**
 * Defines the types of available calls and state of the AsaStakingContract smart contract.
 */
export type AsaStakingContractTypes = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)' | 'getUserStakeInfo', {
      argsObj: AsaStakingContractArgs['obj']['getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)']
      argsTuple: AsaStakingContractArgs['tuple']['getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)']
      returns: AsaStakingContractReturns['getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)']
    }>
    & Record<'storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void' | 'storeUserStakeInfo', {
      argsObj: AsaStakingContractArgs['obj']['storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void']
      argsTuple: AsaStakingContractArgs['tuple']['storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void']
      returns: AsaStakingContractReturns['storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void']
    }>
    & Record<'getCurrentPeriod()uint64' | 'getCurrentPeriod', {
      argsObj: AsaStakingContractArgs['obj']['getCurrentPeriod()uint64']
      argsTuple: AsaStakingContractArgs['tuple']['getCurrentPeriod()uint64']
      returns: AsaStakingContractReturns['getCurrentPeriod()uint64']
    }>
    & Record<'initialize(asset,account,uint64,uint64,uint64)void' | 'initialize', {
      argsObj: AsaStakingContractArgs['obj']['initialize(asset,account,uint64,uint64,uint64)void']
      argsTuple: AsaStakingContractArgs['tuple']['initialize(asset,account,uint64,uint64,uint64)void']
      returns: AsaStakingContractReturns['initialize(asset,account,uint64,uint64,uint64)void']
    }>
    & Record<'optInToAsset()void' | 'optInToAsset', {
      argsObj: AsaStakingContractArgs['obj']['optInToAsset()void']
      argsTuple: AsaStakingContractArgs['tuple']['optInToAsset()void']
      returns: AsaStakingContractReturns['optInToAsset()void']
    }>
    & Record<'stake()void' | 'stake', {
      argsObj: AsaStakingContractArgs['obj']['stake()void']
      argsTuple: AsaStakingContractArgs['tuple']['stake()void']
      returns: AsaStakingContractReturns['stake()void']
    }>
    & Record<'withdraw(uint64)void' | 'withdraw', {
      argsObj: AsaStakingContractArgs['obj']['withdraw(uint64)void']
      argsTuple: AsaStakingContractArgs['tuple']['withdraw(uint64)void']
      returns: AsaStakingContractReturns['withdraw(uint64)void']
    }>
    & Record<'addRewards()void' | 'addRewards', {
      argsObj: AsaStakingContractArgs['obj']['addRewards()void']
      argsTuple: AsaStakingContractArgs['tuple']['addRewards()void']
      returns: AsaStakingContractReturns['addRewards()void']
    }>
    & Record<'calculateUserRewardsForPeriod(account)uint64' | 'calculateUserRewardsForPeriod', {
      argsObj: AsaStakingContractArgs['obj']['calculateUserRewardsForPeriod(account)uint64']
      argsTuple: AsaStakingContractArgs['tuple']['calculateUserRewardsForPeriod(account)uint64']
      returns: AsaStakingContractReturns['calculateUserRewardsForPeriod(account)uint64']
    }>
    & Record<'calculatePendingRewards(account)uint64' | 'calculatePendingRewards', {
      argsObj: AsaStakingContractArgs['obj']['calculatePendingRewards(account)uint64']
      argsTuple: AsaStakingContractArgs['tuple']['calculatePendingRewards(account)uint64']
      returns: AsaStakingContractReturns['calculatePendingRewards(account)uint64']
    }>
    & Record<'distributeRewards(address[])void' | 'distributeRewards', {
      argsObj: AsaStakingContractArgs['obj']['distributeRewards(address[])void']
      argsTuple: AsaStakingContractArgs['tuple']['distributeRewards(address[])void']
      returns: AsaStakingContractReturns['distributeRewards(address[])void']
    }>
    & Record<'getActiveStakersCount(address[])uint64' | 'getActiveStakersCount', {
      argsObj: AsaStakingContractArgs['obj']['getActiveStakersCount(address[])uint64']
      argsTuple: AsaStakingContractArgs['tuple']['getActiveStakersCount(address[])uint64']
      returns: AsaStakingContractReturns['getActiveStakersCount(address[])uint64']
    }>
    & Record<'updateAPR(uint64)void' | 'updateAPR', {
      argsObj: AsaStakingContractArgs['obj']['updateAPR(uint64)void']
      argsTuple: AsaStakingContractArgs['tuple']['updateAPR(uint64)void']
      returns: AsaStakingContractReturns['updateAPR(uint64)void']
    }>
    & Record<'updateAdmin(account)void' | 'updateAdmin', {
      argsObj: AsaStakingContractArgs['obj']['updateAdmin(account)void']
      argsTuple: AsaStakingContractArgs['tuple']['updateAdmin(account)void']
      returns: AsaStakingContractReturns['updateAdmin(account)void']
    }>
    & Record<'getUserStats(account)uint64[]' | 'getUserStats', {
      argsObj: AsaStakingContractArgs['obj']['getUserStats(account)uint64[]']
      argsTuple: AsaStakingContractArgs['tuple']['getUserStats(account)uint64[]']
      returns: AsaStakingContractReturns['getUserStats(account)uint64[]']
    }>
    & Record<'getContractStats()uint64[]' | 'getContractStats', {
      argsObj: AsaStakingContractArgs['obj']['getContractStats()uint64[]']
      argsTuple: AsaStakingContractArgs['tuple']['getContractStats()uint64[]']
      returns: AsaStakingContractReturns['getContractStats()uint64[]']
    }>
    & Record<'emergencyWithdrawRewards(uint64)void' | 'emergencyWithdrawRewards', {
      argsObj: AsaStakingContractArgs['obj']['emergencyWithdrawRewards(uint64)void']
      argsTuple: AsaStakingContractArgs['tuple']['emergencyWithdrawRewards(uint64)void']
      returns: AsaStakingContractReturns['emergencyWithdrawRewards(uint64)void']
    }>
    & Record<'deleteUserBox(account)void' | 'deleteUserBox', {
      argsObj: AsaStakingContractArgs['obj']['deleteUserBox(account)void']
      argsTuple: AsaStakingContractArgs['tuple']['deleteUserBox(account)void']
      returns: AsaStakingContractReturns['deleteUserBox(account)void']
    }>
  /**
   * Defines the shape of the state of the application.
   */
  state: {
    global: {
      keys: {
        asset: bigint
        adminAddress: string
        totalStaked: bigint
        aprBasisPoints: bigint
        lastDistributionTime: bigint
        distributionPeriodRounds: bigint
        minimumStake: bigint
        rewardPool: bigint
      }
      maps: {}
    }
    box: {
      keys: {}
      maps: {
        stakers: Map<string, UserStakeInfo>
      }
    }
  }
}

/**
 * Defines the possible abi call signatures.
 */
export type AsaStakingContractSignatures = keyof AsaStakingContractTypes['methods']
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type AsaStakingContractNonVoidMethodSignatures = keyof AsaStakingContractTypes['methods'] extends infer T ? T extends keyof AsaStakingContractTypes['methods'] ? MethodReturn<T> extends void ? never : T  : never : never
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<
  Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> &
    {
      /** The args for the ABI method call, either as an ordered array or an object */
      args: Expand<TArgs>
    }
>
/**
 * Maps a method signature from the AsaStakingContract smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends AsaStakingContractSignatures> = AsaStakingContractTypes['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the AsaStakingContract smart contract to the method's return type
 */
export type MethodReturn<TSignature extends AsaStakingContractSignatures> = AsaStakingContractTypes['methods'][TSignature]['returns']

/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = AsaStakingContractTypes['state']['global']['keys']

/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = AsaStakingContractTypes['state']['box']['keys']


/**
 * Defines supported create method params for this smart contract
 */
export type AsaStakingContractCreateCallParams =
  | Expand<AppClientBareCallParams & {method?: never} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
/**
 * Defines arguments required for the deploy method.
 */
export type AsaStakingContractDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
  /**
   * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  createParams?: AsaStakingContractCreateCallParams
}>


/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the AsaStakingContract smart contract
 */
export abstract class AsaStakingContractParamsFactory {
  /**
   * Constructs a no op call for the getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64) ABI method
   *
   * Helper function to read user stake info from box storage
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getUserStakeInfo(params: CallParams<AsaStakingContractArgs['obj']['getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)'] | AsaStakingContractArgs['tuple']['getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.userAddress],
    }
  }
  /**
   * Constructs a no op call for the storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void ABI method
   *
   * Helper function to store user stake info in box storage
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static storeUserStakeInfo(params: CallParams<AsaStakingContractArgs['obj']['storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void'] | AsaStakingContractArgs['tuple']['storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.userAddress, params.args.stakeInfo],
    }
  }
  /**
   * Constructs a no op call for the getCurrentPeriod()uint64 ABI method
   *
   * Calculate the current distribution period
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getCurrentPeriod(params: CallParams<AsaStakingContractArgs['obj']['getCurrentPeriod()uint64'] | AsaStakingContractArgs['tuple']['getCurrentPeriod()uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getCurrentPeriod()uint64' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the initialize(asset,account,uint64,uint64,uint64)void ABI method
   *
   * Initialize the contract with the ASA token ID and other parameters
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static initialize(params: CallParams<AsaStakingContractArgs['obj']['initialize(asset,account,uint64,uint64,uint64)void'] | AsaStakingContractArgs['tuple']['initialize(asset,account,uint64,uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'initialize(asset,account,uint64,uint64,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.asset, params.args.adminAddress, params.args.aprBasisPoints, params.args.distributionPeriodSeconds, params.args.minimumStake],
    }
  }
  /**
   * Constructs a no op call for the optInToAsset()void ABI method
   *
   * Opt the contract into the ASA
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static optInToAsset(params: CallParams<AsaStakingContractArgs['obj']['optInToAsset()void'] | AsaStakingContractArgs['tuple']['optInToAsset()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'optInToAsset()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the stake()void ABI method
   *
  * Stake tokens
  Requires a companion ASA transfer transaction

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static stake(params: CallParams<AsaStakingContractArgs['obj']['stake()void'] | AsaStakingContractArgs['tuple']['stake()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'stake()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the withdraw(uint64)void ABI method
   *
   * Withdraw staked tokens
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static withdraw(params: CallParams<AsaStakingContractArgs['obj']['withdraw(uint64)void'] | AsaStakingContractArgs['tuple']['withdraw(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'withdraw(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.amount],
    }
  }
  /**
   * Constructs a no op call for the addRewards()void ABI method
   *
  * Add rewards to the reward pool
  Only the admin can call this
  Requires a companion ASA transfer transaction with the rewards

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static addRewards(params: CallParams<AsaStakingContractArgs['obj']['addRewards()void'] | AsaStakingContractArgs['tuple']['addRewards()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'addRewards()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the calculateUserRewardsForPeriod(account)uint64 ABI method
   *
  * Calculate rewards for a specific user for a given period
  This calculates rewards per distribution period

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static calculateUserRewardsForPeriod(params: CallParams<AsaStakingContractArgs['obj']['calculateUserRewardsForPeriod(account)uint64'] | AsaStakingContractArgs['tuple']['calculateUserRewardsForPeriod(account)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'calculateUserRewardsForPeriod(account)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.userAddress],
    }
  }
  /**
   * Constructs a no op call for the calculatePendingRewards(account)uint64 ABI method
   *
   * Calculate pending rewards for a user since their last claim
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static calculatePendingRewards(params: CallParams<AsaStakingContractArgs['obj']['calculatePendingRewards(account)uint64'] | AsaStakingContractArgs['tuple']['calculatePendingRewards(account)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'calculatePendingRewards(account)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.userAddress],
    }
  }
  /**
   * Constructs a no op call for the distributeRewards(address[])void ABI method
   *
  * Distribute and compound rewards for multiple stakers
  This method is designed to be called by a cron job on a daily basis
  Only admin can call this method

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static distributeRewards(params: CallParams<AsaStakingContractArgs['obj']['distributeRewards(address[])void'] | AsaStakingContractArgs['tuple']['distributeRewards(address[])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'distributeRewards(address[])void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.stakerAddresses],
    }
  }
  /**
   * Constructs a no op call for the getActiveStakersCount(address[])uint64 ABI method
   *
  * Get all non-zero stakers count (for monitoring purposes)
  Note: This doesn't return the actual addresses due to box iteration limitations

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getActiveStakersCount(params: CallParams<AsaStakingContractArgs['obj']['getActiveStakersCount(address[])uint64'] | AsaStakingContractArgs['tuple']['getActiveStakersCount(address[])uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getActiveStakersCount(address[])uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.stakerAddresses],
    }
  }
  /**
   * Constructs a no op call for the updateAPR(uint64)void ABI method
   *
  * Update the APR basis points
  Only the admin can call this

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateApr(params: CallParams<AsaStakingContractArgs['obj']['updateAPR(uint64)void'] | AsaStakingContractArgs['tuple']['updateAPR(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'updateAPR(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.newAprBasisPoints],
    }
  }
  /**
   * Constructs a no op call for the updateAdmin(account)void ABI method
   *
  * Update the admin address
  Only the current admin can call this

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAdmin(params: CallParams<AsaStakingContractArgs['obj']['updateAdmin(account)void'] | AsaStakingContractArgs['tuple']['updateAdmin(account)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'updateAdmin(account)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.newAdminAddress],
    }
  }
  /**
   * Constructs a no op call for the getUserStats(account)uint64[] ABI method
   *
   * Get current staking statistics for a user
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getUserStats(params: CallParams<AsaStakingContractArgs['obj']['getUserStats(account)uint64[]'] | AsaStakingContractArgs['tuple']['getUserStats(account)uint64[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getUserStats(account)uint64[]' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.userAddress],
    }
  }
  /**
   * Constructs a no op call for the getContractStats()uint64[] ABI method
   *
   * Get contract global statistics
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getContractStats(params: CallParams<AsaStakingContractArgs['obj']['getContractStats()uint64[]'] | AsaStakingContractArgs['tuple']['getContractStats()uint64[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getContractStats()uint64[]' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the emergencyWithdrawRewards(uint64)void ABI method
   *
   * Emergency withdraw rewards from pool (admin only)
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static emergencyWithdrawRewards(params: CallParams<AsaStakingContractArgs['obj']['emergencyWithdrawRewards(uint64)void'] | AsaStakingContractArgs['tuple']['emergencyWithdrawRewards(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'emergencyWithdrawRewards(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.amount],
    }
  }
  /**
   * Constructs a no op call for the deleteUserBox(account)void ABI method
   *
  * Delete a user's box (for cleanup)
  Can only be called by the box owner or admin

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static deleteUserBox(params: CallParams<AsaStakingContractArgs['obj']['deleteUserBox(account)void'] | AsaStakingContractArgs['tuple']['deleteUserBox(account)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'deleteUserBox(account)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.userAddress],
    }
  }
}

/**
 * A factory to create and deploy one or more instance of the ASAStakingContract smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export class AsaStakingContractFactory {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  public readonly appFactory: _AppFactory

  /**
   * Creates a new instance of `AsaStakingContractFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params: Omit<AppFactoryParams, 'appSpec'>) {
    this.appFactory = new _AppFactory({
      ...params,
      appSpec: APP_SPEC,
    })
  }
  
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  public get appName() {
    return this.appFactory.appName
  }
  
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC
  }
  
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  public get algorand(): AlgorandClient {
    return this.appFactory.algorand
  }
  
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public getAppClientById(params: AppFactoryAppClientParams) {
    return new AsaStakingContractClient(this.appFactory.getAppClientById(params))
  }
  
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public async getAppClientByCreatorAndName(
    params: AppFactoryResolveAppClientByCreatorAndNameParams,
  ) {
    return new AsaStakingContractClient(await this.appFactory.getAppClientByCreatorAndName(params))
  }

  /**
   * Idempotently deploys the ASAStakingContract smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public async deploy(params: AsaStakingContractDeployParams = {}) {
    const result = await this.appFactory.deploy({
      ...params,
    })
    return { result: result.result, appClient: new AsaStakingContractClient(result.appClient) }
  }

  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the ASAStakingContract smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The params for a create call
       */
      bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        return this.appFactory.params.bare.create(params)
      },
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the ASAStakingContract smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The transaction for a create call
       */
      bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        return this.appFactory.createTransaction.bare.create(params)
      },
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the ASAStakingContract smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The create result
       */
      bare: async (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        const result = await this.appFactory.send.bare.create(params)
        return { result: result.result, appClient: new AsaStakingContractClient(result.appClient) }
      },
    },

  }

}
/**
 * A client to make calls to the ASAStakingContract smart contract
 */
export class AsaStakingContractClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  public readonly appClient: _AppClient

  /**
   * Creates a new instance of `AsaStakingContractClient`
   *
   * @param appClient An `AppClient` instance which has been created with the AsaStakingContract app spec
   */
  constructor(appClient: _AppClient)
  /**
   * Creates a new instance of `AsaStakingContractClient`
   *
   * @param params The parameters to initialise the app client with
   */
  constructor(params: Omit<AppClientParams, 'appSpec'>)
  constructor(appClientOrParams: _AppClient | Omit<AppClientParams, 'appSpec'>) {
    this.appClient = appClientOrParams instanceof _AppClient ? appClientOrParams : new _AppClient({
      ...appClientOrParams,
      appSpec: APP_SPEC,
    })
  }
  
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue<TSignature extends AsaStakingContractNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined) {
    return returnValue !== undefined ? getArc56ReturnValue<MethodReturn<TSignature>>(returnValue, this.appClient.getABIMethod(method), APP_SPEC.structs) : undefined
  }
  
  /**
   * Returns a new `AsaStakingContractClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  public static async fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<AsaStakingContractClient> {
    return new AsaStakingContractClient(await _AppClient.fromCreatorAndName({...params, appSpec: APP_SPEC}))
  }
  
  /**
   * Returns an `AsaStakingContractClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(
    params: Omit<ResolveAppClientByNetwork, 'appSpec'>
  ): Promise<AsaStakingContractClient> {
    return new AsaStakingContractClient(await _AppClient.fromNetwork({...params, appSpec: APP_SPEC}))
  }
  
  /** The ID of the app instance this client is linked to. */
  public get appId() {
    return this.appClient.appId
  }
  
  /** The app address of the app instance this client is linked to. */
  public get appAddress() {
    return this.appClient.appAddress
  }
  
  /** The name of the app. */
  public get appName() {
    return this.appClient.appName
  }
  
  /** The ARC-56 app spec being used */
  public get appSpec() {
    return this.appClient.appSpec
  }
  
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  public get algorand(): AlgorandClient {
    return this.appClient.algorand
  }

  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Makes a clear_state call to an existing instance of the ASAStakingContract smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.params.bare.clearState(params)
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * Helper function to read user stake info from box storage
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getUserStakeInfo: (params: CallParams<AsaStakingContractArgs['obj']['getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)'] | AsaStakingContractArgs['tuple']['getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AsaStakingContractParamsFactory.getUserStakeInfo(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * Helper function to store user stake info in box storage
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    storeUserStakeInfo: (params: CallParams<AsaStakingContractArgs['obj']['storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void'] | AsaStakingContractArgs['tuple']['storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AsaStakingContractParamsFactory.storeUserStakeInfo(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `getCurrentPeriod()uint64` ABI method.
     *
     * Calculate the current distribution period
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getCurrentPeriod: (params: CallParams<AsaStakingContractArgs['obj']['getCurrentPeriod()uint64'] | AsaStakingContractArgs['tuple']['getCurrentPeriod()uint64']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(AsaStakingContractParamsFactory.getCurrentPeriod(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `initialize(asset,account,uint64,uint64,uint64)void` ABI method.
     *
     * Initialize the contract with the ASA token ID and other parameters
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    initialize: (params: CallParams<AsaStakingContractArgs['obj']['initialize(asset,account,uint64,uint64,uint64)void'] | AsaStakingContractArgs['tuple']['initialize(asset,account,uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AsaStakingContractParamsFactory.initialize(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `optInToAsset()void` ABI method.
     *
     * Opt the contract into the ASA
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    optInToAsset: (params: CallParams<AsaStakingContractArgs['obj']['optInToAsset()void'] | AsaStakingContractArgs['tuple']['optInToAsset()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(AsaStakingContractParamsFactory.optInToAsset(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `stake()void` ABI method.
     *
    * Stake tokens
    Requires a companion ASA transfer transaction

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    stake: (params: CallParams<AsaStakingContractArgs['obj']['stake()void'] | AsaStakingContractArgs['tuple']['stake()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(AsaStakingContractParamsFactory.stake(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `withdraw(uint64)void` ABI method.
     *
     * Withdraw staked tokens
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    withdraw: (params: CallParams<AsaStakingContractArgs['obj']['withdraw(uint64)void'] | AsaStakingContractArgs['tuple']['withdraw(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AsaStakingContractParamsFactory.withdraw(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `addRewards()void` ABI method.
     *
    * Add rewards to the reward pool
    Only the admin can call this
    Requires a companion ASA transfer transaction with the rewards

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    addRewards: (params: CallParams<AsaStakingContractArgs['obj']['addRewards()void'] | AsaStakingContractArgs['tuple']['addRewards()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(AsaStakingContractParamsFactory.addRewards(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `calculateUserRewardsForPeriod(account)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Calculate rewards for a specific user for a given period
    This calculates rewards per distribution period

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    calculateUserRewardsForPeriod: (params: CallParams<AsaStakingContractArgs['obj']['calculateUserRewardsForPeriod(account)uint64'] | AsaStakingContractArgs['tuple']['calculateUserRewardsForPeriod(account)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AsaStakingContractParamsFactory.calculateUserRewardsForPeriod(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `calculatePendingRewards(account)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Calculate pending rewards for a user since their last claim
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    calculatePendingRewards: (params: CallParams<AsaStakingContractArgs['obj']['calculatePendingRewards(account)uint64'] | AsaStakingContractArgs['tuple']['calculatePendingRewards(account)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AsaStakingContractParamsFactory.calculatePendingRewards(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `distributeRewards(address[])void` ABI method.
     *
    * Distribute and compound rewards for multiple stakers
    This method is designed to be called by a cron job on a daily basis
    Only admin can call this method

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    distributeRewards: (params: CallParams<AsaStakingContractArgs['obj']['distributeRewards(address[])void'] | AsaStakingContractArgs['tuple']['distributeRewards(address[])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AsaStakingContractParamsFactory.distributeRewards(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `getActiveStakersCount(address[])uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Get all non-zero stakers count (for monitoring purposes)
    Note: This doesn't return the actual addresses due to box iteration limitations

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getActiveStakersCount: (params: CallParams<AsaStakingContractArgs['obj']['getActiveStakersCount(address[])uint64'] | AsaStakingContractArgs['tuple']['getActiveStakersCount(address[])uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AsaStakingContractParamsFactory.getActiveStakersCount(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `updateAPR(uint64)void` ABI method.
     *
    * Update the APR basis points
    Only the admin can call this

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateApr: (params: CallParams<AsaStakingContractArgs['obj']['updateAPR(uint64)void'] | AsaStakingContractArgs['tuple']['updateAPR(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AsaStakingContractParamsFactory.updateApr(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `updateAdmin(account)void` ABI method.
     *
    * Update the admin address
    Only the current admin can call this

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAdmin: (params: CallParams<AsaStakingContractArgs['obj']['updateAdmin(account)void'] | AsaStakingContractArgs['tuple']['updateAdmin(account)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AsaStakingContractParamsFactory.updateAdmin(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `getUserStats(account)uint64[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get current staking statistics for a user
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getUserStats: (params: CallParams<AsaStakingContractArgs['obj']['getUserStats(account)uint64[]'] | AsaStakingContractArgs['tuple']['getUserStats(account)uint64[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AsaStakingContractParamsFactory.getUserStats(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `getContractStats()uint64[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get contract global statistics
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getContractStats: (params: CallParams<AsaStakingContractArgs['obj']['getContractStats()uint64[]'] | AsaStakingContractArgs['tuple']['getContractStats()uint64[]']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(AsaStakingContractParamsFactory.getContractStats(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `emergencyWithdrawRewards(uint64)void` ABI method.
     *
     * Emergency withdraw rewards from pool (admin only)
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    emergencyWithdrawRewards: (params: CallParams<AsaStakingContractArgs['obj']['emergencyWithdrawRewards(uint64)void'] | AsaStakingContractArgs['tuple']['emergencyWithdrawRewards(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AsaStakingContractParamsFactory.emergencyWithdrawRewards(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `deleteUserBox(account)void` ABI method.
     *
    * Delete a user's box (for cleanup)
    Can only be called by the box owner or admin

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    deleteUserBox: (params: CallParams<AsaStakingContractArgs['obj']['deleteUserBox(account)void'] | AsaStakingContractArgs['tuple']['deleteUserBox(account)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(AsaStakingContractParamsFactory.deleteUserBox(params))
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the ASAStakingContract smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.createTransaction.bare.clearState(params)
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * Helper function to read user stake info from box storage
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getUserStakeInfo: (params: CallParams<AsaStakingContractArgs['obj']['getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)'] | AsaStakingContractArgs['tuple']['getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AsaStakingContractParamsFactory.getUserStakeInfo(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * Helper function to store user stake info in box storage
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    storeUserStakeInfo: (params: CallParams<AsaStakingContractArgs['obj']['storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void'] | AsaStakingContractArgs['tuple']['storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AsaStakingContractParamsFactory.storeUserStakeInfo(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `getCurrentPeriod()uint64` ABI method.
     *
     * Calculate the current distribution period
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getCurrentPeriod: (params: CallParams<AsaStakingContractArgs['obj']['getCurrentPeriod()uint64'] | AsaStakingContractArgs['tuple']['getCurrentPeriod()uint64']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(AsaStakingContractParamsFactory.getCurrentPeriod(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `initialize(asset,account,uint64,uint64,uint64)void` ABI method.
     *
     * Initialize the contract with the ASA token ID and other parameters
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    initialize: (params: CallParams<AsaStakingContractArgs['obj']['initialize(asset,account,uint64,uint64,uint64)void'] | AsaStakingContractArgs['tuple']['initialize(asset,account,uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AsaStakingContractParamsFactory.initialize(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `optInToAsset()void` ABI method.
     *
     * Opt the contract into the ASA
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    optInToAsset: (params: CallParams<AsaStakingContractArgs['obj']['optInToAsset()void'] | AsaStakingContractArgs['tuple']['optInToAsset()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(AsaStakingContractParamsFactory.optInToAsset(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `stake()void` ABI method.
     *
    * Stake tokens
    Requires a companion ASA transfer transaction

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    stake: (params: CallParams<AsaStakingContractArgs['obj']['stake()void'] | AsaStakingContractArgs['tuple']['stake()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(AsaStakingContractParamsFactory.stake(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `withdraw(uint64)void` ABI method.
     *
     * Withdraw staked tokens
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    withdraw: (params: CallParams<AsaStakingContractArgs['obj']['withdraw(uint64)void'] | AsaStakingContractArgs['tuple']['withdraw(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AsaStakingContractParamsFactory.withdraw(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `addRewards()void` ABI method.
     *
    * Add rewards to the reward pool
    Only the admin can call this
    Requires a companion ASA transfer transaction with the rewards

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    addRewards: (params: CallParams<AsaStakingContractArgs['obj']['addRewards()void'] | AsaStakingContractArgs['tuple']['addRewards()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(AsaStakingContractParamsFactory.addRewards(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `calculateUserRewardsForPeriod(account)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Calculate rewards for a specific user for a given period
    This calculates rewards per distribution period

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    calculateUserRewardsForPeriod: (params: CallParams<AsaStakingContractArgs['obj']['calculateUserRewardsForPeriod(account)uint64'] | AsaStakingContractArgs['tuple']['calculateUserRewardsForPeriod(account)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AsaStakingContractParamsFactory.calculateUserRewardsForPeriod(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `calculatePendingRewards(account)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Calculate pending rewards for a user since their last claim
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    calculatePendingRewards: (params: CallParams<AsaStakingContractArgs['obj']['calculatePendingRewards(account)uint64'] | AsaStakingContractArgs['tuple']['calculatePendingRewards(account)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AsaStakingContractParamsFactory.calculatePendingRewards(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `distributeRewards(address[])void` ABI method.
     *
    * Distribute and compound rewards for multiple stakers
    This method is designed to be called by a cron job on a daily basis
    Only admin can call this method

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    distributeRewards: (params: CallParams<AsaStakingContractArgs['obj']['distributeRewards(address[])void'] | AsaStakingContractArgs['tuple']['distributeRewards(address[])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AsaStakingContractParamsFactory.distributeRewards(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `getActiveStakersCount(address[])uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Get all non-zero stakers count (for monitoring purposes)
    Note: This doesn't return the actual addresses due to box iteration limitations

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getActiveStakersCount: (params: CallParams<AsaStakingContractArgs['obj']['getActiveStakersCount(address[])uint64'] | AsaStakingContractArgs['tuple']['getActiveStakersCount(address[])uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AsaStakingContractParamsFactory.getActiveStakersCount(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `updateAPR(uint64)void` ABI method.
     *
    * Update the APR basis points
    Only the admin can call this

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateApr: (params: CallParams<AsaStakingContractArgs['obj']['updateAPR(uint64)void'] | AsaStakingContractArgs['tuple']['updateAPR(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AsaStakingContractParamsFactory.updateApr(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `updateAdmin(account)void` ABI method.
     *
    * Update the admin address
    Only the current admin can call this

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAdmin: (params: CallParams<AsaStakingContractArgs['obj']['updateAdmin(account)void'] | AsaStakingContractArgs['tuple']['updateAdmin(account)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AsaStakingContractParamsFactory.updateAdmin(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `getUserStats(account)uint64[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get current staking statistics for a user
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getUserStats: (params: CallParams<AsaStakingContractArgs['obj']['getUserStats(account)uint64[]'] | AsaStakingContractArgs['tuple']['getUserStats(account)uint64[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AsaStakingContractParamsFactory.getUserStats(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `getContractStats()uint64[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get contract global statistics
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getContractStats: (params: CallParams<AsaStakingContractArgs['obj']['getContractStats()uint64[]'] | AsaStakingContractArgs['tuple']['getContractStats()uint64[]']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(AsaStakingContractParamsFactory.getContractStats(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `emergencyWithdrawRewards(uint64)void` ABI method.
     *
     * Emergency withdraw rewards from pool (admin only)
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    emergencyWithdrawRewards: (params: CallParams<AsaStakingContractArgs['obj']['emergencyWithdrawRewards(uint64)void'] | AsaStakingContractArgs['tuple']['emergencyWithdrawRewards(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AsaStakingContractParamsFactory.emergencyWithdrawRewards(params))
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `deleteUserBox(account)void` ABI method.
     *
    * Delete a user's box (for cleanup)
    Can only be called by the box owner or admin

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    deleteUserBox: (params: CallParams<AsaStakingContractArgs['obj']['deleteUserBox(account)void'] | AsaStakingContractArgs['tuple']['deleteUserBox(account)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(AsaStakingContractParamsFactory.deleteUserBox(params))
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Makes a clear_state call to an existing instance of the ASAStakingContract smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => {
      return this.appClient.send.bare.clearState(params)
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * Helper function to read user stake info from box storage
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getUserStakeInfo: async (params: CallParams<AsaStakingContractArgs['obj']['getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)'] | AsaStakingContractArgs['tuple']['getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AsaStakingContractParamsFactory.getUserStakeInfo(params))
      return {...result, return: result.return as unknown as (undefined | AsaStakingContractReturns['getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)'])}
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void` ABI method.
     *
     * Helper function to store user stake info in box storage
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    storeUserStakeInfo: async (params: CallParams<AsaStakingContractArgs['obj']['storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void'] | AsaStakingContractArgs['tuple']['storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AsaStakingContractParamsFactory.storeUserStakeInfo(params))
      return {...result, return: result.return as unknown as (undefined | AsaStakingContractReturns['storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void'])}
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `getCurrentPeriod()uint64` ABI method.
     *
     * Calculate the current distribution period
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getCurrentPeriod: async (params: CallParams<AsaStakingContractArgs['obj']['getCurrentPeriod()uint64'] | AsaStakingContractArgs['tuple']['getCurrentPeriod()uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(AsaStakingContractParamsFactory.getCurrentPeriod(params))
      return {...result, return: result.return as unknown as (undefined | AsaStakingContractReturns['getCurrentPeriod()uint64'])}
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `initialize(asset,account,uint64,uint64,uint64)void` ABI method.
     *
     * Initialize the contract with the ASA token ID and other parameters
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    initialize: async (params: CallParams<AsaStakingContractArgs['obj']['initialize(asset,account,uint64,uint64,uint64)void'] | AsaStakingContractArgs['tuple']['initialize(asset,account,uint64,uint64,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AsaStakingContractParamsFactory.initialize(params))
      return {...result, return: result.return as unknown as (undefined | AsaStakingContractReturns['initialize(asset,account,uint64,uint64,uint64)void'])}
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `optInToAsset()void` ABI method.
     *
     * Opt the contract into the ASA
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    optInToAsset: async (params: CallParams<AsaStakingContractArgs['obj']['optInToAsset()void'] | AsaStakingContractArgs['tuple']['optInToAsset()void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(AsaStakingContractParamsFactory.optInToAsset(params))
      return {...result, return: result.return as unknown as (undefined | AsaStakingContractReturns['optInToAsset()void'])}
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `stake()void` ABI method.
     *
    * Stake tokens
    Requires a companion ASA transfer transaction

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    stake: async (params: CallParams<AsaStakingContractArgs['obj']['stake()void'] | AsaStakingContractArgs['tuple']['stake()void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(AsaStakingContractParamsFactory.stake(params))
      return {...result, return: result.return as unknown as (undefined | AsaStakingContractReturns['stake()void'])}
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `withdraw(uint64)void` ABI method.
     *
     * Withdraw staked tokens
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    withdraw: async (params: CallParams<AsaStakingContractArgs['obj']['withdraw(uint64)void'] | AsaStakingContractArgs['tuple']['withdraw(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AsaStakingContractParamsFactory.withdraw(params))
      return {...result, return: result.return as unknown as (undefined | AsaStakingContractReturns['withdraw(uint64)void'])}
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `addRewards()void` ABI method.
     *
    * Add rewards to the reward pool
    Only the admin can call this
    Requires a companion ASA transfer transaction with the rewards

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    addRewards: async (params: CallParams<AsaStakingContractArgs['obj']['addRewards()void'] | AsaStakingContractArgs['tuple']['addRewards()void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(AsaStakingContractParamsFactory.addRewards(params))
      return {...result, return: result.return as unknown as (undefined | AsaStakingContractReturns['addRewards()void'])}
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `calculateUserRewardsForPeriod(account)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Calculate rewards for a specific user for a given period
    This calculates rewards per distribution period

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    calculateUserRewardsForPeriod: async (params: CallParams<AsaStakingContractArgs['obj']['calculateUserRewardsForPeriod(account)uint64'] | AsaStakingContractArgs['tuple']['calculateUserRewardsForPeriod(account)uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AsaStakingContractParamsFactory.calculateUserRewardsForPeriod(params))
      return {...result, return: result.return as unknown as (undefined | AsaStakingContractReturns['calculateUserRewardsForPeriod(account)uint64'])}
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `calculatePendingRewards(account)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Calculate pending rewards for a user since their last claim
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    calculatePendingRewards: async (params: CallParams<AsaStakingContractArgs['obj']['calculatePendingRewards(account)uint64'] | AsaStakingContractArgs['tuple']['calculatePendingRewards(account)uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AsaStakingContractParamsFactory.calculatePendingRewards(params))
      return {...result, return: result.return as unknown as (undefined | AsaStakingContractReturns['calculatePendingRewards(account)uint64'])}
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `distributeRewards(address[])void` ABI method.
     *
    * Distribute and compound rewards for multiple stakers
    This method is designed to be called by a cron job on a daily basis
    Only admin can call this method

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    distributeRewards: async (params: CallParams<AsaStakingContractArgs['obj']['distributeRewards(address[])void'] | AsaStakingContractArgs['tuple']['distributeRewards(address[])void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AsaStakingContractParamsFactory.distributeRewards(params))
      return {...result, return: result.return as unknown as (undefined | AsaStakingContractReturns['distributeRewards(address[])void'])}
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `getActiveStakersCount(address[])uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Get all non-zero stakers count (for monitoring purposes)
    Note: This doesn't return the actual addresses due to box iteration limitations

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getActiveStakersCount: async (params: CallParams<AsaStakingContractArgs['obj']['getActiveStakersCount(address[])uint64'] | AsaStakingContractArgs['tuple']['getActiveStakersCount(address[])uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AsaStakingContractParamsFactory.getActiveStakersCount(params))
      return {...result, return: result.return as unknown as (undefined | AsaStakingContractReturns['getActiveStakersCount(address[])uint64'])}
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `updateAPR(uint64)void` ABI method.
     *
    * Update the APR basis points
    Only the admin can call this

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateApr: async (params: CallParams<AsaStakingContractArgs['obj']['updateAPR(uint64)void'] | AsaStakingContractArgs['tuple']['updateAPR(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AsaStakingContractParamsFactory.updateApr(params))
      return {...result, return: result.return as unknown as (undefined | AsaStakingContractReturns['updateAPR(uint64)void'])}
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `updateAdmin(account)void` ABI method.
     *
    * Update the admin address
    Only the current admin can call this

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAdmin: async (params: CallParams<AsaStakingContractArgs['obj']['updateAdmin(account)void'] | AsaStakingContractArgs['tuple']['updateAdmin(account)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AsaStakingContractParamsFactory.updateAdmin(params))
      return {...result, return: result.return as unknown as (undefined | AsaStakingContractReturns['updateAdmin(account)void'])}
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `getUserStats(account)uint64[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get current staking statistics for a user
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getUserStats: async (params: CallParams<AsaStakingContractArgs['obj']['getUserStats(account)uint64[]'] | AsaStakingContractArgs['tuple']['getUserStats(account)uint64[]']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AsaStakingContractParamsFactory.getUserStats(params))
      return {...result, return: result.return as unknown as (undefined | AsaStakingContractReturns['getUserStats(account)uint64[]'])}
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `getContractStats()uint64[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get contract global statistics
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getContractStats: async (params: CallParams<AsaStakingContractArgs['obj']['getContractStats()uint64[]'] | AsaStakingContractArgs['tuple']['getContractStats()uint64[]']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(AsaStakingContractParamsFactory.getContractStats(params))
      return {...result, return: result.return as unknown as (undefined | AsaStakingContractReturns['getContractStats()uint64[]'])}
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `emergencyWithdrawRewards(uint64)void` ABI method.
     *
     * Emergency withdraw rewards from pool (admin only)
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    emergencyWithdrawRewards: async (params: CallParams<AsaStakingContractArgs['obj']['emergencyWithdrawRewards(uint64)void'] | AsaStakingContractArgs['tuple']['emergencyWithdrawRewards(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AsaStakingContractParamsFactory.emergencyWithdrawRewards(params))
      return {...result, return: result.return as unknown as (undefined | AsaStakingContractReturns['emergencyWithdrawRewards(uint64)void'])}
    },

    /**
     * Makes a call to the ASAStakingContract smart contract using the `deleteUserBox(account)void` ABI method.
     *
    * Delete a user's box (for cleanup)
    Can only be called by the box owner or admin

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    deleteUserBox: async (params: CallParams<AsaStakingContractArgs['obj']['deleteUserBox(account)void'] | AsaStakingContractArgs['tuple']['deleteUserBox(account)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(AsaStakingContractParamsFactory.deleteUserBox(params))
      return {...result, return: result.return as unknown as (undefined | AsaStakingContractReturns['deleteUserBox(account)void'])}
    },

  }

  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  public clone(params: CloneAppClientParams) {
    return new AsaStakingContractClient(this.appClient.clone(params))
  }

  /**
   * Makes a readonly (simulated) call to the ASAStakingContract smart contract using the `calculateUserRewardsForPeriod(account)uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
  * Calculate rewards for a specific user for a given period
  This calculates rewards per distribution period

   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async calculateUserRewardsForPeriod(params: CallParams<AsaStakingContractArgs['obj']['calculateUserRewardsForPeriod(account)uint64'] | AsaStakingContractArgs['tuple']['calculateUserRewardsForPeriod(account)uint64']>) {
    const result = await this.appClient.send.call(AsaStakingContractParamsFactory.calculateUserRewardsForPeriod(params))
    return result.return as unknown as AsaStakingContractReturns['calculateUserRewardsForPeriod(account)uint64']
  }

  /**
   * Makes a readonly (simulated) call to the ASAStakingContract smart contract using the `calculatePendingRewards(account)uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Calculate pending rewards for a user since their last claim
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async calculatePendingRewards(params: CallParams<AsaStakingContractArgs['obj']['calculatePendingRewards(account)uint64'] | AsaStakingContractArgs['tuple']['calculatePendingRewards(account)uint64']>) {
    const result = await this.appClient.send.call(AsaStakingContractParamsFactory.calculatePendingRewards(params))
    return result.return as unknown as AsaStakingContractReturns['calculatePendingRewards(account)uint64']
  }

  /**
   * Makes a readonly (simulated) call to the ASAStakingContract smart contract using the `getActiveStakersCount(address[])uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
  * Get all non-zero stakers count (for monitoring purposes)
  Note: This doesn't return the actual addresses due to box iteration limitations

   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getActiveStakersCount(params: CallParams<AsaStakingContractArgs['obj']['getActiveStakersCount(address[])uint64'] | AsaStakingContractArgs['tuple']['getActiveStakersCount(address[])uint64']>) {
    const result = await this.appClient.send.call(AsaStakingContractParamsFactory.getActiveStakersCount(params))
    return result.return as unknown as AsaStakingContractReturns['getActiveStakersCount(address[])uint64']
  }

  /**
   * Makes a readonly (simulated) call to the ASAStakingContract smart contract using the `getUserStats(account)uint64[]` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Get current staking statistics for a user
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getUserStats(params: CallParams<AsaStakingContractArgs['obj']['getUserStats(account)uint64[]'] | AsaStakingContractArgs['tuple']['getUserStats(account)uint64[]']>) {
    const result = await this.appClient.send.call(AsaStakingContractParamsFactory.getUserStats(params))
    return result.return as unknown as AsaStakingContractReturns['getUserStats(account)uint64[]']
  }

  /**
   * Makes a readonly (simulated) call to the ASAStakingContract smart contract using the `getContractStats()uint64[]` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Get contract global statistics
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getContractStats(params: CallParams<AsaStakingContractArgs['obj']['getContractStats()uint64[]'] | AsaStakingContractArgs['tuple']['getContractStats()uint64[]']> = {args: []}) {
    const result = await this.appClient.send.call(AsaStakingContractParamsFactory.getContractStats(params))
    return result.return as unknown as AsaStakingContractReturns['getContractStats()uint64[]']
  }

  /**
   * Methods to access state for the current ASAStakingContract app
   */
  state = {
    /**
     * Methods to access global state for the current ASAStakingContract app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async (): Promise<Partial<Expand<GlobalKeysState>>> => {
        const result = await this.appClient.state.global.getAll()
        return {
          asset: result.asset,
          adminAddress: result.adminAddress,
          totalStaked: result.totalStaked,
          aprBasisPoints: result.aprBasisPoints,
          lastDistributionTime: result.lastDistributionTime,
          distributionPeriodRounds: result.distributionPeriodRounds,
          minimumStake: result.minimumStake,
          rewardPool: result.rewardPool,
        }
      },
      /**
       * Get the current value of the asset key in global state
       */
      asset: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("asset")) as bigint | undefined },
      /**
       * Get the current value of the adminAddress key in global state
       */
      adminAddress: async (): Promise<string | undefined> => { return (await this.appClient.state.global.getValue("adminAddress")) as string | undefined },
      /**
       * Get the current value of the totalStaked key in global state
       */
      totalStaked: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("totalStaked")) as bigint | undefined },
      /**
       * Get the current value of the aprBasisPoints key in global state
       */
      aprBasisPoints: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("aprBasisPoints")) as bigint | undefined },
      /**
       * Get the current value of the lastDistributionTime key in global state
       */
      lastDistributionTime: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("lastDistributionTime")) as bigint | undefined },
      /**
       * Get the current value of the distributionPeriodRounds key in global state
       */
      distributionPeriodRounds: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("distributionPeriodRounds")) as bigint | undefined },
      /**
       * Get the current value of the minimumStake key in global state
       */
      minimumStake: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("minimumStake")) as bigint | undefined },
      /**
       * Get the current value of the rewardPool key in global state
       */
      rewardPool: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("rewardPool")) as bigint | undefined },
    },
    /**
     * Methods to access box state for the current ASAStakingContract app
     */
    box: {
      /**
       * Get all current keyed values from box state
       */
      getAll: async (): Promise<Partial<Expand<BoxKeysState>>> => {
        const result = await this.appClient.state.box.getAll()
        return {
        }
      },
      /**
       * Get values from the stakers map in box state
       */
      stakers: {
        /**
         * Get all current values of the stakers map in box state
         */
        getMap: async (): Promise<Map<string, UserStakeInfo>> => { return (await this.appClient.state.box.getMap("stakers")) as Map<string, UserStakeInfo> },
        /**
         * Get a current value of the stakers map by key from box state
         */
        value: async (key: string): Promise<UserStakeInfo | undefined> => { return await this.appClient.state.box.getMapValue("stakers", key) as UserStakeInfo | undefined },
      },
    },
  }

  public newGroup(): AsaStakingContractComposer {
    const client = this
    const composer = this.algorand.newGroup()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: ABIReturn | undefined) => any)> = []
    return {
      /**
       * Add a getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64) method call against the ASAStakingContract contract
       */
      getUserStakeInfo(params: CallParams<AsaStakingContractArgs['obj']['getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)'] | AsaStakingContractArgs['tuple']['getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getUserStakeInfo(params)))
        resultMappers.push((v) => client.decodeReturnValue('getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)', v))
        return this
      },
      /**
       * Add a storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void method call against the ASAStakingContract contract
       */
      storeUserStakeInfo(params: CallParams<AsaStakingContractArgs['obj']['storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void'] | AsaStakingContractArgs['tuple']['storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.storeUserStakeInfo(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a getCurrentPeriod()uint64 method call against the ASAStakingContract contract
       */
      getCurrentPeriod(params: CallParams<AsaStakingContractArgs['obj']['getCurrentPeriod()uint64'] | AsaStakingContractArgs['tuple']['getCurrentPeriod()uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getCurrentPeriod(params)))
        resultMappers.push((v) => client.decodeReturnValue('getCurrentPeriod()uint64', v))
        return this
      },
      /**
       * Add a initialize(asset,account,uint64,uint64,uint64)void method call against the ASAStakingContract contract
       */
      initialize(params: CallParams<AsaStakingContractArgs['obj']['initialize(asset,account,uint64,uint64,uint64)void'] | AsaStakingContractArgs['tuple']['initialize(asset,account,uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.initialize(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a optInToAsset()void method call against the ASAStakingContract contract
       */
      optInToAsset(params: CallParams<AsaStakingContractArgs['obj']['optInToAsset()void'] | AsaStakingContractArgs['tuple']['optInToAsset()void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.optInToAsset(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a stake()void method call against the ASAStakingContract contract
       */
      stake(params: CallParams<AsaStakingContractArgs['obj']['stake()void'] | AsaStakingContractArgs['tuple']['stake()void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.stake(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a withdraw(uint64)void method call against the ASAStakingContract contract
       */
      withdraw(params: CallParams<AsaStakingContractArgs['obj']['withdraw(uint64)void'] | AsaStakingContractArgs['tuple']['withdraw(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.withdraw(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a addRewards()void method call against the ASAStakingContract contract
       */
      addRewards(params: CallParams<AsaStakingContractArgs['obj']['addRewards()void'] | AsaStakingContractArgs['tuple']['addRewards()void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.addRewards(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a calculateUserRewardsForPeriod(account)uint64 method call against the ASAStakingContract contract
       */
      calculateUserRewardsForPeriod(params: CallParams<AsaStakingContractArgs['obj']['calculateUserRewardsForPeriod(account)uint64'] | AsaStakingContractArgs['tuple']['calculateUserRewardsForPeriod(account)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.calculateUserRewardsForPeriod(params)))
        resultMappers.push((v) => client.decodeReturnValue('calculateUserRewardsForPeriod(account)uint64', v))
        return this
      },
      /**
       * Add a calculatePendingRewards(account)uint64 method call against the ASAStakingContract contract
       */
      calculatePendingRewards(params: CallParams<AsaStakingContractArgs['obj']['calculatePendingRewards(account)uint64'] | AsaStakingContractArgs['tuple']['calculatePendingRewards(account)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.calculatePendingRewards(params)))
        resultMappers.push((v) => client.decodeReturnValue('calculatePendingRewards(account)uint64', v))
        return this
      },
      /**
       * Add a distributeRewards(address[])void method call against the ASAStakingContract contract
       */
      distributeRewards(params: CallParams<AsaStakingContractArgs['obj']['distributeRewards(address[])void'] | AsaStakingContractArgs['tuple']['distributeRewards(address[])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.distributeRewards(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a getActiveStakersCount(address[])uint64 method call against the ASAStakingContract contract
       */
      getActiveStakersCount(params: CallParams<AsaStakingContractArgs['obj']['getActiveStakersCount(address[])uint64'] | AsaStakingContractArgs['tuple']['getActiveStakersCount(address[])uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getActiveStakersCount(params)))
        resultMappers.push((v) => client.decodeReturnValue('getActiveStakersCount(address[])uint64', v))
        return this
      },
      /**
       * Add a updateAPR(uint64)void method call against the ASAStakingContract contract
       */
      updateApr(params: CallParams<AsaStakingContractArgs['obj']['updateAPR(uint64)void'] | AsaStakingContractArgs['tuple']['updateAPR(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateApr(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a updateAdmin(account)void method call against the ASAStakingContract contract
       */
      updateAdmin(params: CallParams<AsaStakingContractArgs['obj']['updateAdmin(account)void'] | AsaStakingContractArgs['tuple']['updateAdmin(account)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAdmin(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a getUserStats(account)uint64[] method call against the ASAStakingContract contract
       */
      getUserStats(params: CallParams<AsaStakingContractArgs['obj']['getUserStats(account)uint64[]'] | AsaStakingContractArgs['tuple']['getUserStats(account)uint64[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getUserStats(params)))
        resultMappers.push((v) => client.decodeReturnValue('getUserStats(account)uint64[]', v))
        return this
      },
      /**
       * Add a getContractStats()uint64[] method call against the ASAStakingContract contract
       */
      getContractStats(params: CallParams<AsaStakingContractArgs['obj']['getContractStats()uint64[]'] | AsaStakingContractArgs['tuple']['getContractStats()uint64[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getContractStats(params)))
        resultMappers.push((v) => client.decodeReturnValue('getContractStats()uint64[]', v))
        return this
      },
      /**
       * Add a emergencyWithdrawRewards(uint64)void method call against the ASAStakingContract contract
       */
      emergencyWithdrawRewards(params: CallParams<AsaStakingContractArgs['obj']['emergencyWithdrawRewards(uint64)void'] | AsaStakingContractArgs['tuple']['emergencyWithdrawRewards(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.emergencyWithdrawRewards(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a deleteUserBox(account)void method call against the ASAStakingContract contract
       */
      deleteUserBox(params: CallParams<AsaStakingContractArgs['obj']['deleteUserBox(account)void'] | AsaStakingContractArgs['tuple']['deleteUserBox(account)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.deleteUserBox(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a clear state call to the ASAStakingContract contract
       */
      clearState(params: AppClientBareCallParams) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)))
        return this
      },
      addTransaction(txn: Transaction, signer?: TransactionSigner) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer))
        return this
      },
      async composer() {
        await promiseChain
        return composer
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await (!options ? composer.simulate() : composer.simulate(options))
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      },
      async send(params?: SendParams) {
        await promiseChain
        const result = await composer.send(params)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      }
    } as unknown as AsaStakingContractComposer
  }
}
export type AsaStakingContractComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64) ABI method.
   *
   * Helper function to read user stake info from box storage
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getUserStakeInfo(params?: CallParams<AsaStakingContractArgs['obj']['getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)'] | AsaStakingContractArgs['tuple']['getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)']>): AsaStakingContractComposer<[...TReturns, AsaStakingContractReturns['getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)'] | undefined]>

  /**
   * Calls the storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void ABI method.
   *
   * Helper function to store user stake info in box storage
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  storeUserStakeInfo(params?: CallParams<AsaStakingContractArgs['obj']['storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void'] | AsaStakingContractArgs['tuple']['storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void']>): AsaStakingContractComposer<[...TReturns, AsaStakingContractReturns['storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void'] | undefined]>

  /**
   * Calls the getCurrentPeriod()uint64 ABI method.
   *
   * Calculate the current distribution period
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getCurrentPeriod(params?: CallParams<AsaStakingContractArgs['obj']['getCurrentPeriod()uint64'] | AsaStakingContractArgs['tuple']['getCurrentPeriod()uint64']>): AsaStakingContractComposer<[...TReturns, AsaStakingContractReturns['getCurrentPeriod()uint64'] | undefined]>

  /**
   * Calls the initialize(asset,account,uint64,uint64,uint64)void ABI method.
   *
   * Initialize the contract with the ASA token ID and other parameters
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  initialize(params?: CallParams<AsaStakingContractArgs['obj']['initialize(asset,account,uint64,uint64,uint64)void'] | AsaStakingContractArgs['tuple']['initialize(asset,account,uint64,uint64,uint64)void']>): AsaStakingContractComposer<[...TReturns, AsaStakingContractReturns['initialize(asset,account,uint64,uint64,uint64)void'] | undefined]>

  /**
   * Calls the optInToAsset()void ABI method.
   *
   * Opt the contract into the ASA
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  optInToAsset(params?: CallParams<AsaStakingContractArgs['obj']['optInToAsset()void'] | AsaStakingContractArgs['tuple']['optInToAsset()void']>): AsaStakingContractComposer<[...TReturns, AsaStakingContractReturns['optInToAsset()void'] | undefined]>

  /**
   * Calls the stake()void ABI method.
   *
  * Stake tokens
  Requires a companion ASA transfer transaction

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  stake(params?: CallParams<AsaStakingContractArgs['obj']['stake()void'] | AsaStakingContractArgs['tuple']['stake()void']>): AsaStakingContractComposer<[...TReturns, AsaStakingContractReturns['stake()void'] | undefined]>

  /**
   * Calls the withdraw(uint64)void ABI method.
   *
   * Withdraw staked tokens
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  withdraw(params?: CallParams<AsaStakingContractArgs['obj']['withdraw(uint64)void'] | AsaStakingContractArgs['tuple']['withdraw(uint64)void']>): AsaStakingContractComposer<[...TReturns, AsaStakingContractReturns['withdraw(uint64)void'] | undefined]>

  /**
   * Calls the addRewards()void ABI method.
   *
  * Add rewards to the reward pool
  Only the admin can call this
  Requires a companion ASA transfer transaction with the rewards

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addRewards(params?: CallParams<AsaStakingContractArgs['obj']['addRewards()void'] | AsaStakingContractArgs['tuple']['addRewards()void']>): AsaStakingContractComposer<[...TReturns, AsaStakingContractReturns['addRewards()void'] | undefined]>

  /**
   * Calls the calculateUserRewardsForPeriod(account)uint64 ABI method.
   *
  * Calculate rewards for a specific user for a given period
  This calculates rewards per distribution period

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  calculateUserRewardsForPeriod(params?: CallParams<AsaStakingContractArgs['obj']['calculateUserRewardsForPeriod(account)uint64'] | AsaStakingContractArgs['tuple']['calculateUserRewardsForPeriod(account)uint64']>): AsaStakingContractComposer<[...TReturns, AsaStakingContractReturns['calculateUserRewardsForPeriod(account)uint64'] | undefined]>

  /**
   * Calls the calculatePendingRewards(account)uint64 ABI method.
   *
   * Calculate pending rewards for a user since their last claim
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  calculatePendingRewards(params?: CallParams<AsaStakingContractArgs['obj']['calculatePendingRewards(account)uint64'] | AsaStakingContractArgs['tuple']['calculatePendingRewards(account)uint64']>): AsaStakingContractComposer<[...TReturns, AsaStakingContractReturns['calculatePendingRewards(account)uint64'] | undefined]>

  /**
   * Calls the distributeRewards(address[])void ABI method.
   *
  * Distribute and compound rewards for multiple stakers
  This method is designed to be called by a cron job on a daily basis
  Only admin can call this method

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  distributeRewards(params?: CallParams<AsaStakingContractArgs['obj']['distributeRewards(address[])void'] | AsaStakingContractArgs['tuple']['distributeRewards(address[])void']>): AsaStakingContractComposer<[...TReturns, AsaStakingContractReturns['distributeRewards(address[])void'] | undefined]>

  /**
   * Calls the getActiveStakersCount(address[])uint64 ABI method.
   *
  * Get all non-zero stakers count (for monitoring purposes)
  Note: This doesn't return the actual addresses due to box iteration limitations

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getActiveStakersCount(params?: CallParams<AsaStakingContractArgs['obj']['getActiveStakersCount(address[])uint64'] | AsaStakingContractArgs['tuple']['getActiveStakersCount(address[])uint64']>): AsaStakingContractComposer<[...TReturns, AsaStakingContractReturns['getActiveStakersCount(address[])uint64'] | undefined]>

  /**
   * Calls the updateAPR(uint64)void ABI method.
   *
  * Update the APR basis points
  Only the admin can call this

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateApr(params?: CallParams<AsaStakingContractArgs['obj']['updateAPR(uint64)void'] | AsaStakingContractArgs['tuple']['updateAPR(uint64)void']>): AsaStakingContractComposer<[...TReturns, AsaStakingContractReturns['updateAPR(uint64)void'] | undefined]>

  /**
   * Calls the updateAdmin(account)void ABI method.
   *
  * Update the admin address
  Only the current admin can call this

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateAdmin(params?: CallParams<AsaStakingContractArgs['obj']['updateAdmin(account)void'] | AsaStakingContractArgs['tuple']['updateAdmin(account)void']>): AsaStakingContractComposer<[...TReturns, AsaStakingContractReturns['updateAdmin(account)void'] | undefined]>

  /**
   * Calls the getUserStats(account)uint64[] ABI method.
   *
   * Get current staking statistics for a user
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getUserStats(params?: CallParams<AsaStakingContractArgs['obj']['getUserStats(account)uint64[]'] | AsaStakingContractArgs['tuple']['getUserStats(account)uint64[]']>): AsaStakingContractComposer<[...TReturns, AsaStakingContractReturns['getUserStats(account)uint64[]'] | undefined]>

  /**
   * Calls the getContractStats()uint64[] ABI method.
   *
   * Get contract global statistics
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getContractStats(params?: CallParams<AsaStakingContractArgs['obj']['getContractStats()uint64[]'] | AsaStakingContractArgs['tuple']['getContractStats()uint64[]']>): AsaStakingContractComposer<[...TReturns, AsaStakingContractReturns['getContractStats()uint64[]'] | undefined]>

  /**
   * Calls the emergencyWithdrawRewards(uint64)void ABI method.
   *
   * Emergency withdraw rewards from pool (admin only)
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  emergencyWithdrawRewards(params?: CallParams<AsaStakingContractArgs['obj']['emergencyWithdrawRewards(uint64)void'] | AsaStakingContractArgs['tuple']['emergencyWithdrawRewards(uint64)void']>): AsaStakingContractComposer<[...TReturns, AsaStakingContractReturns['emergencyWithdrawRewards(uint64)void'] | undefined]>

  /**
   * Calls the deleteUserBox(account)void ABI method.
   *
  * Delete a user's box (for cleanup)
  Can only be called by the box owner or admin

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  deleteUserBox(params?: CallParams<AsaStakingContractArgs['obj']['deleteUserBox(account)void'] | AsaStakingContractArgs['tuple']['deleteUserBox(account)void']>): AsaStakingContractComposer<[...TReturns, AsaStakingContractReturns['deleteUserBox(account)void'] | undefined]>

  /**
   * Makes a clear_state call to an existing instance of the ASAStakingContract smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(params?: AppClientBareCallParams): AsaStakingContractComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn A transaction to add to the transaction group
   * @param signer The optional signer to use when signing this transaction.
   */
  addTransaction(txn: Transaction, signer?: TransactionSigner): AsaStakingContractComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  composer(): Promise<TransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<AsaStakingContractComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  simulate(options: SkipSignaturesSimulateOptions): Promise<AsaStakingContractComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  simulate(options: RawSimulateOptions): Promise<AsaStakingContractComposerResults<TReturns> & { simulateResponse: SimulateResponse }>
  /**
   * Sends the transaction group to the network and returns the results
   */
  send(params?: SendParams): Promise<AsaStakingContractComposerResults<TReturns>>
}
export type AsaStakingContractComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
  returns: TReturns
}>

