#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 4 8
    bytecblock "totalStaked" "assetId" "adminAddress" "lastDistributionTime" "aprBasisPoints" "minimumStake" 0x151f7c75 "distributionPeriodSeconds" "stakers"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:46
    // public assetId = GlobalState<uint64>({ initialValue: 0 })
    bytec_1 // "assetId"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "totalStaked"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:49
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    bytec 4 // "aprBasisPoints"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:50
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    bytec_3 // "lastDistributionTime"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:51
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    bytec 7 // "distributionPeriodSeconds"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:52
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    bytec 5 // "minimumStake"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txn NumAppArgs
    bz main_bare_routing@22
    pushbytess 0xa9b56b38 0x124ba026 0x83786954 0x4184bb17 0x9ffd3e53 0x0890bd58 0x21f1ddff 0xb0a93807 0x411cec23 0xa5ae6bd1 0x1e6612bd 0x82ab1ec4 0x15766b09 0xbfe31564 0xdc9a2a05 // method "getUserBoxName(account)address", method "getUserStakeInfo(account)(uint64,uint64,uint64)", method "storeUserStakeInfo(account,(uint64,uint64,uint64))void", method "initialize(uint64,account,uint64,uint64,uint64)void", method "optInToAsset()void", method "stake()void", method "withdraw(uint64)void", method "distributeRewards()void", method "calculateUserRewards(account)uint64", method "claimRewards()void", method "updateAPR(uint64)void", method "updateAdmin(account)void", method "getUserStats(account)uint64[]", method "getContractStats()uint64[]", method "deleteUserBox(account)void"
    txna ApplicationArgs 0
    match main_getUserBoxName_route@5 main_getUserStakeInfo_route@6 main_storeUserStakeInfo_route@7 main_initialize_route@8 main_optInToAsset_route@9 main_stake_route@10 main_withdraw_route@11 main_distributeRewards_route@12 main_calculateUserRewards_route@13 main_claimRewards_route@14 main_updateAPR_route@15 main_updateAdmin_route@16 main_getUserStats_route@17 main_getContractStats_route@18 main_deleteUserBox_route@19

main_after_if_else@26:
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    intc_0 // 0
    return

main_deleteUserBox_route@19:
    // smart_contracts/staking/contract.algo.ts:403
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:403
    // @abimethod()
    callsub deleteUserBox
    intc_1 // 1
    return

main_getContractStats_route@18:
    // smart_contracts/staking/contract.algo.ts:385
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getContractStats
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getUserStats_route@17:
    // smart_contracts/staking/contract.algo.ts:368
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:368
    // @abimethod({ readonly: true })
    callsub getUserStats
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_updateAdmin_route@16:
    // smart_contracts/staking/contract.algo.ts:355
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:355
    // @abimethod()
    callsub updateAdmin
    intc_1 // 1
    return

main_updateAPR_route@15:
    // smart_contracts/staking/contract.algo.ts:341
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/staking/contract.algo.ts:341
    // @abimethod()
    callsub updateAPR
    intc_1 // 1
    return

main_claimRewards_route@14:
    // smart_contracts/staking/contract.algo.ts:312
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub claimRewards
    intc_1 // 1
    return

main_calculateUserRewards_route@13:
    // smart_contracts/staking/contract.algo.ts:268
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:268
    // @abimethod({ readonly: true })
    callsub calculateUserRewards
    itob
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_distributeRewards_route@12:
    // smart_contracts/staking/contract.algo.ts:235
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub distributeRewards
    intc_1 // 1
    return

main_withdraw_route@11:
    // smart_contracts/staking/contract.algo.ts:191
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/staking/contract.algo.ts:191
    // @abimethod()
    callsub withdraw
    intc_1 // 1
    return

main_stake_route@10:
    // smart_contracts/staking/contract.algo.ts:147
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub stake
    intc_1 // 1
    return

main_optInToAsset_route@9:
    // smart_contracts/staking/contract.algo.ts:125
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub optInToAsset
    intc_1 // 1
    return

main_initialize_route@8:
    // smart_contracts/staking/contract.algo.ts:98
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txnas Accounts
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    // smart_contracts/staking/contract.algo.ts:98
    // @abimethod()
    callsub initialize
    intc_1 // 1
    return

main_storeUserStakeInfo_route@7:
    // smart_contracts/staking/contract.algo.ts:88
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    // smart_contracts/staking/contract.algo.ts:88
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    callsub storeUserStakeInfo
    pop
    intc_1 // 1
    return

main_getUserStakeInfo_route@6:
    // smart_contracts/staking/contract.algo.ts:68
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:68
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    callsub getUserStakeInfo
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getUserBoxName_route@5:
    // smart_contracts/staking/contract.algo.ts:60
    // public getUserBoxName(userAddress: Account): arc4.Address {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:60
    // public getUserBoxName(userAddress: Account): arc4.Address {
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@22:
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txn OnCompletion
    bnz main_after_if_else@26
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getUserStakeInfo(userAddress: bytes) -> bytes:
getUserStakeInfo:
    // smart_contracts/staking/contract.algo.ts:68
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    proto 1 1
    // smart_contracts/staking/contract.algo.ts:54
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    bytec 8 // "stakers"
    // smart_contracts/staking/contract.algo.ts:69
    // const userBox = this.stakers(userAddress)
    frame_dig -1
    // smart_contracts/staking/contract.algo.ts:54
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    concat
    // smart_contracts/staking/contract.algo.ts:69
    // const userBox = this.stakers(userAddress)
    dup
    // smart_contracts/staking/contract.algo.ts:72
    // if (userBox.exists) {
    box_len
    bury 1
    bz getUserStakeInfo_else_body@2
    // smart_contracts/staking/contract.algo.ts:73
    // const boxData = userBox.value.copy()
    frame_dig 0
    box_get
    assert // Box must have value
    // smart_contracts/staking/contract.algo.ts:75
    // return boxData
    swap
    retsub

getUserStakeInfo_else_body@2:
    // smart_contracts/staking/contract.algo.ts:77-81
    // return new UserStakeInfo({
    //   stakedAmount: new arc4.UintN64(0),
    //   lastStakeTime: new arc4.UintN64(0),
    //   totalRewardsEarned: new arc4.UintN64(0),
    // })
    pushbytes 0x000000000000000000000000000000000000000000000000
    swap
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.storeUserStakeInfo(userAddress: bytes, stakeInfo: bytes) -> bytes:
storeUserStakeInfo:
    // smart_contracts/staking/contract.algo.ts:88
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    proto 2 1
    // smart_contracts/staking/contract.algo.ts:54
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    bytec 8 // "stakers"
    // smart_contracts/staking/contract.algo.ts:89
    // const userBox = this.stakers(userAddress)
    frame_dig -2
    // smart_contracts/staking/contract.algo.ts:54
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    concat
    // smart_contracts/staking/contract.algo.ts:89
    // const userBox = this.stakers(userAddress)
    dup
    // smart_contracts/staking/contract.algo.ts:90
    // if (userBox.exists) {
    box_len
    bury 1
    bz storeUserStakeInfo_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:91
    // userBox.value = stakeInfo.copy()
    frame_dig 0
    frame_dig -1
    box_put

storeUserStakeInfo_after_if_else@2:
    frame_dig -1
    swap
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.initialize(assetId: uint64, adminAddress: bytes, aprBasisPoints: uint64, distributionPeriodSeconds: uint64, minimumStake: uint64) -> void:
initialize:
    // smart_contracts/staking/contract.algo.ts:98-105
    // @abimethod()
    // public initialize(
    //   assetId: uint64,
    //   adminAddress: Account,
    //   aprBasisPoints: uint64,
    //   distributionPeriodSeconds: uint64,
    //   minimumStake: uint64,
    // ): void {
    proto 5 0
    // smart_contracts/staking/contract.algo.ts:46
    // public assetId = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_1 // "assetId"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:107
    // assert(this.assetId.value === 0, 'Already initialized')
    !
    assert // Already initialized
    // smart_contracts/staking/contract.algo.ts:110
    // assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can initialize
    // smart_contracts/staking/contract.algo.ts:46
    // public assetId = GlobalState<uint64>({ initialValue: 0 })
    bytec_1 // "assetId"
    // smart_contracts/staking/contract.algo.ts:113
    // this.assetId.value = assetId
    frame_dig -5
    app_global_put
    // smart_contracts/staking/contract.algo.ts:47
    // public adminAddress = GlobalState<Account>()
    bytec_2 // "adminAddress"
    // smart_contracts/staking/contract.algo.ts:114
    // this.adminAddress.value = adminAddress
    frame_dig -4
    app_global_put
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "totalStaked"
    // smart_contracts/staking/contract.algo.ts:115
    // this.totalStaked.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:49
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    bytec 4 // "aprBasisPoints"
    // smart_contracts/staking/contract.algo.ts:116
    // this.aprBasisPoints.value = aprBasisPoints
    frame_dig -3
    app_global_put
    // smart_contracts/staking/contract.algo.ts:50
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    bytec_3 // "lastDistributionTime"
    // smart_contracts/staking/contract.algo.ts:117
    // this.lastDistributionTime.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/staking/contract.algo.ts:51
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    bytec 7 // "distributionPeriodSeconds"
    // smart_contracts/staking/contract.algo.ts:118
    // this.distributionPeriodSeconds.value = distributionPeriodSeconds
    frame_dig -2
    app_global_put
    // smart_contracts/staking/contract.algo.ts:52
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    bytec 5 // "minimumStake"
    // smart_contracts/staking/contract.algo.ts:119
    // this.minimumStake.value = minimumStake
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.optInToAsset() -> void:
optInToAsset:
    // smart_contracts/staking/contract.algo.ts:125-126
    // @abimethod()
    // public optInToAsset(): void {
    proto 0 0
    // smart_contracts/staking/contract.algo.ts:47
    // public adminAddress = GlobalState<Account>()
    intc_0 // 0
    bytec_2 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:129
    // assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    txn Sender
    global CreatorAddress
    ==
    bnz optInToAsset_bool_true@2
    txn Sender
    frame_dig 0
    ==
    bz optInToAsset_bool_false@3

optInToAsset_bool_true@2:
    intc_1 // 1

optInToAsset_bool_merge@4:
    // smart_contracts/staking/contract.algo.ts:129
    // assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    assert // Only creator or admin can opt in
    // smart_contracts/staking/contract.algo.ts:46
    // public assetId = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_1 // "assetId"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:133-140
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: assetId,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/staking/contract.algo.ts:135
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    swap
    itxn_field XferAsset
    // smart_contracts/staking/contract.algo.ts:136
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/staking/contract.algo.ts:133-139
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: assetId,
    //     fee: 1000,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/contract.algo.ts:138
    // fee: 1000,
    pushint 1000 // 1000
    itxn_field Fee
    // smart_contracts/staking/contract.algo.ts:133-140
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: assetId,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_submit
    retsub

optInToAsset_bool_false@3:
    intc_0 // 0
    b optInToAsset_bool_merge@4


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.stake() -> void:
stake:
    // smart_contracts/staking/contract.algo.ts:147-148
    // @abimethod()
    // public stake(): void {
    proto 0 0
    // smart_contracts/staking/contract.algo.ts:46
    // public assetId = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_1 // "assetId"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:152
    // assert(asset.balance(Global.currentApplicationAddress) >= 0, 'Contract not opted in to ASA')
    global CurrentApplicationAddress
    dig 1
    asset_holding_get AssetBalance
    bury 1
    assert // account opted into asset
    // smart_contracts/staking/contract.algo.ts:155
    // assert(Global.groupSize === 2, 'Expected 2 txns in group')
    global GroupSize
    pushint 2 // 2
    ==
    assert // Expected 2 txns in group
    // smart_contracts/staking/contract.algo.ts:158
    // const xferTxn = gtxn.AssetTransferTxn(1)
    intc_1 // 1
    gtxns TypeEnum
    dup
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/staking/contract.algo.ts:159
    // assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 1 must be asset transfer')
    intc_2 // 4
    ==
    assert // Transaction 1 must be asset transfer
    // smart_contracts/staking/contract.algo.ts:158
    // const xferTxn = gtxn.AssetTransferTxn(1)
    intc_1 // 1
    // smart_contracts/staking/contract.algo.ts:160
    // assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // Asset transfer must be to contract
    // smart_contracts/staking/contract.algo.ts:158
    // const xferTxn = gtxn.AssetTransferTxn(1)
    intc_1 // 1
    // smart_contracts/staking/contract.algo.ts:161
    // assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    gtxns AssetAmount
    dup
    cover 2
    assert // Must stake non-zero amount
    // smart_contracts/staking/contract.algo.ts:158
    // const xferTxn = gtxn.AssetTransferTxn(1)
    intc_1 // 1
    // smart_contracts/staking/contract.algo.ts:162
    // assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    gtxns XferAsset
    ==
    assert // Incorrect asset ID
    // smart_contracts/staking/contract.algo.ts:52
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 5 // "minimumStake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:169
    // const senderAddress = Txn.sender
    txn Sender
    dup
    // smart_contracts/staking/contract.algo.ts:170
    // const stakeInfo = this.getUserStakeInfo(senderAddress)
    callsub getUserStakeInfo
    dup
    // smart_contracts/staking/contract.algo.ts:173
    // if (stakeInfo.stakedAmount.native === 0) {
    intc_0 // 0
    extract_uint64
    dup
    bnz stake_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:174
    // assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    frame_dig 0
    frame_dig 1
    >=
    assert // Initial stake below minimum

stake_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:178
    // stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    frame_dig 4
    frame_dig 0
    dup
    cover 2
    +
    itob
    frame_dig 3
    swap
    replace2 0
    // smart_contracts/staking/contract.algo.ts:179
    // stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    global LatestTimestamp
    itob
    replace2 8
    // smart_contracts/staking/contract.algo.ts:182
    // this.storeUserStakeInfo(senderAddress, stakeInfo)
    frame_dig 2
    swap
    callsub storeUserStakeInfo
    pop
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:185
    // this.totalStaked.value = this.totalStaked.value + stakeAmount
    +
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "totalStaked"
    // smart_contracts/staking/contract.algo.ts:185
    // this.totalStaked.value = this.totalStaked.value + stakeAmount
    swap
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.withdraw(amount: uint64) -> void:
withdraw:
    // smart_contracts/staking/contract.algo.ts:191-192
    // @abimethod()
    // public withdraw(amount: uint64): void {
    proto 1 0
    // smart_contracts/staking/contract.algo.ts:193
    // const senderAddress = Txn.sender
    txn Sender
    dup
    // smart_contracts/staking/contract.algo.ts:194
    // const stakeInfo = this.getUserStakeInfo(senderAddress)
    callsub getUserStakeInfo
    dup
    // smart_contracts/staking/contract.algo.ts:197
    // assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    intc_0 // 0
    extract_uint64
    dupn 2
    assert // No stake found
    // smart_contracts/staking/contract.algo.ts:198
    // assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    frame_dig -1
    dig 1
    <=
    assert // Withdrawal amount exceeds stake
    // smart_contracts/staking/contract.algo.ts:199
    // assert(amount > 0, 'Withdrawal amount must be positive')
    frame_dig -1
    assert // Withdrawal amount must be positive
    // smart_contracts/staking/contract.algo.ts:203
    // if (amount < stakeInfo.stakedAmount.native) {
    frame_dig -1
    >
    bz withdraw_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:204
    // const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    frame_dig 2
    frame_dig -1
    -
    // smart_contracts/staking/contract.algo.ts:52
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 5 // "minimumStake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:206
    // assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    >=
    assert // Remaining stake would be below minimum

withdraw_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:210
    // stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    frame_dig 2
    frame_dig -1
    -
    itob
    frame_dig 1
    swap
    replace2 0
    // smart_contracts/staking/contract.algo.ts:213
    // this.storeUserStakeInfo(senderAddress, stakeInfo)
    frame_dig 0
    swap
    callsub storeUserStakeInfo
    pop
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:216
    // this.totalStaked.value = this.totalStaked.value - amount
    frame_dig -1
    -
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "totalStaked"
    // smart_contracts/staking/contract.algo.ts:216
    // this.totalStaked.value = this.totalStaked.value - amount
    swap
    app_global_put
    // smart_contracts/staking/contract.algo.ts:46
    // public assetId = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_1 // "assetId"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:220-227
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     assetAmount: amount,
    //     xferAsset: assetId,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/staking/contract.algo.ts:222
    // assetReceiver: Txn.sender,
    txn Sender
    swap
    itxn_field XferAsset
    frame_dig -1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/staking/contract.algo.ts:220-226
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     assetAmount: amount,
    //     xferAsset: assetId,
    //     fee: 1000,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/contract.algo.ts:225
    // fee: 1000,
    pushint 1000 // 1000
    itxn_field Fee
    // smart_contracts/staking/contract.algo.ts:220-227
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     assetAmount: amount,
    //     xferAsset: assetId,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.distributeRewards() -> void:
distributeRewards:
    // smart_contracts/staking/contract.algo.ts:47
    // public adminAddress = GlobalState<Account>()
    intc_0 // 0
    bytec_2 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:239
    // assert(Txn.sender === adminAddr, 'Only admin can distribute rewards')
    txn Sender
    ==
    assert // Only admin can distribute rewards
    // smart_contracts/staking/contract.algo.ts:242
    // assert(Global.groupSize === 2, 'Expected 2 txns in group')
    global GroupSize
    pushint 2 // 2
    ==
    assert // Expected 2 txns in group
    // smart_contracts/staking/contract.algo.ts:46
    // public assetId = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_1 // "assetId"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:246
    // const xferTxn = gtxn.AssetTransferTxn(1)
    intc_1 // 1
    gtxns TypeEnum
    dup
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/staking/contract.algo.ts:247
    // assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 1 must be asset transfer')
    intc_2 // 4
    ==
    assert // Transaction 1 must be asset transfer
    // smart_contracts/staking/contract.algo.ts:246
    // const xferTxn = gtxn.AssetTransferTxn(1)
    intc_1 // 1
    // smart_contracts/staking/contract.algo.ts:248
    // assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // Asset transfer must be to contract
    // smart_contracts/staking/contract.algo.ts:246
    // const xferTxn = gtxn.AssetTransferTxn(1)
    intc_1 // 1
    // smart_contracts/staking/contract.algo.ts:249
    // assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    gtxns AssetAmount
    assert // Must provide non-zero rewards
    // smart_contracts/staking/contract.algo.ts:246
    // const xferTxn = gtxn.AssetTransferTxn(1)
    intc_1 // 1
    // smart_contracts/staking/contract.algo.ts:250
    // assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    gtxns XferAsset
    ==
    assert // Incorrect asset ID
    // smart_contracts/staking/contract.algo.ts:253
    // const currentTime = Global.latestTimestamp
    global LatestTimestamp
    // smart_contracts/staking/contract.algo.ts:50
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_3 // "lastDistributionTime"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:51
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 7 // "distributionPeriodSeconds"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:256
    // assert(currentTime >= lastDistributionTime + periodSeconds, 'Distribution period has not passed')
    +
    dig 1
    <=
    assert // Distribution period has not passed
    // smart_contracts/staking/contract.algo.ts:50
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    bytec_3 // "lastDistributionTime"
    // smart_contracts/staking/contract.algo.ts:259
    // this.lastDistributionTime.value = currentTime
    swap
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.calculateUserRewards(userAddress: bytes) -> uint64:
calculateUserRewards:
    // smart_contracts/staking/contract.algo.ts:268-269
    // @abimethod({ readonly: true })
    // public calculateUserRewards(userAddress: Account): uint64 {
    proto 1 1
    intc_0 // 0
    pushbytes ""
    // smart_contracts/staking/contract.algo.ts:49
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 4 // "aprBasisPoints"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:274
    // if (totalStaked === 0) {
    bnz calculateUserRewards_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:275
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

calculateUserRewards_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:280
    // const stakeInfo = this.getUserStakeInfo(userAddr)
    frame_dig -1
    callsub getUserStakeInfo
    dup
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:283
    // if (stakeInfo.stakedAmount.native === 0) {
    intc_0 // 0
    extract_uint64
    dup
    frame_bury 1
    bnz calculateUserRewards_after_if_else@4
    // smart_contracts/staking/contract.algo.ts:284
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

calculateUserRewards_after_if_else@4:
    // smart_contracts/staking/contract.algo.ts:50
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_3 // "lastDistributionTime"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:295
    // if (lastStakeTime.native + 86400 > lastDistributionTime) {
    frame_dig 0
    // smart_contracts/staking/contract.algo.ts:289
    // const lastStakeTime = stakeInfo.lastStakeTime
    intc_3 // 8
    // smart_contracts/staking/contract.algo.ts:295
    // if (lastStakeTime.native + 86400 > lastDistributionTime) {
    extract_uint64
    pushint 86400 // 86400
    +
    <
    bz calculateUserRewards_after_if_else@6
    // smart_contracts/staking/contract.algo.ts:296
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

calculateUserRewards_after_if_else@6:
    // smart_contracts/staking/contract.algo.ts:302
    // const dailyRateBasisPoints: uint64 = ((apr * 100) / 365) * 10000
    frame_dig 2
    pushint 100 // 100
    *
    pushint 365 // 365
    /
    pushint 10000 // 10000
    *
    // smart_contracts/staking/contract.algo.ts:303
    // const reward: uint64 = (userStake.native * dailyRateBasisPoints) / 10000
    frame_dig 1
    *
    pushint 10000 // 10000
    /
    // smart_contracts/staking/contract.algo.ts:305
    // return reward
    frame_bury 0
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.claimRewards() -> void:
claimRewards:
    // smart_contracts/staking/contract.algo.ts:314
    // const senderAddress = Txn.sender
    txn Sender
    // smart_contracts/staking/contract.algo.ts:315
    // const stakeInfo = this.getUserStakeInfo(senderAddress)
    dup
    callsub getUserStakeInfo
    // smart_contracts/staking/contract.algo.ts:318
    // assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    dup
    intc_0 // 0
    extract_uint64
    dup
    assert // No stake found
    // smart_contracts/staking/contract.algo.ts:321
    // const reward = this.calculateUserRewards(Txn.sender)
    txn Sender
    callsub calculateUserRewards
    // smart_contracts/staking/contract.algo.ts:322
    // assert(reward > 0, 'No rewards to claim')
    dup
    assert // No rewards to claim
    // smart_contracts/staking/contract.algo.ts:325
    // stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + reward)
    swap
    dig 1
    +
    itob
    uncover 2
    swap
    replace2 0
    // smart_contracts/staking/contract.algo.ts:328
    // stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + reward)
    dup
    pushint 16 // 16
    extract_uint64
    dig 2
    +
    itob
    replace2 16
    // smart_contracts/staking/contract.algo.ts:331
    // this.storeUserStakeInfo(senderAddress, stakeInfo)
    uncover 2
    swap
    callsub storeUserStakeInfo
    pop
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:334
    // this.totalStaked.value = this.totalStaked.value + reward
    +
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "totalStaked"
    // smart_contracts/staking/contract.algo.ts:334
    // this.totalStaked.value = this.totalStaked.value + reward
    swap
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.updateAPR(newAprBasisPoints: uint64) -> void:
updateAPR:
    // smart_contracts/staking/contract.algo.ts:341-342
    // @abimethod()
    // public updateAPR(newAprBasisPoints: uint64): void {
    proto 1 0
    // smart_contracts/staking/contract.algo.ts:47
    // public adminAddress = GlobalState<Account>()
    intc_0 // 0
    bytec_2 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:345
    // assert(Txn.sender === adminAddr, 'Only admin can update APR')
    txn Sender
    ==
    assert // Only admin can update APR
    // smart_contracts/staking/contract.algo.ts:49
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    bytec 4 // "aprBasisPoints"
    // smart_contracts/staking/contract.algo.ts:348
    // this.aprBasisPoints.value = newAprBasisPoints
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.updateAdmin(newAdminAddress: bytes) -> void:
updateAdmin:
    // smart_contracts/staking/contract.algo.ts:355-356
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    proto 1 0
    // smart_contracts/staking/contract.algo.ts:47
    // public adminAddress = GlobalState<Account>()
    intc_0 // 0
    bytec_2 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:359
    // assert(Txn.sender === adminAddr, 'Only admin can update admin')
    txn Sender
    ==
    assert // Only admin can update admin
    // smart_contracts/staking/contract.algo.ts:47
    // public adminAddress = GlobalState<Account>()
    bytec_2 // "adminAddress"
    // smart_contracts/staking/contract.algo.ts:362
    // this.adminAddress.value = newAdminAddress
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getUserStats(userAddress: bytes) -> bytes:
getUserStats:
    // smart_contracts/staking/contract.algo.ts:368-369
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    proto 1 1
    // smart_contracts/staking/contract.algo.ts:371
    // const stakeInfo = this.getUserStakeInfo(userAddr)
    frame_dig -1
    callsub getUserStakeInfo
    // smart_contracts/staking/contract.algo.ts:373
    // stakeInfo.stakedAmount.native,
    dup
    intc_0 // 0
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:374
    // stakeInfo.lastStakeTime.native,
    dig 1
    intc_3 // 8
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:375
    // stakeInfo.totalRewardsEarned.native,
    uncover 2
    pushint 16 // 16
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:376
    // this.calculateUserRewards(userAddress),
    frame_dig -1
    callsub calculateUserRewards
    // smart_contracts/staking/contract.algo.ts:373
    // stakeInfo.stakedAmount.native,
    uncover 3
    itob
    // smart_contracts/staking/contract.algo.ts:374
    // stakeInfo.lastStakeTime.native,
    uncover 3
    itob
    // smart_contracts/staking/contract.algo.ts:373-376
    // stakeInfo.stakedAmount.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // this.calculateUserRewards(userAddress),
    concat
    // smart_contracts/staking/contract.algo.ts:375
    // stakeInfo.totalRewardsEarned.native,
    uncover 2
    itob
    // smart_contracts/staking/contract.algo.ts:373-376
    // stakeInfo.stakedAmount.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // this.calculateUserRewards(userAddress),
    concat
    // smart_contracts/staking/contract.algo.ts:376
    // this.calculateUserRewards(userAddress),
    swap
    itob
    // smart_contracts/staking/contract.algo.ts:373-376
    // stakeInfo.stakedAmount.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // this.calculateUserRewards(userAddress),
    concat
    dup
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:379
    // return result
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getContractStats() -> bytes:
getContractStats:
    // smart_contracts/staking/contract.algo.ts:46
    // public assetId = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_1 // "assetId"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:49
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 4 // "aprBasisPoints"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:50
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_3 // "lastDistributionTime"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:51
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 7 // "distributionPeriodSeconds"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:52
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 5 // "minimumStake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:46
    // public assetId = GlobalState<uint64>({ initialValue: 0 })
    uncover 5
    itob
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    uncover 5
    itob
    // smart_contracts/staking/contract.algo.ts:46-52
    // public assetId = GlobalState<uint64>({ initialValue: 0 })
    // public adminAddress = GlobalState<Account>()
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    concat
    // smart_contracts/staking/contract.algo.ts:49
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    uncover 4
    itob
    // smart_contracts/staking/contract.algo.ts:46-52
    // public assetId = GlobalState<uint64>({ initialValue: 0 })
    // public adminAddress = GlobalState<Account>()
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    concat
    // smart_contracts/staking/contract.algo.ts:50
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    uncover 3
    itob
    // smart_contracts/staking/contract.algo.ts:46-52
    // public assetId = GlobalState<uint64>({ initialValue: 0 })
    // public adminAddress = GlobalState<Account>()
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    concat
    // smart_contracts/staking/contract.algo.ts:51
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    uncover 2
    itob
    // smart_contracts/staking/contract.algo.ts:46-52
    // public assetId = GlobalState<uint64>({ initialValue: 0 })
    // public adminAddress = GlobalState<Account>()
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    concat
    // smart_contracts/staking/contract.algo.ts:52
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    swap
    itob
    // smart_contracts/staking/contract.algo.ts:46-52
    // public assetId = GlobalState<uint64>({ initialValue: 0 })
    // public adminAddress = GlobalState<Account>()
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    concat
    dup
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:396
    // return result
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.deleteUserBox(userAddress: bytes) -> void:
deleteUserBox:
    // smart_contracts/staking/contract.algo.ts:403-404
    // @abimethod()
    // public deleteUserBox(userAddress: Account): void {
    proto 1 0
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:47
    // public adminAddress = GlobalState<Account>()
    dup
    bytec_2 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:409
    // assert(Txn.sender === boxOwner || Txn.sender === adminAddr, 'Only box owner or admin can delete box')
    txn Sender
    frame_dig -1
    ==
    bnz deleteUserBox_bool_true@2
    txn Sender
    frame_dig 1
    ==
    bz deleteUserBox_bool_false@3

deleteUserBox_bool_true@2:
    intc_1 // 1

deleteUserBox_bool_merge@4:
    // smart_contracts/staking/contract.algo.ts:409
    // assert(Txn.sender === boxOwner || Txn.sender === adminAddr, 'Only box owner or admin can delete box')
    assert // Only box owner or admin can delete box
    // smart_contracts/staking/contract.algo.ts:413
    // const stakeInfo = this.getUserStakeInfo(userAddr)
    frame_dig -1
    callsub getUserStakeInfo
    // smart_contracts/staking/contract.algo.ts:414
    // assert(stakeInfo.stakedAmount.native === 0, 'User still has active stake')
    intc_0 // 0
    extract_uint64
    !
    assert // User still has active stake
    // smart_contracts/staking/contract.algo.ts:54
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    bytec 8 // "stakers"
    // smart_contracts/staking/contract.algo.ts:417
    // const userBox = this.stakers(userAddress)
    frame_dig -1
    // smart_contracts/staking/contract.algo.ts:54
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    concat
    // smart_contracts/staking/contract.algo.ts:417
    // const userBox = this.stakers(userAddress)
    dup
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:418
    // if (userBox.exists) {
    box_len
    bury 1
    bz deleteUserBox_after_if_else@6
    // smart_contracts/staking/contract.algo.ts:419
    // userBox.delete()
    frame_dig 0
    box_del
    pop

deleteUserBox_after_if_else@6:
    retsub

deleteUserBox_bool_false@3:
    intc_0 // 0
    b deleteUserBox_bool_merge@4
