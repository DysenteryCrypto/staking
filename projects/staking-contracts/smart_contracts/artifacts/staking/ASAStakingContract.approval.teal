#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 4 32
    bytecblock "rewardPool" "asset" "adminAddress" "totalStaked" 0x151f7c75 "aprBasisPoints" "distributionPeriodRounds" "minimumStake" "lastDistributionTime" "stakers"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:54
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    bytec_1 // "asset"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:55
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    bytec_2 // "adminAddress"
    global ZeroAddress
    app_global_put
    // smart_contracts/staking/contract.algo.ts:56
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_3 // "totalStaked"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:57
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    bytec 5 // "aprBasisPoints"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:58
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    bytec 8 // "lastDistributionTime"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:59
    // public distributionPeriodRounds = GlobalState<uint64>({ initialValue: 0 })
    bytec 6 // "distributionPeriodRounds"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:60
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    bytec 7 // "minimumStake"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:61
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "rewardPool"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:52-53
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txn NumAppArgs
    bz main_bare_routing@25
    pushbytess 0x5d789521 0x080f6ecd 0x0e93fde6 0x667c5d30 0x9ffd3e53 0x0890bd58 0x21f1ddff 0xb3b70146 0x0bd8cf60 0x6904ac5a 0x2b87f57c 0xf83eeb5d 0x1e6612bd 0x82ab1ec4 0x15766b09 0xbfe31564 0xce963b1d 0xdc9a2a05 // method "getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)", method "storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void", method "getCurrentPeriod()uint64", method "initialize(asset,account,uint64,uint64,uint64)void", method "optInToAsset()void", method "stake()void", method "withdraw(uint64)void", method "addRewards()void", method "calculateUserRewardsForPeriod(account)uint64", method "calculatePendingRewards(account)uint64", method "distributeRewards(address[])void", method "getActiveStakersCount(address[])uint64", method "updateAPR(uint64)void", method "updateAdmin(account)void", method "getUserStats(account)uint64[]", method "getContractStats()uint64[]", method "emergencyWithdrawRewards(uint64)void", method "deleteUserBox(account)void"
    txna ApplicationArgs 0
    match main_getUserStakeInfo_route@5 main_storeUserStakeInfo_route@6 main_getCurrentPeriod_route@7 main_initialize_route@8 main_optInToAsset_route@9 main_stake_route@10 main_withdraw_route@11 main_addRewards_route@12 main_calculateUserRewardsForPeriod_route@13 main_calculatePendingRewards_route@14 main_distributeRewards_route@15 main_getActiveStakersCount_route@16 main_updateAPR_route@17 main_updateAdmin_route@18 main_getUserStats_route@19 main_getContractStats_route@20 main_emergencyWithdrawRewards_route@21 main_deleteUserBox_route@22

main_after_if_else@29:
    // smart_contracts/staking/contract.algo.ts:52-53
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    intc_0 // 0
    return

main_deleteUserBox_route@22:
    // smart_contracts/staking/contract.algo.ts:524
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:52-53
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:524
    // @abimethod()
    callsub deleteUserBox
    intc_1 // 1
    return

main_emergencyWithdrawRewards_route@21:
    // smart_contracts/staking/contract.algo.ts:496
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:52-53
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/staking/contract.algo.ts:496
    // @abimethod()
    callsub emergencyWithdrawRewards
    intc_1 // 1
    return

main_getContractStats_route@20:
    // smart_contracts/staking/contract.algo.ts:477
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getContractStats
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getUserStats_route@19:
    // smart_contracts/staking/contract.algo.ts:457
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:52-53
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:457
    // @abimethod({ readonly: true })
    callsub getUserStats
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_updateAdmin_route@18:
    // smart_contracts/staking/contract.algo.ts:444
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:52-53
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:444
    // @abimethod()
    callsub updateAdmin
    intc_1 // 1
    return

main_updateAPR_route@17:
    // smart_contracts/staking/contract.algo.ts:430
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:52-53
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/staking/contract.algo.ts:430
    // @abimethod()
    callsub updateAPR
    intc_1 // 1
    return

main_getActiveStakersCount_route@16:
    // smart_contracts/staking/contract.algo.ts:412
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:52-53
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/staking/contract.algo.ts:412
    // @abimethod({ readonly: true })
    callsub getActiveStakersCount
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_distributeRewards_route@15:
    // smart_contracts/staking/contract.algo.ts:387
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:52-53
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/staking/contract.algo.ts:387
    // @abimethod()
    callsub distributeRewards
    intc_1 // 1
    return

main_calculatePendingRewards_route@14:
    // smart_contracts/staking/contract.algo.ts:314
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:52-53
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:314
    // @abimethod({ readonly: true })
    callsub calculatePendingRewards
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_calculateUserRewardsForPeriod_route@13:
    // smart_contracts/staking/contract.algo.ts:268
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:52-53
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:268
    // @abimethod({ readonly: true })
    callsub calculateUserRewardsForPeriod
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_addRewards_route@12:
    // smart_contracts/staking/contract.algo.ts:243
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub addRewards
    intc_1 // 1
    return

main_withdraw_route@11:
    // smart_contracts/staking/contract.algo.ts:199
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:52-53
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/staking/contract.algo.ts:199
    // @abimethod()
    callsub withdraw
    intc_1 // 1
    return

main_stake_route@10:
    // smart_contracts/staking/contract.algo.ts:152
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub stake
    intc_1 // 1
    return

main_optInToAsset_route@9:
    // smart_contracts/staking/contract.algo.ts:131
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub optInToAsset
    intc_1 // 1
    return

main_initialize_route@8:
    // smart_contracts/staking/contract.algo.ts:103
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:52-53
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    btoi
    txnas Accounts
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    // smart_contracts/staking/contract.algo.ts:103
    // @abimethod()
    callsub initialize
    intc_1 // 1
    return

main_getCurrentPeriod_route@7:
    // smart_contracts/staking/contract.algo.ts:94
    // public getCurrentPeriod(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getCurrentPeriod
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_storeUserStakeInfo_route@6:
    // smart_contracts/staking/contract.algo.ts:87
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:52-53
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    // smart_contracts/staking/contract.algo.ts:87
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    callsub storeUserStakeInfo
    pop
    intc_1 // 1
    return

main_getUserStakeInfo_route@5:
    // smart_contracts/staking/contract.algo.ts:68
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:52-53
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:68
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    callsub getUserStakeInfo
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@25:
    // smart_contracts/staking/contract.algo.ts:52-53
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txn OnCompletion
    bnz main_after_if_else@29
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getUserStakeInfo(userAddress: bytes) -> bytes:
getUserStakeInfo:
    // smart_contracts/staking/contract.algo.ts:68
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    proto 1 1
    // smart_contracts/staking/contract.algo.ts:63
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    bytec 9 // "stakers"
    // smart_contracts/staking/contract.algo.ts:69
    // const userBox = this.stakers(userAddress)
    frame_dig -1
    // smart_contracts/staking/contract.algo.ts:63
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    concat
    // smart_contracts/staking/contract.algo.ts:69
    // const userBox = this.stakers(userAddress)
    dup
    // smart_contracts/staking/contract.algo.ts:71
    // if (userBox.exists) {
    box_len
    bury 1
    bz getUserStakeInfo_else_body@2
    // smart_contracts/staking/contract.algo.ts:72
    // return userBox.value.copy()
    frame_dig 0
    box_get
    assert // Box must have value
    swap
    retsub

getUserStakeInfo_else_body@2:
    // smart_contracts/staking/contract.algo.ts:74-80
    // return new UserStakeInfo({
    //   stakedAmount: new arc4.UintN64(0),
    //   firstStakeTime: new arc4.UintN64(0),
    //   lastStakeTime: new arc4.UintN64(0),
    //   totalRewardsEarned: new arc4.UintN64(0),
    //   lastClaimedPeriod: new arc4.UintN64(0),
    // })
    pushbytes 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000
    swap
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.storeUserStakeInfo(userAddress: bytes, stakeInfo: bytes) -> bytes:
storeUserStakeInfo:
    // smart_contracts/staking/contract.algo.ts:87
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    proto 2 1
    // smart_contracts/staking/contract.algo.ts:63
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    bytec 9 // "stakers"
    frame_dig -2
    concat
    // smart_contracts/staking/contract.algo.ts:88
    // this.stakers(userAddress).value = stakeInfo.copy()
    frame_dig -1
    box_put
    frame_dig -1
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getCurrentPeriod() -> uint64:
getCurrentPeriod:
    // smart_contracts/staking/contract.algo.ts:94
    // public getCurrentPeriod(): uint64 {
    proto 0 1
    // smart_contracts/staking/contract.algo.ts:59
    // public distributionPeriodRounds = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 6 // "distributionPeriodRounds"
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:96
    // if (periodSeconds === 0) return 0
    bnz getCurrentPeriod_after_if_else@2
    intc_0 // 0
    swap
    retsub

getCurrentPeriod_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:97
    // return Global.latestTimestamp / periodSeconds
    global LatestTimestamp
    frame_dig 0
    /
    swap
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.initialize(asset: uint64, adminAddress: bytes, aprBasisPoints: uint64, distributionPeriodSeconds: uint64, minimumStake: uint64) -> void:
initialize:
    // smart_contracts/staking/contract.algo.ts:103-110
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   aprBasisPoints: uint64,
    //   distributionPeriodSeconds: uint64,
    //   minimumStake: uint64,
    // ): void {
    proto 5 0
    // smart_contracts/staking/contract.algo.ts:54
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:112
    // assert(this.asset.value === Asset(), 'Already initialized')
    !
    assert // Already initialized
    // smart_contracts/staking/contract.algo.ts:115
    // assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can initialize
    // smart_contracts/staking/contract.algo.ts:54
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    bytec_1 // "asset"
    // smart_contracts/staking/contract.algo.ts:118
    // this.asset.value = asset
    frame_dig -5
    app_global_put
    // smart_contracts/staking/contract.algo.ts:55
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    bytec_2 // "adminAddress"
    // smart_contracts/staking/contract.algo.ts:119
    // this.adminAddress.value = adminAddress
    frame_dig -4
    app_global_put
    // smart_contracts/staking/contract.algo.ts:56
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_3 // "totalStaked"
    // smart_contracts/staking/contract.algo.ts:120
    // this.totalStaked.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:57
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    bytec 5 // "aprBasisPoints"
    // smart_contracts/staking/contract.algo.ts:121
    // this.aprBasisPoints.value = aprBasisPoints
    frame_dig -3
    app_global_put
    // smart_contracts/staking/contract.algo.ts:58
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    bytec 8 // "lastDistributionTime"
    // smart_contracts/staking/contract.algo.ts:122
    // this.lastDistributionTime.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/staking/contract.algo.ts:59
    // public distributionPeriodRounds = GlobalState<uint64>({ initialValue: 0 })
    bytec 6 // "distributionPeriodRounds"
    // smart_contracts/staking/contract.algo.ts:123
    // this.distributionPeriodRounds.value = distributionPeriodSeconds
    frame_dig -2
    app_global_put
    // smart_contracts/staking/contract.algo.ts:60
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    bytec 7 // "minimumStake"
    // smart_contracts/staking/contract.algo.ts:124
    // this.minimumStake.value = minimumStake
    frame_dig -1
    app_global_put
    // smart_contracts/staking/contract.algo.ts:61
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "rewardPool"
    // smart_contracts/staking/contract.algo.ts:125
    // this.rewardPool.value = 0
    intc_0 // 0
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.optInToAsset() -> void:
optInToAsset:
    // smart_contracts/staking/contract.algo.ts:131-132
    // @abimethod()
    // public optInToAsset(): void {
    proto 0 0
    // smart_contracts/staking/contract.algo.ts:55
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_2 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:135
    // assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    txn Sender
    global CreatorAddress
    ==
    bnz optInToAsset_bool_true@2
    txn Sender
    frame_dig 0
    ==
    bz optInToAsset_bool_false@3

optInToAsset_bool_true@2:
    intc_1 // 1

optInToAsset_bool_merge@4:
    // smart_contracts/staking/contract.algo.ts:135
    // assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    assert // Only creator or admin can opt in
    // smart_contracts/staking/contract.algo.ts:54
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:139-145
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/staking/contract.algo.ts:141
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    swap
    itxn_field XferAsset
    // smart_contracts/staking/contract.algo.ts:142
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/staking/contract.algo.ts:139-144
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/contract.algo.ts:139-145
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_submit
    retsub

optInToAsset_bool_false@3:
    intc_0 // 0
    b optInToAsset_bool_merge@4


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.stake() -> void:
stake:
    // smart_contracts/staking/contract.algo.ts:152-153
    // @abimethod()
    // public stake(): void {
    proto 0 0
    // smart_contracts/staking/contract.algo.ts:54
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:156
    // assert(this.asset.value !== Asset(), 'Contract not initialized')
    assert // Contract not initialized
    // smart_contracts/staking/contract.algo.ts:159
    // assert(Global.groupSize === 2, 'Expected 2 txns in group')
    global GroupSize
    pushint 2 // 2
    ==
    assert // Expected 2 txns in group
    // smart_contracts/staking/contract.algo.ts:162
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    gtxns TypeEnum
    dup
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/staking/contract.algo.ts:163
    // assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    intc_2 // 4
    ==
    assert // Transaction 0 must be asset transfer
    // smart_contracts/staking/contract.algo.ts:162
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:164
    // assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // Asset transfer must be to contract
    // smart_contracts/staking/contract.algo.ts:162
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:165
    // assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    gtxns AssetAmount
    dup
    cover 2
    assert // Must stake non-zero amount
    // smart_contracts/staking/contract.algo.ts:162
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:166
    // assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    gtxns XferAsset
    ==
    assert // Incorrect asset ID
    // smart_contracts/staking/contract.algo.ts:60
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 7 // "minimumStake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:173
    // const senderAddress = Txn.sender
    txn Sender
    dup
    // smart_contracts/staking/contract.algo.ts:174
    // const stakeInfo = this.getUserStakeInfo(senderAddress)
    callsub getUserStakeInfo
    dupn 2
    // smart_contracts/staking/contract.algo.ts:177
    // if (stakeInfo.stakedAmount.native === 0) {
    intc_0 // 0
    extract_uint64
    bnz stake_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:178
    // assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    frame_dig 0
    frame_dig 1
    >=
    assert // Initial stake below minimum
    // smart_contracts/staking/contract.algo.ts:180
    // stakeInfo.lastClaimedPeriod = new arc4.UintN64(this.getCurrentPeriod())
    callsub getCurrentPeriod
    itob
    frame_dig 3
    swap
    replace2 32
    // smart_contracts/staking/contract.algo.ts:182
    // stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    global LatestTimestamp
    itob
    replace2 8
    frame_bury 4

stake_after_if_else@2:
    frame_dig 4
    // smart_contracts/staking/contract.algo.ts:186
    // stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    dup
    intc_0 // 0
    extract_uint64
    frame_dig 0
    dup
    cover 3
    +
    itob
    replace2 0
    // smart_contracts/staking/contract.algo.ts:187
    // stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    global LatestTimestamp
    itob
    replace2 16
    // smart_contracts/staking/contract.algo.ts:190
    // this.storeUserStakeInfo(senderAddress, stakeInfo)
    frame_dig 2
    swap
    callsub storeUserStakeInfo
    pop
    // smart_contracts/staking/contract.algo.ts:56
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_3 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:193
    // this.totalStaked.value = this.totalStaked.value + stakeAmount
    +
    // smart_contracts/staking/contract.algo.ts:56
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_3 // "totalStaked"
    // smart_contracts/staking/contract.algo.ts:193
    // this.totalStaked.value = this.totalStaked.value + stakeAmount
    swap
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.withdraw(amount: uint64) -> void:
withdraw:
    // smart_contracts/staking/contract.algo.ts:199-200
    // @abimethod()
    // public withdraw(amount: uint64): void {
    proto 1 0
    // smart_contracts/staking/contract.algo.ts:201
    // const senderAddress = Txn.sender
    txn Sender
    dup
    // smart_contracts/staking/contract.algo.ts:202
    // const stakeInfo = this.getUserStakeInfo(senderAddress)
    callsub getUserStakeInfo
    dup
    // smart_contracts/staking/contract.algo.ts:205
    // assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    intc_0 // 0
    extract_uint64
    dupn 2
    assert // No stake found
    // smart_contracts/staking/contract.algo.ts:206
    // assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    frame_dig -1
    dig 1
    <=
    assert // Withdrawal amount exceeds stake
    // smart_contracts/staking/contract.algo.ts:207
    // assert(amount > 0, 'Withdrawal amount must be positive')
    frame_dig -1
    assert // Withdrawal amount must be positive
    // smart_contracts/staking/contract.algo.ts:211
    // if (amount < stakeInfo.stakedAmount.native) {
    frame_dig -1
    >
    bz withdraw_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:212
    // const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    frame_dig 2
    frame_dig -1
    -
    // smart_contracts/staking/contract.algo.ts:60
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 7 // "minimumStake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:214
    // assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    >=
    assert // Remaining stake would be below minimum

withdraw_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:218
    // stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    frame_dig 2
    frame_dig -1
    -
    itob
    frame_dig 1
    swap
    replace2 0
    // smart_contracts/staking/contract.algo.ts:221
    // this.storeUserStakeInfo(senderAddress, stakeInfo)
    frame_dig 0
    swap
    callsub storeUserStakeInfo
    pop
    // smart_contracts/staking/contract.algo.ts:56
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_3 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:224
    // this.totalStaked.value = this.totalStaked.value - amount
    frame_dig -1
    -
    // smart_contracts/staking/contract.algo.ts:56
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_3 // "totalStaked"
    // smart_contracts/staking/contract.algo.ts:224
    // this.totalStaked.value = this.totalStaked.value - amount
    swap
    app_global_put
    // smart_contracts/staking/contract.algo.ts:54
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:228-235
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/staking/contract.algo.ts:230
    // assetReceiver: Txn.sender,
    txn Sender
    swap
    itxn_field XferAsset
    frame_dig -1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/staking/contract.algo.ts:228-234
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/contract.algo.ts:233
    // fee: 1000,
    pushint 1000 // 1000
    itxn_field Fee
    // smart_contracts/staking/contract.algo.ts:228-235
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.addRewards() -> void:
addRewards:
    // smart_contracts/staking/contract.algo.ts:55
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_2 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:247
    // assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    txn Sender
    ==
    assert // Only admin can add rewards
    // smart_contracts/staking/contract.algo.ts:250
    // assert(Global.groupSize === 2, 'Expected 2 txns in group')
    global GroupSize
    pushint 2 // 2
    ==
    assert // Expected 2 txns in group
    // smart_contracts/staking/contract.algo.ts:54
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:254
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    gtxns TypeEnum
    dup
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/staking/contract.algo.ts:255
    // assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    intc_2 // 4
    ==
    assert // Transaction 0 must be asset transfer
    // smart_contracts/staking/contract.algo.ts:254
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:256
    // assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // Asset transfer must be to contract
    // smart_contracts/staking/contract.algo.ts:254
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:257
    // assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    gtxns AssetAmount
    dup
    assert // Must provide non-zero rewards
    // smart_contracts/staking/contract.algo.ts:254
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:258
    // assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    gtxns XferAsset
    uncover 2
    ==
    assert // Incorrect asset ID
    // smart_contracts/staking/contract.algo.ts:61
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:261
    // this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    +
    // smart_contracts/staking/contract.algo.ts:61
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "rewardPool"
    // smart_contracts/staking/contract.algo.ts:261
    // this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    swap
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.calculateUserRewardsForPeriod(userAddress: bytes) -> uint64:
calculateUserRewardsForPeriod:
    // smart_contracts/staking/contract.algo.ts:268-269
    // @abimethod({ readonly: true })
    // public calculateUserRewardsForPeriod(userAddress: Account): uint64 {
    proto 1 1
    intc_0 // 0
    pushbytes ""
    // smart_contracts/staking/contract.algo.ts:57
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 5 // "aprBasisPoints"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:56
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_3 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:59
    // public distributionPeriodRounds = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 6 // "distributionPeriodRounds"
    app_global_get_ex
    swap
    cover 2
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:275
    // if (totalStaked === 0 || periodSeconds === 0) {
    bz calculateUserRewardsForPeriod_if_body@2
    frame_dig 3
    bnz calculateUserRewardsForPeriod_after_if_else@3

calculateUserRewardsForPeriod_if_body@2:
    // smart_contracts/staking/contract.algo.ts:276
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

calculateUserRewardsForPeriod_after_if_else@3:
    // smart_contracts/staking/contract.algo.ts:280
    // const stakeInfo = this.getUserStakeInfo(userAddress)
    frame_dig -1
    callsub getUserStakeInfo
    dup
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:283
    // if (stakeInfo.stakedAmount.native === 0) {
    intc_0 // 0
    extract_uint64
    dup
    frame_bury 1
    bnz calculateUserRewardsForPeriod_after_if_else@5
    // smart_contracts/staking/contract.algo.ts:284
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

calculateUserRewardsForPeriod_after_if_else@5:
    // smart_contracts/staking/contract.algo.ts:289
    // const firstStakeTime = stakeInfo.firstStakeTime.native
    frame_dig 0
    pushint 8 // 8
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:293
    // if (Global.latestTimestamp < firstStakeTime + minimumStakeTime) {
    global LatestTimestamp
    swap
    // smart_contracts/staking/contract.algo.ts:37
    // const ROUNDS_PER_DAY = Uint64(30857) // (24 * 60 * 60) / 2.8
    pushint 30857 // 30857
    // smart_contracts/staking/contract.algo.ts:293
    // if (Global.latestTimestamp < firstStakeTime + minimumStakeTime) {
    +
    <
    bz calculateUserRewardsForPeriod_after_if_else@7
    // smart_contracts/staking/contract.algo.ts:294
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

calculateUserRewardsForPeriod_after_if_else@7:
    // smart_contracts/staking/contract.algo.ts:302
    // const periodRateNumerator: uint64 = apr * periodSeconds
    frame_dig 2
    frame_dig 3
    *
    // smart_contracts/staking/contract.algo.ts:306
    // const reward: uint64 = (userStake * periodRateNumerator) / periodRateDenominator
    frame_dig 1
    *
    // smart_contracts/staking/contract.algo.ts:303
    // const periodRateDenominator: uint64 = 10000 * yearInSeconds
    pushint 112628570000 // 112628570000
    // smart_contracts/staking/contract.algo.ts:306
    // const reward: uint64 = (userStake * periodRateNumerator) / periodRateDenominator
    /
    // smart_contracts/staking/contract.algo.ts:308
    // return reward
    frame_bury 0
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.calculatePendingRewards(userAddress: bytes) -> uint64:
calculatePendingRewards:
    // smart_contracts/staking/contract.algo.ts:314-315
    // @abimethod({ readonly: true })
    // public calculatePendingRewards(userAddress: Account): uint64 {
    proto 1 1
    pushbytes ""
    dupn 2
    // smart_contracts/staking/contract.algo.ts:316
    // const stakeInfo = this.getUserStakeInfo(userAddress)
    frame_dig -1
    callsub getUserStakeInfo
    dup
    // smart_contracts/staking/contract.algo.ts:318
    // if (stakeInfo.stakedAmount.native === 0) {
    intc_0 // 0
    extract_uint64
    bnz calculatePendingRewards_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:319
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

calculatePendingRewards_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:322
    // const currentPeriod = this.getCurrentPeriod()
    callsub getCurrentPeriod
    dup
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:323
    // const lastClaimedPeriod = stakeInfo.lastClaimedPeriod.native
    frame_dig 3
    intc_3 // 32
    extract_uint64
    dup
    frame_bury 1
    // smart_contracts/staking/contract.algo.ts:326
    // const periodsSinceLastClaim: uint64 = currentPeriod > lastClaimedPeriod ? currentPeriod - lastClaimedPeriod : 0
    >
    bz calculatePendingRewards_ternary_false@4
    frame_dig 0
    frame_dig 1
    -
    frame_bury 2

calculatePendingRewards_ternary_merge@5:
    // smart_contracts/staking/contract.algo.ts:328
    // if (periodsSinceLastClaim === 0) {
    frame_dig 2
    bnz calculatePendingRewards_after_if_else@7
    // smart_contracts/staking/contract.algo.ts:329
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

calculatePendingRewards_after_if_else@7:
    // smart_contracts/staking/contract.algo.ts:333
    // const rewardPerPeriod = this.calculateUserRewardsForPeriod(userAddress)
    frame_dig -1
    callsub calculateUserRewardsForPeriod
    // smart_contracts/staking/contract.algo.ts:335
    // return rewardPerPeriod * periodsSinceLastClaim
    frame_dig 2
    *
    frame_bury 0
    retsub

calculatePendingRewards_ternary_false@4:
    // smart_contracts/staking/contract.algo.ts:326
    // const periodsSinceLastClaim: uint64 = currentPeriod > lastClaimedPeriod ? currentPeriod - lastClaimedPeriod : 0
    intc_0 // 0
    frame_bury 2
    b calculatePendingRewards_ternary_merge@5


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.distributeRewards(stakerAddresses: bytes) -> void:
distributeRewards:
    // smart_contracts/staking/contract.algo.ts:387-388
    // @abimethod()
    // public distributeRewards(stakerAddresses: arc4.Address[]): void {
    proto 1 0
    intc_0 // 0
    dup
    pushbytes ""
    dup
    // smart_contracts/staking/contract.algo.ts:55
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_2 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:391
    // assert(Txn.sender === adminAddr, 'Only admin can distribute rewards')
    txn Sender
    ==
    assert // Only admin can distribute rewards
    // smart_contracts/staking/contract.algo.ts:394
    // assert(stakerAddresses.length <= 50, 'Too many stakers in single batch')
    frame_dig -1
    intc_0 // 0
    extract_uint16
    dup
    pushint 50 // 50
    <=
    assert // Too many stakers in single batch
    // smart_contracts/staking/contract.algo.ts:396
    // let totalDistributed: uint64 = 0
    intc_0 // 0
    dup

distributeRewards_for_header@1:
    // smart_contracts/staking/contract.algo.ts:399
    // for (const staker of stakerAddresses) {
    frame_dig 6
    frame_dig 4
    <
    bz distributeRewards_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 6
    intc_3 // 32
    *
    intc_3 // 32
    extract3 // on error: Index access is out of bounds
    dup
    frame_bury 1
    // smart_contracts/staking/contract.algo.ts:343
    // const stakeInfo = this.getUserStakeInfo(userAddress)
    callsub getUserStakeInfo
    dup
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:346
    // if (stakeInfo.stakedAmount.native === 0) {
    intc_0 // 0
    extract_uint64
    dup
    frame_bury 3
    bnz distributeRewards_after_if_else@7
    // smart_contracts/staking/contract.algo.ts:347
    // return 0
    intc_0 // 0

distributeRewards_after_inlined_smart_contracts/staking/contract.algo.ts::ASAStakingContract.compoundRewardsForUser@12:
    // smart_contracts/staking/contract.algo.ts:401
    // totalDistributed = totalDistributed + rewardsCompounded
    frame_dig 5
    +
    frame_bury 5
    frame_dig 6
    intc_1 // 1
    +
    frame_bury 6
    b distributeRewards_for_header@1

distributeRewards_after_if_else@7:
    // smart_contracts/staking/contract.algo.ts:351
    // const pendingRewards = this.calculatePendingRewards(userAddress)
    frame_dig 1
    callsub calculatePendingRewards
    dup
    frame_bury 2
    // smart_contracts/staking/contract.algo.ts:354
    // if (pendingRewards === 0) {
    bnz distributeRewards_after_if_else@9
    // smart_contracts/staking/contract.algo.ts:355
    // return 0
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:400
    // const rewardsCompounded = this.compoundRewardsForUser(staker.native)
    b distributeRewards_after_inlined_smart_contracts/staking/contract.algo.ts::ASAStakingContract.compoundRewardsForUser@12

distributeRewards_after_if_else@9:
    // smart_contracts/staking/contract.algo.ts:61
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:359
    // if (this.rewardPool.value < pendingRewards) {
    frame_dig 2
    <
    bz distributeRewards_after_if_else@11
    // smart_contracts/staking/contract.algo.ts:360
    // return 0
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:400
    // const rewardsCompounded = this.compoundRewardsForUser(staker.native)
    b distributeRewards_after_inlined_smart_contracts/staking/contract.algo.ts::ASAStakingContract.compoundRewardsForUser@12

distributeRewards_after_if_else@11:
    // smart_contracts/staking/contract.algo.ts:364
    // stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + pendingRewards)
    frame_dig 3
    frame_dig 2
    dup
    cover 2
    +
    itob
    frame_dig 0
    swap
    replace2 0
    // smart_contracts/staking/contract.algo.ts:367
    // stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    dup
    pushint 24 // 24
    extract_uint64
    dig 2
    +
    itob
    replace2 24
    // smart_contracts/staking/contract.algo.ts:370
    // stakeInfo.lastClaimedPeriod = new arc4.UintN64(this.getCurrentPeriod())
    callsub getCurrentPeriod
    itob
    replace2 32
    // smart_contracts/staking/contract.algo.ts:373
    // this.storeUserStakeInfo(userAddress, stakeInfo)
    frame_dig 1
    swap
    callsub storeUserStakeInfo
    pop
    // smart_contracts/staking/contract.algo.ts:56
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_3 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:376
    // this.totalStaked.value = this.totalStaked.value + pendingRewards
    dig 1
    +
    // smart_contracts/staking/contract.algo.ts:56
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_3 // "totalStaked"
    // smart_contracts/staking/contract.algo.ts:376
    // this.totalStaked.value = this.totalStaked.value + pendingRewards
    swap
    app_global_put
    // smart_contracts/staking/contract.algo.ts:61
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:377
    // this.rewardPool.value = this.rewardPool.value - pendingRewards
    dig 1
    -
    // smart_contracts/staking/contract.algo.ts:61
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "rewardPool"
    // smart_contracts/staking/contract.algo.ts:377
    // this.rewardPool.value = this.rewardPool.value - pendingRewards
    swap
    app_global_put
    // smart_contracts/staking/contract.algo.ts:400
    // const rewardsCompounded = this.compoundRewardsForUser(staker.native)
    b distributeRewards_after_inlined_smart_contracts/staking/contract.algo.ts::ASAStakingContract.compoundRewardsForUser@12

distributeRewards_after_for@4:
    // smart_contracts/staking/contract.algo.ts:58
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    bytec 8 // "lastDistributionTime"
    // smart_contracts/staking/contract.algo.ts:405
    // this.lastDistributionTime.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getActiveStakersCount(stakerAddresses: bytes) -> uint64:
getActiveStakersCount:
    // smart_contracts/staking/contract.algo.ts:412-413
    // @abimethod({ readonly: true })
    // public getActiveStakersCount(stakerAddresses: arc4.Address[]): uint64 {
    proto 1 1
    pushbytes ""
    // smart_contracts/staking/contract.algo.ts:414
    // let activeCount: uint64 = 0
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:416
    // for (const staker of stakerAddresses) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    intc_0 // 0

getActiveStakersCount_for_header@1:
    // smart_contracts/staking/contract.algo.ts:416
    // for (const staker of stakerAddresses) {
    frame_dig 3
    frame_dig 2
    <
    bz getActiveStakersCount_after_for@6
    frame_dig -1
    extract 2 0
    frame_dig 3
    intc_3 // 32
    *
    intc_3 // 32
    extract3 // on error: Index access is out of bounds
    // smart_contracts/staking/contract.algo.ts:417
    // const stakeInfo = this.getUserStakeInfo(staker.native)
    callsub getUserStakeInfo
    // smart_contracts/staking/contract.algo.ts:418
    // if (stakeInfo.stakedAmount.native > 0) {
    intc_0 // 0
    extract_uint64
    frame_dig 1
    frame_bury 0
    bz getActiveStakersCount_after_if_else@4
    // smart_contracts/staking/contract.algo.ts:419
    // activeCount = activeCount + 1
    frame_dig 1
    intc_1 // 1
    +
    frame_bury 0

getActiveStakersCount_after_if_else@4:
    frame_dig 0
    frame_bury 1
    frame_dig 3
    intc_1 // 1
    +
    frame_bury 3
    b getActiveStakersCount_for_header@1

getActiveStakersCount_after_for@6:
    // smart_contracts/staking/contract.algo.ts:423
    // return activeCount
    frame_dig 1
    frame_bury 0
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.updateAPR(newAprBasisPoints: uint64) -> void:
updateAPR:
    // smart_contracts/staking/contract.algo.ts:430-431
    // @abimethod()
    // public updateAPR(newAprBasisPoints: uint64): void {
    proto 1 0
    // smart_contracts/staking/contract.algo.ts:55
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_2 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:434
    // assert(Txn.sender === adminAddr, 'Only admin can update APR')
    txn Sender
    ==
    assert // Only admin can update APR
    // smart_contracts/staking/contract.algo.ts:57
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    bytec 5 // "aprBasisPoints"
    // smart_contracts/staking/contract.algo.ts:437
    // this.aprBasisPoints.value = newAprBasisPoints
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.updateAdmin(newAdminAddress: bytes) -> void:
updateAdmin:
    // smart_contracts/staking/contract.algo.ts:444-445
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    proto 1 0
    // smart_contracts/staking/contract.algo.ts:55
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_2 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:448
    // assert(Txn.sender === adminAddr, 'Only admin can update admin')
    txn Sender
    ==
    assert // Only admin can update admin
    // smart_contracts/staking/contract.algo.ts:55
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    bytec_2 // "adminAddress"
    // smart_contracts/staking/contract.algo.ts:451
    // this.adminAddress.value = newAdminAddress
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getUserStats(userAddress: bytes) -> bytes:
getUserStats:
    // smart_contracts/staking/contract.algo.ts:457-458
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    proto 1 1
    // smart_contracts/staking/contract.algo.ts:459
    // const stakeInfo = this.getUserStakeInfo(userAddress)
    frame_dig -1
    callsub getUserStakeInfo
    // smart_contracts/staking/contract.algo.ts:460
    // const pendingRewards = this.calculatePendingRewards(userAddress)
    frame_dig -1
    callsub calculatePendingRewards
    // smart_contracts/staking/contract.algo.ts:463
    // stakeInfo.stakedAmount.native,
    dig 1
    intc_0 // 0
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:464
    // stakeInfo.firstStakeTime.native,
    dig 2
    pushint 8 // 8
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:465
    // stakeInfo.lastStakeTime.native,
    dig 3
    pushint 16 // 16
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:466
    // stakeInfo.totalRewardsEarned.native,
    dig 4
    pushint 24 // 24
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:468
    // stakeInfo.lastClaimedPeriod.native,
    uncover 5
    intc_3 // 32
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:463
    // stakeInfo.stakedAmount.native,
    uncover 4
    itob
    // smart_contracts/staking/contract.algo.ts:464
    // stakeInfo.firstStakeTime.native,
    uncover 4
    itob
    // smart_contracts/staking/contract.algo.ts:463-468
    // stakeInfo.stakedAmount.native,
    // stakeInfo.firstStakeTime.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // pendingRewards,
    // stakeInfo.lastClaimedPeriod.native,
    concat
    // smart_contracts/staking/contract.algo.ts:465
    // stakeInfo.lastStakeTime.native,
    uncover 3
    itob
    // smart_contracts/staking/contract.algo.ts:463-468
    // stakeInfo.stakedAmount.native,
    // stakeInfo.firstStakeTime.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // pendingRewards,
    // stakeInfo.lastClaimedPeriod.native,
    concat
    // smart_contracts/staking/contract.algo.ts:466
    // stakeInfo.totalRewardsEarned.native,
    uncover 2
    itob
    // smart_contracts/staking/contract.algo.ts:463-468
    // stakeInfo.stakedAmount.native,
    // stakeInfo.firstStakeTime.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // pendingRewards,
    // stakeInfo.lastClaimedPeriod.native,
    concat
    // smart_contracts/staking/contract.algo.ts:467
    // pendingRewards,
    uncover 2
    itob
    // smart_contracts/staking/contract.algo.ts:463-468
    // stakeInfo.stakedAmount.native,
    // stakeInfo.firstStakeTime.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // pendingRewards,
    // stakeInfo.lastClaimedPeriod.native,
    concat
    // smart_contracts/staking/contract.algo.ts:468
    // stakeInfo.lastClaimedPeriod.native,
    swap
    itob
    // smart_contracts/staking/contract.algo.ts:463-468
    // stakeInfo.stakedAmount.native,
    // stakeInfo.firstStakeTime.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // pendingRewards,
    // stakeInfo.lastClaimedPeriod.native,
    concat
    dup
    len
    pushint 8 // 8
    /
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:471
    // return result
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getContractStats() -> bytes:
getContractStats:
    // smart_contracts/staking/contract.algo.ts:54
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:56
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_3 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:57
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 5 // "aprBasisPoints"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:58
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 8 // "lastDistributionTime"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:59
    // public distributionPeriodRounds = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 6 // "distributionPeriodRounds"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:60
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 7 // "minimumStake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:61
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:487
    // this.getCurrentPeriod(),
    callsub getCurrentPeriod
    // smart_contracts/staking/contract.algo.ts:54
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    uncover 7
    itob
    // smart_contracts/staking/contract.algo.ts:56
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    uncover 7
    itob
    // smart_contracts/staking/contract.algo.ts:56-487
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    // public distributionPeriodRounds = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       lastClaimedPeriod: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Calculate the current distribution period
    //  */
    // public getCurrentPeriod(): uint64 {
    //   const periodSeconds = this.distributionPeriodRounds.value
    //   if (periodSeconds === 0) return 0
    //   return Global.latestTimestamp / periodSeconds
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   aprBasisPoints: uint64,
    //   distributionPeriodSeconds: uint64,
    //   minimumStake: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.aprBasisPoints.value = aprBasisPoints
    //   this.lastDistributionTime.value = Global.latestTimestamp
    //   this.distributionPeriodRounds.value = distributionPeriodSeconds
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    // 
    //   // Get the current user stake info
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the initial claim period to current period
    //     stakeInfo.lastClaimedPeriod = new arc4.UintN64(this.getCurrentPeriod())
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Txn.sender,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate rewards for a specific user for a given period
    //  * This calculates rewards per distribution period
    //  */
    // @abimethod({ readonly: true })
    // public calculateUserRewardsForPeriod(userAddress: Account): uint64 {
    //   const apr = this.aprBasisPoints.value
    //   const totalStaked = this.totalStaked.value
    //   const periodSeconds = this.distributionPeriodRounds.value
    // 
    //   // If no total stake or no period defined, return 0
    //   if (totalStaked === 0 || periodSeconds === 0) {
    //     return 0
    //   }
    // 
    //   // Get the user's stake info
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   // If user has no stake, return 0
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   // Get user's stake amount and first stake time
    //   const userStake = stakeInfo.stakedAmount.native
    //   const firstStakeTime = stakeInfo.firstStakeTime.native
    // 
    //   // Check if user has been staked for the minimum period (using first stake time)
    //   const minimumStakeTime: uint64 = ROUNDS_PER_DAY
    //   if (Global.latestTimestamp < firstStakeTime + minimumStakeTime) {
    //     return 0
    //   }
    // 
    //   // Calculate reward rate for the period
    //   // APR is in basis points (e.g., 500 = 5%)
    //   // Convert APR to period rate: (APR / 10000) * (periodSeconds / 31536000)
    //   // where 31536000 is seconds in a year
    //   const yearInSeconds: uint64 = ROUNDS_PER_YEAR
    //   const periodRateNumerator: uint64 = apr * periodSeconds
    //   const periodRateDenominator: uint64 = 10000 * yearInSeconds
    // 
    //   // Calculate reward: userStake * periodRate
    //   const reward: uint64 = (userStake * periodRateNumerator) / periodRateDenominator
    // 
    //   return reward
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user since their last claim
    //  */
    // @abimethod({ readonly: true })
    // public calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const currentPeriod = this.getCurrentPeriod()
    //   const lastClaimedPeriod = stakeInfo.lastClaimedPeriod.native
    // 
    //   // Calculate periods since last claim
    //   const periodsSinceLastClaim: uint64 = currentPeriod > lastClaimedPeriod ? currentPeriod - lastClaimedPeriod : 0
    // 
    //   if (periodsSinceLastClaim === 0) {
    //     return 0
    //   }
    // 
    //   // Calculate reward per period
    //   const rewardPerPeriod = this.calculateUserRewardsForPeriod(userAddress)
    // 
    //   return rewardPerPeriod * periodsSinceLastClaim
    // }
    // 
    // /**
    //  * Helper function to compound rewards for a single user
    //  * Used by the automated distribution system
    //  */
    // private compoundRewardsForUser(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   // Skip if user has no stake
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   // Calculate pending rewards
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   // Skip if no rewards to compound
    //   if (pendingRewards === 0) {
    //     return 0
    //   }
    // 
    //   // Skip if reward pool has insufficient funds for this user
    //   if (this.rewardPool.value < pendingRewards) {
    //     return 0
    //   }
    // 
    //   // Auto-compound: Add rewards to staked amount
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + pendingRewards)
    // 
    //   // Update total rewards earned
    //   stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    // 
    //   // Update last claimed period to current period
    //   stakeInfo.lastClaimedPeriod = new arc4.UintN64(this.getCurrentPeriod())
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(userAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + pendingRewards
    //   this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Distribute and compound rewards for multiple stakers
    //  * This method is designed to be called by a cron job on a daily basis
    //  * Only admin can call this method
    //  */
    // @abimethod()
    // public distributeRewards(stakerAddresses: arc4.Address[]): void {
    //   // Ensure only admin can distribute rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can distribute rewards')
    // 
    //   // Ensure we don't process too many stakers in one call (gas limit protection)
    //   assert(stakerAddresses.length <= 50, 'Too many stakers in single batch')
    // 
    //   let totalDistributed: uint64 = 0
    // 
    //   // Process each staker
    //   for (const staker of stakerAddresses) {
    //     const rewardsCompounded = this.compoundRewardsForUser(staker.native)
    //     totalDistributed = totalDistributed + rewardsCompounded
    //   }
    // 
    //   // Update last distribution time
    //   this.lastDistributionTime.value = Global.latestTimestamp
    // }
    // 
    // /**
    //  * Get all non-zero stakers count (for monitoring purposes)
    //  * Note: This doesn't return the actual addresses due to box iteration limitations
    //  */
    // @abimethod({ readonly: true })
    // public getActiveStakersCount(stakerAddresses: arc4.Address[]): uint64 {
    //   let activeCount: uint64 = 0
    // 
    //   for (const staker of stakerAddresses) {
    //     const stakeInfo = this.getUserStakeInfo(staker.native)
    //     if (stakeInfo.stakedAmount.native > 0) {
    //       activeCount = activeCount + 1
    //     }
    //   }
    // 
    //   return activeCount
    // }
    // 
    // /**
    //  * Update the APR basis points
    //  * Only the admin can call this
    //  */
    // @abimethod()
    // public updateAPR(newAprBasisPoints: uint64): void {
    //   // Ensure only admin can update APR
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update APR')
    // 
    //   // Update APR
    //   this.aprBasisPoints.value = newAprBasisPoints
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.lastClaimedPeriod.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     this.aprBasisPoints.value,
    //     this.lastDistributionTime.value,
    //     this.distributionPeriodRounds.value,
    //     this.minimumStake.value,
    //     this.rewardPool.value,
    //     this.getCurrentPeriod(),
    concat
    // smart_contracts/staking/contract.algo.ts:57
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    uncover 6
    itob
    // smart_contracts/staking/contract.algo.ts:56-487
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    // public distributionPeriodRounds = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       lastClaimedPeriod: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Calculate the current distribution period
    //  */
    // public getCurrentPeriod(): uint64 {
    //   const periodSeconds = this.distributionPeriodRounds.value
    //   if (periodSeconds === 0) return 0
    //   return Global.latestTimestamp / periodSeconds
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   aprBasisPoints: uint64,
    //   distributionPeriodSeconds: uint64,
    //   minimumStake: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.aprBasisPoints.value = aprBasisPoints
    //   this.lastDistributionTime.value = Global.latestTimestamp
    //   this.distributionPeriodRounds.value = distributionPeriodSeconds
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    // 
    //   // Get the current user stake info
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the initial claim period to current period
    //     stakeInfo.lastClaimedPeriod = new arc4.UintN64(this.getCurrentPeriod())
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Txn.sender,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate rewards for a specific user for a given period
    //  * This calculates rewards per distribution period
    //  */
    // @abimethod({ readonly: true })
    // public calculateUserRewardsForPeriod(userAddress: Account): uint64 {
    //   const apr = this.aprBasisPoints.value
    //   const totalStaked = this.totalStaked.value
    //   const periodSeconds = this.distributionPeriodRounds.value
    // 
    //   // If no total stake or no period defined, return 0
    //   if (totalStaked === 0 || periodSeconds === 0) {
    //     return 0
    //   }
    // 
    //   // Get the user's stake info
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   // If user has no stake, return 0
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   // Get user's stake amount and first stake time
    //   const userStake = stakeInfo.stakedAmount.native
    //   const firstStakeTime = stakeInfo.firstStakeTime.native
    // 
    //   // Check if user has been staked for the minimum period (using first stake time)
    //   const minimumStakeTime: uint64 = ROUNDS_PER_DAY
    //   if (Global.latestTimestamp < firstStakeTime + minimumStakeTime) {
    //     return 0
    //   }
    // 
    //   // Calculate reward rate for the period
    //   // APR is in basis points (e.g., 500 = 5%)
    //   // Convert APR to period rate: (APR / 10000) * (periodSeconds / 31536000)
    //   // where 31536000 is seconds in a year
    //   const yearInSeconds: uint64 = ROUNDS_PER_YEAR
    //   const periodRateNumerator: uint64 = apr * periodSeconds
    //   const periodRateDenominator: uint64 = 10000 * yearInSeconds
    // 
    //   // Calculate reward: userStake * periodRate
    //   const reward: uint64 = (userStake * periodRateNumerator) / periodRateDenominator
    // 
    //   return reward
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user since their last claim
    //  */
    // @abimethod({ readonly: true })
    // public calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const currentPeriod = this.getCurrentPeriod()
    //   const lastClaimedPeriod = stakeInfo.lastClaimedPeriod.native
    // 
    //   // Calculate periods since last claim
    //   const periodsSinceLastClaim: uint64 = currentPeriod > lastClaimedPeriod ? currentPeriod - lastClaimedPeriod : 0
    // 
    //   if (periodsSinceLastClaim === 0) {
    //     return 0
    //   }
    // 
    //   // Calculate reward per period
    //   const rewardPerPeriod = this.calculateUserRewardsForPeriod(userAddress)
    // 
    //   return rewardPerPeriod * periodsSinceLastClaim
    // }
    // 
    // /**
    //  * Helper function to compound rewards for a single user
    //  * Used by the automated distribution system
    //  */
    // private compoundRewardsForUser(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   // Skip if user has no stake
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   // Calculate pending rewards
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   // Skip if no rewards to compound
    //   if (pendingRewards === 0) {
    //     return 0
    //   }
    // 
    //   // Skip if reward pool has insufficient funds for this user
    //   if (this.rewardPool.value < pendingRewards) {
    //     return 0
    //   }
    // 
    //   // Auto-compound: Add rewards to staked amount
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + pendingRewards)
    // 
    //   // Update total rewards earned
    //   stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    // 
    //   // Update last claimed period to current period
    //   stakeInfo.lastClaimedPeriod = new arc4.UintN64(this.getCurrentPeriod())
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(userAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + pendingRewards
    //   this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Distribute and compound rewards for multiple stakers
    //  * This method is designed to be called by a cron job on a daily basis
    //  * Only admin can call this method
    //  */
    // @abimethod()
    // public distributeRewards(stakerAddresses: arc4.Address[]): void {
    //   // Ensure only admin can distribute rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can distribute rewards')
    // 
    //   // Ensure we don't process too many stakers in one call (gas limit protection)
    //   assert(stakerAddresses.length <= 50, 'Too many stakers in single batch')
    // 
    //   let totalDistributed: uint64 = 0
    // 
    //   // Process each staker
    //   for (const staker of stakerAddresses) {
    //     const rewardsCompounded = this.compoundRewardsForUser(staker.native)
    //     totalDistributed = totalDistributed + rewardsCompounded
    //   }
    // 
    //   // Update last distribution time
    //   this.lastDistributionTime.value = Global.latestTimestamp
    // }
    // 
    // /**
    //  * Get all non-zero stakers count (for monitoring purposes)
    //  * Note: This doesn't return the actual addresses due to box iteration limitations
    //  */
    // @abimethod({ readonly: true })
    // public getActiveStakersCount(stakerAddresses: arc4.Address[]): uint64 {
    //   let activeCount: uint64 = 0
    // 
    //   for (const staker of stakerAddresses) {
    //     const stakeInfo = this.getUserStakeInfo(staker.native)
    //     if (stakeInfo.stakedAmount.native > 0) {
    //       activeCount = activeCount + 1
    //     }
    //   }
    // 
    //   return activeCount
    // }
    // 
    // /**
    //  * Update the APR basis points
    //  * Only the admin can call this
    //  */
    // @abimethod()
    // public updateAPR(newAprBasisPoints: uint64): void {
    //   // Ensure only admin can update APR
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update APR')
    // 
    //   // Update APR
    //   this.aprBasisPoints.value = newAprBasisPoints
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.lastClaimedPeriod.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     this.aprBasisPoints.value,
    //     this.lastDistributionTime.value,
    //     this.distributionPeriodRounds.value,
    //     this.minimumStake.value,
    //     this.rewardPool.value,
    //     this.getCurrentPeriod(),
    concat
    // smart_contracts/staking/contract.algo.ts:58
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    uncover 5
    itob
    // smart_contracts/staking/contract.algo.ts:56-487
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    // public distributionPeriodRounds = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       lastClaimedPeriod: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Calculate the current distribution period
    //  */
    // public getCurrentPeriod(): uint64 {
    //   const periodSeconds = this.distributionPeriodRounds.value
    //   if (periodSeconds === 0) return 0
    //   return Global.latestTimestamp / periodSeconds
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   aprBasisPoints: uint64,
    //   distributionPeriodSeconds: uint64,
    //   minimumStake: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.aprBasisPoints.value = aprBasisPoints
    //   this.lastDistributionTime.value = Global.latestTimestamp
    //   this.distributionPeriodRounds.value = distributionPeriodSeconds
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    // 
    //   // Get the current user stake info
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the initial claim period to current period
    //     stakeInfo.lastClaimedPeriod = new arc4.UintN64(this.getCurrentPeriod())
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Txn.sender,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate rewards for a specific user for a given period
    //  * This calculates rewards per distribution period
    //  */
    // @abimethod({ readonly: true })
    // public calculateUserRewardsForPeriod(userAddress: Account): uint64 {
    //   const apr = this.aprBasisPoints.value
    //   const totalStaked = this.totalStaked.value
    //   const periodSeconds = this.distributionPeriodRounds.value
    // 
    //   // If no total stake or no period defined, return 0
    //   if (totalStaked === 0 || periodSeconds === 0) {
    //     return 0
    //   }
    // 
    //   // Get the user's stake info
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   // If user has no stake, return 0
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   // Get user's stake amount and first stake time
    //   const userStake = stakeInfo.stakedAmount.native
    //   const firstStakeTime = stakeInfo.firstStakeTime.native
    // 
    //   // Check if user has been staked for the minimum period (using first stake time)
    //   const minimumStakeTime: uint64 = ROUNDS_PER_DAY
    //   if (Global.latestTimestamp < firstStakeTime + minimumStakeTime) {
    //     return 0
    //   }
    // 
    //   // Calculate reward rate for the period
    //   // APR is in basis points (e.g., 500 = 5%)
    //   // Convert APR to period rate: (APR / 10000) * (periodSeconds / 31536000)
    //   // where 31536000 is seconds in a year
    //   const yearInSeconds: uint64 = ROUNDS_PER_YEAR
    //   const periodRateNumerator: uint64 = apr * periodSeconds
    //   const periodRateDenominator: uint64 = 10000 * yearInSeconds
    // 
    //   // Calculate reward: userStake * periodRate
    //   const reward: uint64 = (userStake * periodRateNumerator) / periodRateDenominator
    // 
    //   return reward
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user since their last claim
    //  */
    // @abimethod({ readonly: true })
    // public calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const currentPeriod = this.getCurrentPeriod()
    //   const lastClaimedPeriod = stakeInfo.lastClaimedPeriod.native
    // 
    //   // Calculate periods since last claim
    //   const periodsSinceLastClaim: uint64 = currentPeriod > lastClaimedPeriod ? currentPeriod - lastClaimedPeriod : 0
    // 
    //   if (periodsSinceLastClaim === 0) {
    //     return 0
    //   }
    // 
    //   // Calculate reward per period
    //   const rewardPerPeriod = this.calculateUserRewardsForPeriod(userAddress)
    // 
    //   return rewardPerPeriod * periodsSinceLastClaim
    // }
    // 
    // /**
    //  * Helper function to compound rewards for a single user
    //  * Used by the automated distribution system
    //  */
    // private compoundRewardsForUser(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   // Skip if user has no stake
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   // Calculate pending rewards
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   // Skip if no rewards to compound
    //   if (pendingRewards === 0) {
    //     return 0
    //   }
    // 
    //   // Skip if reward pool has insufficient funds for this user
    //   if (this.rewardPool.value < pendingRewards) {
    //     return 0
    //   }
    // 
    //   // Auto-compound: Add rewards to staked amount
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + pendingRewards)
    // 
    //   // Update total rewards earned
    //   stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    // 
    //   // Update last claimed period to current period
    //   stakeInfo.lastClaimedPeriod = new arc4.UintN64(this.getCurrentPeriod())
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(userAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + pendingRewards
    //   this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Distribute and compound rewards for multiple stakers
    //  * This method is designed to be called by a cron job on a daily basis
    //  * Only admin can call this method
    //  */
    // @abimethod()
    // public distributeRewards(stakerAddresses: arc4.Address[]): void {
    //   // Ensure only admin can distribute rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can distribute rewards')
    // 
    //   // Ensure we don't process too many stakers in one call (gas limit protection)
    //   assert(stakerAddresses.length <= 50, 'Too many stakers in single batch')
    // 
    //   let totalDistributed: uint64 = 0
    // 
    //   // Process each staker
    //   for (const staker of stakerAddresses) {
    //     const rewardsCompounded = this.compoundRewardsForUser(staker.native)
    //     totalDistributed = totalDistributed + rewardsCompounded
    //   }
    // 
    //   // Update last distribution time
    //   this.lastDistributionTime.value = Global.latestTimestamp
    // }
    // 
    // /**
    //  * Get all non-zero stakers count (for monitoring purposes)
    //  * Note: This doesn't return the actual addresses due to box iteration limitations
    //  */
    // @abimethod({ readonly: true })
    // public getActiveStakersCount(stakerAddresses: arc4.Address[]): uint64 {
    //   let activeCount: uint64 = 0
    // 
    //   for (const staker of stakerAddresses) {
    //     const stakeInfo = this.getUserStakeInfo(staker.native)
    //     if (stakeInfo.stakedAmount.native > 0) {
    //       activeCount = activeCount + 1
    //     }
    //   }
    // 
    //   return activeCount
    // }
    // 
    // /**
    //  * Update the APR basis points
    //  * Only the admin can call this
    //  */
    // @abimethod()
    // public updateAPR(newAprBasisPoints: uint64): void {
    //   // Ensure only admin can update APR
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update APR')
    // 
    //   // Update APR
    //   this.aprBasisPoints.value = newAprBasisPoints
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.lastClaimedPeriod.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     this.aprBasisPoints.value,
    //     this.lastDistributionTime.value,
    //     this.distributionPeriodRounds.value,
    //     this.minimumStake.value,
    //     this.rewardPool.value,
    //     this.getCurrentPeriod(),
    concat
    // smart_contracts/staking/contract.algo.ts:59
    // public distributionPeriodRounds = GlobalState<uint64>({ initialValue: 0 })
    uncover 4
    itob
    // smart_contracts/staking/contract.algo.ts:56-487
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    // public distributionPeriodRounds = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       lastClaimedPeriod: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Calculate the current distribution period
    //  */
    // public getCurrentPeriod(): uint64 {
    //   const periodSeconds = this.distributionPeriodRounds.value
    //   if (periodSeconds === 0) return 0
    //   return Global.latestTimestamp / periodSeconds
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   aprBasisPoints: uint64,
    //   distributionPeriodSeconds: uint64,
    //   minimumStake: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.aprBasisPoints.value = aprBasisPoints
    //   this.lastDistributionTime.value = Global.latestTimestamp
    //   this.distributionPeriodRounds.value = distributionPeriodSeconds
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    // 
    //   // Get the current user stake info
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the initial claim period to current period
    //     stakeInfo.lastClaimedPeriod = new arc4.UintN64(this.getCurrentPeriod())
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Txn.sender,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate rewards for a specific user for a given period
    //  * This calculates rewards per distribution period
    //  */
    // @abimethod({ readonly: true })
    // public calculateUserRewardsForPeriod(userAddress: Account): uint64 {
    //   const apr = this.aprBasisPoints.value
    //   const totalStaked = this.totalStaked.value
    //   const periodSeconds = this.distributionPeriodRounds.value
    // 
    //   // If no total stake or no period defined, return 0
    //   if (totalStaked === 0 || periodSeconds === 0) {
    //     return 0
    //   }
    // 
    //   // Get the user's stake info
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   // If user has no stake, return 0
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   // Get user's stake amount and first stake time
    //   const userStake = stakeInfo.stakedAmount.native
    //   const firstStakeTime = stakeInfo.firstStakeTime.native
    // 
    //   // Check if user has been staked for the minimum period (using first stake time)
    //   const minimumStakeTime: uint64 = ROUNDS_PER_DAY
    //   if (Global.latestTimestamp < firstStakeTime + minimumStakeTime) {
    //     return 0
    //   }
    // 
    //   // Calculate reward rate for the period
    //   // APR is in basis points (e.g., 500 = 5%)
    //   // Convert APR to period rate: (APR / 10000) * (periodSeconds / 31536000)
    //   // where 31536000 is seconds in a year
    //   const yearInSeconds: uint64 = ROUNDS_PER_YEAR
    //   const periodRateNumerator: uint64 = apr * periodSeconds
    //   const periodRateDenominator: uint64 = 10000 * yearInSeconds
    // 
    //   // Calculate reward: userStake * periodRate
    //   const reward: uint64 = (userStake * periodRateNumerator) / periodRateDenominator
    // 
    //   return reward
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user since their last claim
    //  */
    // @abimethod({ readonly: true })
    // public calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const currentPeriod = this.getCurrentPeriod()
    //   const lastClaimedPeriod = stakeInfo.lastClaimedPeriod.native
    // 
    //   // Calculate periods since last claim
    //   const periodsSinceLastClaim: uint64 = currentPeriod > lastClaimedPeriod ? currentPeriod - lastClaimedPeriod : 0
    // 
    //   if (periodsSinceLastClaim === 0) {
    //     return 0
    //   }
    // 
    //   // Calculate reward per period
    //   const rewardPerPeriod = this.calculateUserRewardsForPeriod(userAddress)
    // 
    //   return rewardPerPeriod * periodsSinceLastClaim
    // }
    // 
    // /**
    //  * Helper function to compound rewards for a single user
    //  * Used by the automated distribution system
    //  */
    // private compoundRewardsForUser(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   // Skip if user has no stake
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   // Calculate pending rewards
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   // Skip if no rewards to compound
    //   if (pendingRewards === 0) {
    //     return 0
    //   }
    // 
    //   // Skip if reward pool has insufficient funds for this user
    //   if (this.rewardPool.value < pendingRewards) {
    //     return 0
    //   }
    // 
    //   // Auto-compound: Add rewards to staked amount
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + pendingRewards)
    // 
    //   // Update total rewards earned
    //   stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    // 
    //   // Update last claimed period to current period
    //   stakeInfo.lastClaimedPeriod = new arc4.UintN64(this.getCurrentPeriod())
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(userAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + pendingRewards
    //   this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Distribute and compound rewards for multiple stakers
    //  * This method is designed to be called by a cron job on a daily basis
    //  * Only admin can call this method
    //  */
    // @abimethod()
    // public distributeRewards(stakerAddresses: arc4.Address[]): void {
    //   // Ensure only admin can distribute rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can distribute rewards')
    // 
    //   // Ensure we don't process too many stakers in one call (gas limit protection)
    //   assert(stakerAddresses.length <= 50, 'Too many stakers in single batch')
    // 
    //   let totalDistributed: uint64 = 0
    // 
    //   // Process each staker
    //   for (const staker of stakerAddresses) {
    //     const rewardsCompounded = this.compoundRewardsForUser(staker.native)
    //     totalDistributed = totalDistributed + rewardsCompounded
    //   }
    // 
    //   // Update last distribution time
    //   this.lastDistributionTime.value = Global.latestTimestamp
    // }
    // 
    // /**
    //  * Get all non-zero stakers count (for monitoring purposes)
    //  * Note: This doesn't return the actual addresses due to box iteration limitations
    //  */
    // @abimethod({ readonly: true })
    // public getActiveStakersCount(stakerAddresses: arc4.Address[]): uint64 {
    //   let activeCount: uint64 = 0
    // 
    //   for (const staker of stakerAddresses) {
    //     const stakeInfo = this.getUserStakeInfo(staker.native)
    //     if (stakeInfo.stakedAmount.native > 0) {
    //       activeCount = activeCount + 1
    //     }
    //   }
    // 
    //   return activeCount
    // }
    // 
    // /**
    //  * Update the APR basis points
    //  * Only the admin can call this
    //  */
    // @abimethod()
    // public updateAPR(newAprBasisPoints: uint64): void {
    //   // Ensure only admin can update APR
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update APR')
    // 
    //   // Update APR
    //   this.aprBasisPoints.value = newAprBasisPoints
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.lastClaimedPeriod.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     this.aprBasisPoints.value,
    //     this.lastDistributionTime.value,
    //     this.distributionPeriodRounds.value,
    //     this.minimumStake.value,
    //     this.rewardPool.value,
    //     this.getCurrentPeriod(),
    concat
    // smart_contracts/staking/contract.algo.ts:60
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    uncover 3
    itob
    // smart_contracts/staking/contract.algo.ts:56-487
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    // public distributionPeriodRounds = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       lastClaimedPeriod: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Calculate the current distribution period
    //  */
    // public getCurrentPeriod(): uint64 {
    //   const periodSeconds = this.distributionPeriodRounds.value
    //   if (periodSeconds === 0) return 0
    //   return Global.latestTimestamp / periodSeconds
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   aprBasisPoints: uint64,
    //   distributionPeriodSeconds: uint64,
    //   minimumStake: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.aprBasisPoints.value = aprBasisPoints
    //   this.lastDistributionTime.value = Global.latestTimestamp
    //   this.distributionPeriodRounds.value = distributionPeriodSeconds
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    // 
    //   // Get the current user stake info
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the initial claim period to current period
    //     stakeInfo.lastClaimedPeriod = new arc4.UintN64(this.getCurrentPeriod())
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Txn.sender,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate rewards for a specific user for a given period
    //  * This calculates rewards per distribution period
    //  */
    // @abimethod({ readonly: true })
    // public calculateUserRewardsForPeriod(userAddress: Account): uint64 {
    //   const apr = this.aprBasisPoints.value
    //   const totalStaked = this.totalStaked.value
    //   const periodSeconds = this.distributionPeriodRounds.value
    // 
    //   // If no total stake or no period defined, return 0
    //   if (totalStaked === 0 || periodSeconds === 0) {
    //     return 0
    //   }
    // 
    //   // Get the user's stake info
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   // If user has no stake, return 0
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   // Get user's stake amount and first stake time
    //   const userStake = stakeInfo.stakedAmount.native
    //   const firstStakeTime = stakeInfo.firstStakeTime.native
    // 
    //   // Check if user has been staked for the minimum period (using first stake time)
    //   const minimumStakeTime: uint64 = ROUNDS_PER_DAY
    //   if (Global.latestTimestamp < firstStakeTime + minimumStakeTime) {
    //     return 0
    //   }
    // 
    //   // Calculate reward rate for the period
    //   // APR is in basis points (e.g., 500 = 5%)
    //   // Convert APR to period rate: (APR / 10000) * (periodSeconds / 31536000)
    //   // where 31536000 is seconds in a year
    //   const yearInSeconds: uint64 = ROUNDS_PER_YEAR
    //   const periodRateNumerator: uint64 = apr * periodSeconds
    //   const periodRateDenominator: uint64 = 10000 * yearInSeconds
    // 
    //   // Calculate reward: userStake * periodRate
    //   const reward: uint64 = (userStake * periodRateNumerator) / periodRateDenominator
    // 
    //   return reward
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user since their last claim
    //  */
    // @abimethod({ readonly: true })
    // public calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const currentPeriod = this.getCurrentPeriod()
    //   const lastClaimedPeriod = stakeInfo.lastClaimedPeriod.native
    // 
    //   // Calculate periods since last claim
    //   const periodsSinceLastClaim: uint64 = currentPeriod > lastClaimedPeriod ? currentPeriod - lastClaimedPeriod : 0
    // 
    //   if (periodsSinceLastClaim === 0) {
    //     return 0
    //   }
    // 
    //   // Calculate reward per period
    //   const rewardPerPeriod = this.calculateUserRewardsForPeriod(userAddress)
    // 
    //   return rewardPerPeriod * periodsSinceLastClaim
    // }
    // 
    // /**
    //  * Helper function to compound rewards for a single user
    //  * Used by the automated distribution system
    //  */
    // private compoundRewardsForUser(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   // Skip if user has no stake
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   // Calculate pending rewards
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   // Skip if no rewards to compound
    //   if (pendingRewards === 0) {
    //     return 0
    //   }
    // 
    //   // Skip if reward pool has insufficient funds for this user
    //   if (this.rewardPool.value < pendingRewards) {
    //     return 0
    //   }
    // 
    //   // Auto-compound: Add rewards to staked amount
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + pendingRewards)
    // 
    //   // Update total rewards earned
    //   stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    // 
    //   // Update last claimed period to current period
    //   stakeInfo.lastClaimedPeriod = new arc4.UintN64(this.getCurrentPeriod())
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(userAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + pendingRewards
    //   this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Distribute and compound rewards for multiple stakers
    //  * This method is designed to be called by a cron job on a daily basis
    //  * Only admin can call this method
    //  */
    // @abimethod()
    // public distributeRewards(stakerAddresses: arc4.Address[]): void {
    //   // Ensure only admin can distribute rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can distribute rewards')
    // 
    //   // Ensure we don't process too many stakers in one call (gas limit protection)
    //   assert(stakerAddresses.length <= 50, 'Too many stakers in single batch')
    // 
    //   let totalDistributed: uint64 = 0
    // 
    //   // Process each staker
    //   for (const staker of stakerAddresses) {
    //     const rewardsCompounded = this.compoundRewardsForUser(staker.native)
    //     totalDistributed = totalDistributed + rewardsCompounded
    //   }
    // 
    //   // Update last distribution time
    //   this.lastDistributionTime.value = Global.latestTimestamp
    // }
    // 
    // /**
    //  * Get all non-zero stakers count (for monitoring purposes)
    //  * Note: This doesn't return the actual addresses due to box iteration limitations
    //  */
    // @abimethod({ readonly: true })
    // public getActiveStakersCount(stakerAddresses: arc4.Address[]): uint64 {
    //   let activeCount: uint64 = 0
    // 
    //   for (const staker of stakerAddresses) {
    //     const stakeInfo = this.getUserStakeInfo(staker.native)
    //     if (stakeInfo.stakedAmount.native > 0) {
    //       activeCount = activeCount + 1
    //     }
    //   }
    // 
    //   return activeCount
    // }
    // 
    // /**
    //  * Update the APR basis points
    //  * Only the admin can call this
    //  */
    // @abimethod()
    // public updateAPR(newAprBasisPoints: uint64): void {
    //   // Ensure only admin can update APR
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update APR')
    // 
    //   // Update APR
    //   this.aprBasisPoints.value = newAprBasisPoints
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.lastClaimedPeriod.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     this.aprBasisPoints.value,
    //     this.lastDistributionTime.value,
    //     this.distributionPeriodRounds.value,
    //     this.minimumStake.value,
    //     this.rewardPool.value,
    //     this.getCurrentPeriod(),
    concat
    // smart_contracts/staking/contract.algo.ts:61
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    uncover 2
    itob
    // smart_contracts/staking/contract.algo.ts:56-487
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    // public distributionPeriodRounds = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       lastClaimedPeriod: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Calculate the current distribution period
    //  */
    // public getCurrentPeriod(): uint64 {
    //   const periodSeconds = this.distributionPeriodRounds.value
    //   if (periodSeconds === 0) return 0
    //   return Global.latestTimestamp / periodSeconds
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   aprBasisPoints: uint64,
    //   distributionPeriodSeconds: uint64,
    //   minimumStake: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.aprBasisPoints.value = aprBasisPoints
    //   this.lastDistributionTime.value = Global.latestTimestamp
    //   this.distributionPeriodRounds.value = distributionPeriodSeconds
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    // 
    //   // Get the current user stake info
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the initial claim period to current period
    //     stakeInfo.lastClaimedPeriod = new arc4.UintN64(this.getCurrentPeriod())
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Txn.sender,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate rewards for a specific user for a given period
    //  * This calculates rewards per distribution period
    //  */
    // @abimethod({ readonly: true })
    // public calculateUserRewardsForPeriod(userAddress: Account): uint64 {
    //   const apr = this.aprBasisPoints.value
    //   const totalStaked = this.totalStaked.value
    //   const periodSeconds = this.distributionPeriodRounds.value
    // 
    //   // If no total stake or no period defined, return 0
    //   if (totalStaked === 0 || periodSeconds === 0) {
    //     return 0
    //   }
    // 
    //   // Get the user's stake info
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   // If user has no stake, return 0
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   // Get user's stake amount and first stake time
    //   const userStake = stakeInfo.stakedAmount.native
    //   const firstStakeTime = stakeInfo.firstStakeTime.native
    // 
    //   // Check if user has been staked for the minimum period (using first stake time)
    //   const minimumStakeTime: uint64 = ROUNDS_PER_DAY
    //   if (Global.latestTimestamp < firstStakeTime + minimumStakeTime) {
    //     return 0
    //   }
    // 
    //   // Calculate reward rate for the period
    //   // APR is in basis points (e.g., 500 = 5%)
    //   // Convert APR to period rate: (APR / 10000) * (periodSeconds / 31536000)
    //   // where 31536000 is seconds in a year
    //   const yearInSeconds: uint64 = ROUNDS_PER_YEAR
    //   const periodRateNumerator: uint64 = apr * periodSeconds
    //   const periodRateDenominator: uint64 = 10000 * yearInSeconds
    // 
    //   // Calculate reward: userStake * periodRate
    //   const reward: uint64 = (userStake * periodRateNumerator) / periodRateDenominator
    // 
    //   return reward
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user since their last claim
    //  */
    // @abimethod({ readonly: true })
    // public calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const currentPeriod = this.getCurrentPeriod()
    //   const lastClaimedPeriod = stakeInfo.lastClaimedPeriod.native
    // 
    //   // Calculate periods since last claim
    //   const periodsSinceLastClaim: uint64 = currentPeriod > lastClaimedPeriod ? currentPeriod - lastClaimedPeriod : 0
    // 
    //   if (periodsSinceLastClaim === 0) {
    //     return 0
    //   }
    // 
    //   // Calculate reward per period
    //   const rewardPerPeriod = this.calculateUserRewardsForPeriod(userAddress)
    // 
    //   return rewardPerPeriod * periodsSinceLastClaim
    // }
    // 
    // /**
    //  * Helper function to compound rewards for a single user
    //  * Used by the automated distribution system
    //  */
    // private compoundRewardsForUser(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   // Skip if user has no stake
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   // Calculate pending rewards
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   // Skip if no rewards to compound
    //   if (pendingRewards === 0) {
    //     return 0
    //   }
    // 
    //   // Skip if reward pool has insufficient funds for this user
    //   if (this.rewardPool.value < pendingRewards) {
    //     return 0
    //   }
    // 
    //   // Auto-compound: Add rewards to staked amount
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + pendingRewards)
    // 
    //   // Update total rewards earned
    //   stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    // 
    //   // Update last claimed period to current period
    //   stakeInfo.lastClaimedPeriod = new arc4.UintN64(this.getCurrentPeriod())
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(userAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + pendingRewards
    //   this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Distribute and compound rewards for multiple stakers
    //  * This method is designed to be called by a cron job on a daily basis
    //  * Only admin can call this method
    //  */
    // @abimethod()
    // public distributeRewards(stakerAddresses: arc4.Address[]): void {
    //   // Ensure only admin can distribute rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can distribute rewards')
    // 
    //   // Ensure we don't process too many stakers in one call (gas limit protection)
    //   assert(stakerAddresses.length <= 50, 'Too many stakers in single batch')
    // 
    //   let totalDistributed: uint64 = 0
    // 
    //   // Process each staker
    //   for (const staker of stakerAddresses) {
    //     const rewardsCompounded = this.compoundRewardsForUser(staker.native)
    //     totalDistributed = totalDistributed + rewardsCompounded
    //   }
    // 
    //   // Update last distribution time
    //   this.lastDistributionTime.value = Global.latestTimestamp
    // }
    // 
    // /**
    //  * Get all non-zero stakers count (for monitoring purposes)
    //  * Note: This doesn't return the actual addresses due to box iteration limitations
    //  */
    // @abimethod({ readonly: true })
    // public getActiveStakersCount(stakerAddresses: arc4.Address[]): uint64 {
    //   let activeCount: uint64 = 0
    // 
    //   for (const staker of stakerAddresses) {
    //     const stakeInfo = this.getUserStakeInfo(staker.native)
    //     if (stakeInfo.stakedAmount.native > 0) {
    //       activeCount = activeCount + 1
    //     }
    //   }
    // 
    //   return activeCount
    // }
    // 
    // /**
    //  * Update the APR basis points
    //  * Only the admin can call this
    //  */
    // @abimethod()
    // public updateAPR(newAprBasisPoints: uint64): void {
    //   // Ensure only admin can update APR
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update APR')
    // 
    //   // Update APR
    //   this.aprBasisPoints.value = newAprBasisPoints
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.lastClaimedPeriod.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     this.aprBasisPoints.value,
    //     this.lastDistributionTime.value,
    //     this.distributionPeriodRounds.value,
    //     this.minimumStake.value,
    //     this.rewardPool.value,
    //     this.getCurrentPeriod(),
    concat
    // smart_contracts/staking/contract.algo.ts:487
    // this.getCurrentPeriod(),
    swap
    itob
    // smart_contracts/staking/contract.algo.ts:56-487
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    // public distributionPeriodRounds = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       lastClaimedPeriod: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Calculate the current distribution period
    //  */
    // public getCurrentPeriod(): uint64 {
    //   const periodSeconds = this.distributionPeriodRounds.value
    //   if (periodSeconds === 0) return 0
    //   return Global.latestTimestamp / periodSeconds
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   aprBasisPoints: uint64,
    //   distributionPeriodSeconds: uint64,
    //   minimumStake: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.aprBasisPoints.value = aprBasisPoints
    //   this.lastDistributionTime.value = Global.latestTimestamp
    //   this.distributionPeriodRounds.value = distributionPeriodSeconds
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    // 
    //   // Get the current user stake info
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the initial claim period to current period
    //     stakeInfo.lastClaimedPeriod = new arc4.UintN64(this.getCurrentPeriod())
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Txn.sender,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate rewards for a specific user for a given period
    //  * This calculates rewards per distribution period
    //  */
    // @abimethod({ readonly: true })
    // public calculateUserRewardsForPeriod(userAddress: Account): uint64 {
    //   const apr = this.aprBasisPoints.value
    //   const totalStaked = this.totalStaked.value
    //   const periodSeconds = this.distributionPeriodRounds.value
    // 
    //   // If no total stake or no period defined, return 0
    //   if (totalStaked === 0 || periodSeconds === 0) {
    //     return 0
    //   }
    // 
    //   // Get the user's stake info
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   // If user has no stake, return 0
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   // Get user's stake amount and first stake time
    //   const userStake = stakeInfo.stakedAmount.native
    //   const firstStakeTime = stakeInfo.firstStakeTime.native
    // 
    //   // Check if user has been staked for the minimum period (using first stake time)
    //   const minimumStakeTime: uint64 = ROUNDS_PER_DAY
    //   if (Global.latestTimestamp < firstStakeTime + minimumStakeTime) {
    //     return 0
    //   }
    // 
    //   // Calculate reward rate for the period
    //   // APR is in basis points (e.g., 500 = 5%)
    //   // Convert APR to period rate: (APR / 10000) * (periodSeconds / 31536000)
    //   // where 31536000 is seconds in a year
    //   const yearInSeconds: uint64 = ROUNDS_PER_YEAR
    //   const periodRateNumerator: uint64 = apr * periodSeconds
    //   const periodRateDenominator: uint64 = 10000 * yearInSeconds
    // 
    //   // Calculate reward: userStake * periodRate
    //   const reward: uint64 = (userStake * periodRateNumerator) / periodRateDenominator
    // 
    //   return reward
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user since their last claim
    //  */
    // @abimethod({ readonly: true })
    // public calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const currentPeriod = this.getCurrentPeriod()
    //   const lastClaimedPeriod = stakeInfo.lastClaimedPeriod.native
    // 
    //   // Calculate periods since last claim
    //   const periodsSinceLastClaim: uint64 = currentPeriod > lastClaimedPeriod ? currentPeriod - lastClaimedPeriod : 0
    // 
    //   if (periodsSinceLastClaim === 0) {
    //     return 0
    //   }
    // 
    //   // Calculate reward per period
    //   const rewardPerPeriod = this.calculateUserRewardsForPeriod(userAddress)
    // 
    //   return rewardPerPeriod * periodsSinceLastClaim
    // }
    // 
    // /**
    //  * Helper function to compound rewards for a single user
    //  * Used by the automated distribution system
    //  */
    // private compoundRewardsForUser(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   // Skip if user has no stake
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   // Calculate pending rewards
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   // Skip if no rewards to compound
    //   if (pendingRewards === 0) {
    //     return 0
    //   }
    // 
    //   // Skip if reward pool has insufficient funds for this user
    //   if (this.rewardPool.value < pendingRewards) {
    //     return 0
    //   }
    // 
    //   // Auto-compound: Add rewards to staked amount
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + pendingRewards)
    // 
    //   // Update total rewards earned
    //   stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    // 
    //   // Update last claimed period to current period
    //   stakeInfo.lastClaimedPeriod = new arc4.UintN64(this.getCurrentPeriod())
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(userAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + pendingRewards
    //   this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Distribute and compound rewards for multiple stakers
    //  * This method is designed to be called by a cron job on a daily basis
    //  * Only admin can call this method
    //  */
    // @abimethod()
    // public distributeRewards(stakerAddresses: arc4.Address[]): void {
    //   // Ensure only admin can distribute rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can distribute rewards')
    // 
    //   // Ensure we don't process too many stakers in one call (gas limit protection)
    //   assert(stakerAddresses.length <= 50, 'Too many stakers in single batch')
    // 
    //   let totalDistributed: uint64 = 0
    // 
    //   // Process each staker
    //   for (const staker of stakerAddresses) {
    //     const rewardsCompounded = this.compoundRewardsForUser(staker.native)
    //     totalDistributed = totalDistributed + rewardsCompounded
    //   }
    // 
    //   // Update last distribution time
    //   this.lastDistributionTime.value = Global.latestTimestamp
    // }
    // 
    // /**
    //  * Get all non-zero stakers count (for monitoring purposes)
    //  * Note: This doesn't return the actual addresses due to box iteration limitations
    //  */
    // @abimethod({ readonly: true })
    // public getActiveStakersCount(stakerAddresses: arc4.Address[]): uint64 {
    //   let activeCount: uint64 = 0
    // 
    //   for (const staker of stakerAddresses) {
    //     const stakeInfo = this.getUserStakeInfo(staker.native)
    //     if (stakeInfo.stakedAmount.native > 0) {
    //       activeCount = activeCount + 1
    //     }
    //   }
    // 
    //   return activeCount
    // }
    // 
    // /**
    //  * Update the APR basis points
    //  * Only the admin can call this
    //  */
    // @abimethod()
    // public updateAPR(newAprBasisPoints: uint64): void {
    //   // Ensure only admin can update APR
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update APR')
    // 
    //   // Update APR
    //   this.aprBasisPoints.value = newAprBasisPoints
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.lastClaimedPeriod.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     this.aprBasisPoints.value,
    //     this.lastDistributionTime.value,
    //     this.distributionPeriodRounds.value,
    //     this.minimumStake.value,
    //     this.rewardPool.value,
    //     this.getCurrentPeriod(),
    concat
    dup
    len
    pushint 8 // 8
    /
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:490
    // return result
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.emergencyWithdrawRewards(amount: uint64) -> void:
emergencyWithdrawRewards:
    // smart_contracts/staking/contract.algo.ts:496-497
    // @abimethod()
    // public emergencyWithdrawRewards(amount: uint64): void {
    proto 1 0
    // smart_contracts/staking/contract.algo.ts:55
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_2 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:500
    // assert(Txn.sender === adminAddr, 'Only admin can emergency withdraw')
    txn Sender
    dig 1
    ==
    assert // Only admin can emergency withdraw
    // smart_contracts/staking/contract.algo.ts:61
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:503
    // assert(this.rewardPool.value >= amount, 'Insufficient reward pool')
    frame_dig -1
    >=
    assert // Insufficient reward pool
    // smart_contracts/staking/contract.algo.ts:61
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:506
    // this.rewardPool.value = this.rewardPool.value - amount
    frame_dig -1
    -
    // smart_contracts/staking/contract.algo.ts:61
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "rewardPool"
    // smart_contracts/staking/contract.algo.ts:506
    // this.rewardPool.value = this.rewardPool.value - amount
    swap
    app_global_put
    // smart_contracts/staking/contract.algo.ts:54
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:510-517
    // itxn
    //   .assetTransfer({
    //     assetReceiver: adminAddr,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_begin
    itxn_field XferAsset
    frame_dig -1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/staking/contract.algo.ts:510-516
    // itxn
    //   .assetTransfer({
    //     assetReceiver: adminAddr,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/contract.algo.ts:515
    // fee: 1000,
    pushint 1000 // 1000
    itxn_field Fee
    // smart_contracts/staking/contract.algo.ts:510-517
    // itxn
    //   .assetTransfer({
    //     assetReceiver: adminAddr,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.deleteUserBox(userAddress: bytes) -> void:
deleteUserBox:
    // smart_contracts/staking/contract.algo.ts:524-525
    // @abimethod()
    // public deleteUserBox(userAddress: Account): void {
    proto 1 0
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:55
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    dup
    bytec_2 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:530
    // assert(Txn.sender === boxOwner || Txn.sender === adminAddr, 'Only box owner or admin can delete box')
    txn Sender
    frame_dig -1
    ==
    bnz deleteUserBox_bool_true@2
    txn Sender
    frame_dig 1
    ==
    bz deleteUserBox_bool_false@3

deleteUserBox_bool_true@2:
    intc_1 // 1

deleteUserBox_bool_merge@4:
    // smart_contracts/staking/contract.algo.ts:530
    // assert(Txn.sender === boxOwner || Txn.sender === adminAddr, 'Only box owner or admin can delete box')
    assert // Only box owner or admin can delete box
    // smart_contracts/staking/contract.algo.ts:533
    // const stakeInfo = this.getUserStakeInfo(userAddress)
    frame_dig -1
    callsub getUserStakeInfo
    // smart_contracts/staking/contract.algo.ts:534
    // assert(stakeInfo.stakedAmount.native === 0, 'User still has active stake')
    intc_0 // 0
    extract_uint64
    !
    assert // User still has active stake
    // smart_contracts/staking/contract.algo.ts:63
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    bytec 9 // "stakers"
    // smart_contracts/staking/contract.algo.ts:537
    // const userBox = this.stakers(userAddress)
    frame_dig -1
    // smart_contracts/staking/contract.algo.ts:63
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    concat
    // smart_contracts/staking/contract.algo.ts:537
    // const userBox = this.stakers(userAddress)
    dup
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:538
    // if (userBox.exists) {
    box_len
    bury 1
    bz deleteUserBox_after_if_else@6
    // smart_contracts/staking/contract.algo.ts:539
    // userBox.delete()
    frame_dig 0
    box_del
    pop

deleteUserBox_after_if_else@6:
    retsub

deleteUserBox_bool_false@3:
    intc_0 // 0
    b deleteUserBox_bool_merge@4
