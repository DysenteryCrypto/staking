#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 4 8
    bytecblock "adminAddress" "asset" "totalStaked" "rewardPool" "accumulatedRewardsPerShare" "lastRewardTime" "minimumStake" "weeklyRewards" "rewardPeriod" 0x151f7c75 "stakers"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    bytec_1 // "asset"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    bytec_0 // "adminAddress"
    global ZeroAddress
    app_global_put
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_2 // "totalStaked"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:55
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    bytec 5 // "lastRewardTime"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:56
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    bytec 6 // "minimumStake"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    bytec_3 // "rewardPool"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:58
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    bytec 4 // "accumulatedRewardsPerShare"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:61
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    bytec 7 // "weeklyRewards"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:62
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    bytec 8 // "rewardPeriod"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txn NumAppArgs
    bz main_bare_routing@24
    pushbytess 0x5d789521 0x080f6ecd 0x667c5d30 0x9ffd3e53 0x0890bd58 0x21f1ddff 0xb3b70146 0xbf8b766d 0x183838e9 0x21b1b022 0x82ab1ec4 0x15766b09 0xbfe31564 0xce963b1d 0xdc9a2a05 0x1e2b52ab 0x1b874ad6 // method "getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)", method "storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void", method "initialize(asset,account,uint64,uint64,uint64)void", method "optInToAsset()void", method "stake()void", method "withdraw(uint64)void", method "addRewards()void", method "getCurrentAPY()uint64", method "getPendingRewards(account)uint64", method "triggerRewardDistribution()void", method "updateAdmin(account)void", method "getUserStats(account)uint64[]", method "getContractStats()uint64[]", method "emergencyWithdrawRewards(uint64)void", method "deleteUserBox(account)void", method "updateWeeklyRewards(uint64)void", method "updateRewardPeriod(uint64)void"
    txna ApplicationArgs 0
    match main_getUserStakeInfo_route@5 main_storeUserStakeInfo_route@6 main_initialize_route@7 main_optInToAsset_route@8 main_stake_route@9 main_withdraw_route@10 main_addRewards_route@11 main_getCurrentAPY_route@12 main_getPendingRewards_route@13 main_triggerRewardDistribution_route@14 main_updateAdmin_route@15 main_getUserStats_route@16 main_getContractStats_route@17 main_emergencyWithdrawRewards_route@18 main_deleteUserBox_route@19 main_updateWeeklyRewards_route@20 main_updateRewardPeriod_route@21

main_after_if_else@28:
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    intc_0 // 0
    return

main_updateRewardPeriod_route@21:
    // smart_contracts/staking/contract.algo.ts:483
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/staking/contract.algo.ts:483
    // @abimethod()
    callsub updateRewardPeriod
    intc_1 // 1
    return

main_updateWeeklyRewards_route@20:
    // smart_contracts/staking/contract.algo.ts:467
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/staking/contract.algo.ts:467
    // @abimethod()
    callsub updateWeeklyRewards
    intc_1 // 1
    return

main_deleteUserBox_route@19:
    // smart_contracts/staking/contract.algo.ts:445
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:445
    // @abimethod()
    callsub deleteUserBox
    intc_1 // 1
    return

main_emergencyWithdrawRewards_route@18:
    // smart_contracts/staking/contract.algo.ts:417
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/staking/contract.algo.ts:417
    // @abimethod()
    callsub emergencyWithdrawRewards
    intc_1 // 1
    return

main_getContractStats_route@17:
    // smart_contracts/staking/contract.algo.ts:396
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getContractStats
    bytec 9 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getUserStats_route@16:
    // smart_contracts/staking/contract.algo.ts:376
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:376
    // @abimethod({ readonly: true })
    callsub getUserStats
    bytec 9 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_updateAdmin_route@15:
    // smart_contracts/staking/contract.algo.ts:363
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:363
    // @abimethod()
    callsub updateAdmin
    intc_1 // 1
    return

main_triggerRewardDistribution_route@14:
    // smart_contracts/staking/contract.algo.ts:349
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub triggerRewardDistribution
    intc_1 // 1
    return

main_getPendingRewards_route@13:
    // smart_contracts/staking/contract.algo.ts:340
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:340
    // @abimethod({ readonly: true })
    callsub getPendingRewards
    itob
    bytec 9 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getCurrentAPY_route@12:
    // smart_contracts/staking/contract.algo.ts:320
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getCurrentAPY
    itob
    bytec 9 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_addRewards_route@11:
    // smart_contracts/staking/contract.algo.ts:296
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub addRewards
    intc_1 // 1
    return

main_withdraw_route@10:
    // smart_contracts/staking/contract.algo.ts:249
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/staking/contract.algo.ts:249
    // @abimethod()
    callsub withdraw
    intc_1 // 1
    return

main_stake_route@9:
    // smart_contracts/staking/contract.algo.ts:200
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub stake
    intc_1 // 1
    return

main_optInToAsset_route@8:
    // smart_contracts/staking/contract.algo.ts:178
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub optInToAsset
    intc_1 // 1
    return

main_initialize_route@7:
    // smart_contracts/staking/contract.algo.ts:147
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    btoi
    txnas Accounts
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    // smart_contracts/staking/contract.algo.ts:147
    // @abimethod()
    callsub initialize
    intc_1 // 1
    return

main_storeUserStakeInfo_route@6:
    // smart_contracts/staking/contract.algo.ts:88
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    // smart_contracts/staking/contract.algo.ts:88
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    callsub storeUserStakeInfo
    pop
    intc_1 // 1
    return

main_getUserStakeInfo_route@5:
    // smart_contracts/staking/contract.algo.ts:69
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:69
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    callsub getUserStakeInfo
    bytec 9 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@24:
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txn OnCompletion
    bnz main_after_if_else@28
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getUserStakeInfo(userAddress: bytes) -> bytes:
getUserStakeInfo:
    // smart_contracts/staking/contract.algo.ts:69
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    proto 1 1
    // smart_contracts/staking/contract.algo.ts:64
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    bytec 10 // "stakers"
    // smart_contracts/staking/contract.algo.ts:70
    // const userBox = this.stakers(userAddress)
    frame_dig -1
    // smart_contracts/staking/contract.algo.ts:64
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    concat
    // smart_contracts/staking/contract.algo.ts:70
    // const userBox = this.stakers(userAddress)
    dup
    // smart_contracts/staking/contract.algo.ts:72
    // if (userBox.exists) {
    box_len
    bury 1
    bz getUserStakeInfo_else_body@2
    // smart_contracts/staking/contract.algo.ts:73
    // return userBox.value.copy()
    frame_dig 0
    box_get
    assert // Box must have value
    swap
    retsub

getUserStakeInfo_else_body@2:
    // smart_contracts/staking/contract.algo.ts:75-81
    // return new UserStakeInfo({
    //   stakedAmount: new arc4.UintN64(0),
    //   firstStakeTime: new arc4.UintN64(0),
    //   lastStakeTime: new arc4.UintN64(0),
    //   totalRewardsEarned: new arc4.UintN64(0),
    //   rewardDebt: new arc4.UintN64(0),
    // })
    pushbytes 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000
    swap
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.storeUserStakeInfo(userAddress: bytes, stakeInfo: bytes) -> bytes:
storeUserStakeInfo:
    // smart_contracts/staking/contract.algo.ts:88
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    proto 2 1
    // smart_contracts/staking/contract.algo.ts:64
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    bytec 10 // "stakers"
    frame_dig -2
    concat
    // smart_contracts/staking/contract.algo.ts:89
    // this.stakers(userAddress).value = stakeInfo.copy()
    frame_dig -1
    box_put
    frame_dig -1
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.updateRewards() -> void:
updateRewards:
    // smart_contracts/staking/contract.algo.ts:95
    // private updateRewards(): void {
    proto 0 0
    // smart_contracts/staking/contract.algo.ts:96
    // const currentTime = Global.latestTimestamp
    global LatestTimestamp
    dup
    // smart_contracts/staking/contract.algo.ts:55
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 5 // "lastRewardTime"
    app_global_get_ex
    swap
    dup
    cover 2
    cover 3
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:62
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 8 // "rewardPeriod"
    app_global_get_ex
    swap
    dup
    cover 2
    cover 4
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:101
    // if (currentTime >= lastReward + rewardPeriod && this.totalStaked.value > 0) {
    +
    >=
    bz updateRewards_after_if_else@3
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_2 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:101
    // if (currentTime >= lastReward + rewardPeriod && this.totalStaked.value > 0) {
    bz updateRewards_after_if_else@3
    // smart_contracts/staking/contract.algo.ts:103
    // const periodsPassed: uint64 = (currentTime - lastReward) / rewardPeriod
    frame_dig 0
    frame_dig 1
    dup
    cover 2
    -
    frame_dig 2
    dup
    cover 2
    /
    // smart_contracts/staking/contract.algo.ts:61
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 7 // "weeklyRewards"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:107
    // const totalRewards: uint64 = rewardPerPeriod * periodsPassed
    dig 1
    *
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_2 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:111
    // const rewardPerShare: uint64 = totalRewards / totalStaked
    dig 1
    swap
    /
    // smart_contracts/staking/contract.algo.ts:58
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 4 // "accumulatedRewardsPerShare"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:113
    // this.accumulatedRewardsPerShare.value = this.accumulatedRewardsPerShare.value + rewardPerShare
    +
    // smart_contracts/staking/contract.algo.ts:58
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    bytec 4 // "accumulatedRewardsPerShare"
    // smart_contracts/staking/contract.algo.ts:113
    // this.accumulatedRewardsPerShare.value = this.accumulatedRewardsPerShare.value + rewardPerShare
    swap
    app_global_put
    // smart_contracts/staking/contract.algo.ts:116
    // this.lastRewardTime.value = lastReward + (periodsPassed * rewardPeriod)
    swap
    uncover 2
    *
    uncover 2
    +
    // smart_contracts/staking/contract.algo.ts:55
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    bytec 5 // "lastRewardTime"
    // smart_contracts/staking/contract.algo.ts:116
    // this.lastRewardTime.value = lastReward + (periodsPassed * rewardPeriod)
    swap
    app_global_put
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_3 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:119
    // this.rewardPool.value = this.rewardPool.value - totalRewards
    swap
    -
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    bytec_3 // "rewardPool"
    // smart_contracts/staking/contract.algo.ts:119
    // this.rewardPool.value = this.rewardPool.value - totalRewards
    swap
    app_global_put

updateRewards_after_if_else@3:
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.calculatePendingRewards(userAddress: bytes) -> uint64:
calculatePendingRewards:
    // smart_contracts/staking/contract.algo.ts:126
    // private calculatePendingRewards(userAddress: Account): uint64 {
    proto 1 1
    pushbytes ""
    dup
    // smart_contracts/staking/contract.algo.ts:127
    // const stakeInfo = this.getUserStakeInfo(userAddress)
    frame_dig -1
    callsub getUserStakeInfo
    dup
    // smart_contracts/staking/contract.algo.ts:129
    // if (stakeInfo.stakedAmount.native === 0) {
    intc_0 // 0
    extract_uint64
    dup
    bnz calculatePendingRewards_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:130
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

calculatePendingRewards_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:58
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 4 // "accumulatedRewardsPerShare"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:135
    // const userRewardDebt = stakeInfo.rewardDebt.native
    frame_dig 2
    pushint 32 // 32
    extract_uint64
    dup
    frame_bury 1
    // smart_contracts/staking/contract.algo.ts:138
    // const totalEarned: uint64 = userStake * accRewardsPerShare
    frame_dig 3
    uncover 2
    *
    dup
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:139
    // const pendingRewards: uint64 = totalEarned > userRewardDebt ? totalEarned - userRewardDebt : 0
    <
    bz calculatePendingRewards_ternary_false@4
    frame_dig 0
    frame_dig 1
    -

calculatePendingRewards_ternary_merge@5:
    // smart_contracts/staking/contract.algo.ts:141
    // return pendingRewards
    frame_bury 0
    retsub

calculatePendingRewards_ternary_false@4:
    // smart_contracts/staking/contract.algo.ts:139
    // const pendingRewards: uint64 = totalEarned > userRewardDebt ? totalEarned - userRewardDebt : 0
    intc_0 // 0
    b calculatePendingRewards_ternary_merge@5


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.initialize(asset: uint64, adminAddress: bytes, minimumStake: uint64, weeklyRewards: uint64, rewardPeriod: uint64) -> void:
initialize:
    // smart_contracts/staking/contract.algo.ts:147-154
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   minimumStake: uint64,
    //   weeklyRewards: uint64,
    //   rewardPeriod: uint64,
    // ): void {
    proto 5 0
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:156
    // assert(this.asset.value === Asset(), 'Already initialized')
    !
    assert // Already initialized
    // smart_contracts/staking/contract.algo.ts:159
    // assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can initialize
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    bytec_1 // "asset"
    // smart_contracts/staking/contract.algo.ts:162
    // this.asset.value = asset
    frame_dig -5
    app_global_put
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    bytec_0 // "adminAddress"
    // smart_contracts/staking/contract.algo.ts:163
    // this.adminAddress.value = adminAddress
    frame_dig -4
    app_global_put
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_2 // "totalStaked"
    // smart_contracts/staking/contract.algo.ts:164
    // this.totalStaked.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:55
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    bytec 5 // "lastRewardTime"
    // smart_contracts/staking/contract.algo.ts:165
    // this.lastRewardTime.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/staking/contract.algo.ts:56
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    bytec 6 // "minimumStake"
    // smart_contracts/staking/contract.algo.ts:166
    // this.minimumStake.value = minimumStake
    frame_dig -3
    app_global_put
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    bytec_3 // "rewardPool"
    // smart_contracts/staking/contract.algo.ts:167
    // this.rewardPool.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:58
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    bytec 4 // "accumulatedRewardsPerShare"
    // smart_contracts/staking/contract.algo.ts:168
    // this.accumulatedRewardsPerShare.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:61
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    bytec 7 // "weeklyRewards"
    // smart_contracts/staking/contract.algo.ts:171
    // this.weeklyRewards.value = weeklyRewards
    frame_dig -2
    app_global_put
    // smart_contracts/staking/contract.algo.ts:62
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    bytec 8 // "rewardPeriod"
    // smart_contracts/staking/contract.algo.ts:172
    // this.rewardPeriod.value = rewardPeriod
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.optInToAsset() -> void:
optInToAsset:
    // smart_contracts/staking/contract.algo.ts:178-179
    // @abimethod()
    // public optInToAsset(): void {
    proto 0 0
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_0 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:182
    // assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    txn Sender
    global CreatorAddress
    ==
    bnz optInToAsset_bool_true@2
    txn Sender
    frame_dig 0
    ==
    bz optInToAsset_bool_false@3

optInToAsset_bool_true@2:
    intc_1 // 1

optInToAsset_bool_merge@4:
    // smart_contracts/staking/contract.algo.ts:182
    // assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    assert // Only creator or admin can opt in
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:186-192
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/staking/contract.algo.ts:188
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    swap
    itxn_field XferAsset
    // smart_contracts/staking/contract.algo.ts:189
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/staking/contract.algo.ts:186-191
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/contract.algo.ts:186-192
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_submit
    retsub

optInToAsset_bool_false@3:
    intc_0 // 0
    b optInToAsset_bool_merge@4


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.stake() -> void:
stake:
    // smart_contracts/staking/contract.algo.ts:200-201
    // @abimethod()
    // public stake(): void {
    proto 0 0
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:204
    // assert(this.asset.value !== Asset(), 'Contract not initialized')
    assert // Contract not initialized
    // smart_contracts/staking/contract.algo.ts:207
    // assert(Global.groupSize === 2, 'Expected 2 txns in group')
    global GroupSize
    pushint 2 // 2
    ==
    assert // Expected 2 txns in group
    // smart_contracts/staking/contract.algo.ts:210
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    gtxns TypeEnum
    dup
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/staking/contract.algo.ts:211
    // assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    intc_2 // 4
    ==
    assert // Transaction 0 must be asset transfer
    // smart_contracts/staking/contract.algo.ts:210
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:212
    // assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // Asset transfer must be to contract
    // smart_contracts/staking/contract.algo.ts:210
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:213
    // assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    gtxns AssetAmount
    dup
    cover 2
    assert // Must stake non-zero amount
    // smart_contracts/staking/contract.algo.ts:210
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:214
    // assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    gtxns XferAsset
    ==
    assert // Incorrect asset ID
    // smart_contracts/staking/contract.algo.ts:56
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 6 // "minimumStake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:219
    // const senderAddress = Txn.sender
    txn Sender
    dup
    // smart_contracts/staking/contract.algo.ts:222
    // const stakeInfo = this.getUserStakeInfo(senderAddress)
    callsub getUserStakeInfo
    dupn 2
    // smart_contracts/staking/contract.algo.ts:225
    // if (stakeInfo.stakedAmount.native === 0) {
    intc_0 // 0
    extract_uint64
    bnz stake_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:226
    // assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    frame_dig 0
    frame_dig 1
    >=
    assert // Initial stake below minimum
    // smart_contracts/staking/contract.algo.ts:228
    // stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    global LatestTimestamp
    itob
    frame_dig 3
    swap
    replace2 8
    frame_bury 4

stake_after_if_else@2:
    frame_dig 4
    // smart_contracts/staking/contract.algo.ts:232
    // stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    dup
    intc_0 // 0
    extract_uint64
    frame_dig 0
    dup
    cover 3
    +
    itob
    replace2 0
    // smart_contracts/staking/contract.algo.ts:233
    // stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    global LatestTimestamp
    itob
    replace2 16
    // smart_contracts/staking/contract.algo.ts:236
    // stakeInfo.rewardDebt = new arc4.UintN64(stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value)
    dup
    intc_0 // 0
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:58
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 4 // "accumulatedRewardsPerShare"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:236
    // stakeInfo.rewardDebt = new arc4.UintN64(stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value)
    *
    itob
    replace2 32
    // smart_contracts/staking/contract.algo.ts:239
    // this.storeUserStakeInfo(senderAddress, stakeInfo)
    frame_dig 2
    swap
    callsub storeUserStakeInfo
    pop
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_2 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:242
    // this.totalStaked.value = this.totalStaked.value + stakeAmount
    +
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_2 // "totalStaked"
    // smart_contracts/staking/contract.algo.ts:242
    // this.totalStaked.value = this.totalStaked.value + stakeAmount
    swap
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.withdraw(amount: uint64) -> void:
withdraw:
    // smart_contracts/staking/contract.algo.ts:249-250
    // @abimethod()
    // public withdraw(amount: uint64): void {
    proto 1 0
    // smart_contracts/staking/contract.algo.ts:251
    // const senderAddress = Txn.sender
    txn Sender
    dup
    // smart_contracts/staking/contract.algo.ts:252
    // const stakeInfo = this.getUserStakeInfo(senderAddress)
    callsub getUserStakeInfo
    dup
    // smart_contracts/staking/contract.algo.ts:255
    // assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    intc_0 // 0
    extract_uint64
    dupn 2
    assert // No stake found
    // smart_contracts/staking/contract.algo.ts:256
    // assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    frame_dig -1
    dig 1
    <=
    assert // Withdrawal amount exceeds stake
    // smart_contracts/staking/contract.algo.ts:257
    // assert(amount > 0, 'Withdrawal amount must be positive')
    frame_dig -1
    assert // Withdrawal amount must be positive
    // smart_contracts/staking/contract.algo.ts:261
    // if (amount < stakeInfo.stakedAmount.native) {
    frame_dig -1
    >
    bz withdraw_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:262
    // const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    frame_dig 2
    frame_dig -1
    -
    // smart_contracts/staking/contract.algo.ts:56
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 6 // "minimumStake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:264
    // assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    >=
    assert // Remaining stake would be below minimum

withdraw_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:268
    // stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    frame_dig 2
    frame_dig -1
    -
    itob
    frame_dig 1
    swap
    replace2 0
    // smart_contracts/staking/contract.algo.ts:271
    // stakeInfo.rewardDebt = new arc4.UintN64(stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value)
    dup
    intc_0 // 0
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:58
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 4 // "accumulatedRewardsPerShare"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:271
    // stakeInfo.rewardDebt = new arc4.UintN64(stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value)
    *
    itob
    replace2 32
    // smart_contracts/staking/contract.algo.ts:274
    // this.storeUserStakeInfo(senderAddress, stakeInfo)
    frame_dig 0
    dup
    uncover 2
    callsub storeUserStakeInfo
    pop
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_2 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:277
    // this.totalStaked.value = this.totalStaked.value - amount
    frame_dig -1
    -
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_2 // "totalStaked"
    // smart_contracts/staking/contract.algo.ts:277
    // this.totalStaked.value = this.totalStaked.value - amount
    swap
    app_global_put
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:281-288
    // itxn
    //   .assetTransfer({
    //     assetReceiver: senderAddress,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_begin
    itxn_field XferAsset
    frame_dig -1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/staking/contract.algo.ts:281-287
    // itxn
    //   .assetTransfer({
    //     assetReceiver: senderAddress,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/contract.algo.ts:286
    // fee: 1000,
    pushint 1000 // 1000
    itxn_field Fee
    // smart_contracts/staking/contract.algo.ts:281-288
    // itxn
    //   .assetTransfer({
    //     assetReceiver: senderAddress,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.addRewards() -> void:
addRewards:
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_0 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:300
    // assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    txn Sender
    ==
    assert // Only admin can add rewards
    // smart_contracts/staking/contract.algo.ts:303
    // assert(Global.groupSize === 2, 'Expected 2 txns in group')
    global GroupSize
    pushint 2 // 2
    ==
    assert // Expected 2 txns in group
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:307
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    gtxns TypeEnum
    dup
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/staking/contract.algo.ts:308
    // assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    intc_2 // 4
    ==
    assert // Transaction 0 must be asset transfer
    // smart_contracts/staking/contract.algo.ts:307
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:309
    // assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // Asset transfer must be to contract
    // smart_contracts/staking/contract.algo.ts:307
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:310
    // assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    gtxns AssetAmount
    dup
    assert // Must provide non-zero rewards
    // smart_contracts/staking/contract.algo.ts:307
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:311
    // assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    gtxns XferAsset
    uncover 2
    ==
    assert // Incorrect asset ID
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_3 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:314
    // this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    +
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    bytec_3 // "rewardPool"
    // smart_contracts/staking/contract.algo.ts:314
    // this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    swap
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getCurrentAPY() -> uint64:
getCurrentAPY:
    // smart_contracts/staking/contract.algo.ts:320-321
    // @abimethod({ readonly: true })
    // public getCurrentAPY(): uint64 {
    proto 0 1
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_2 // "totalStaked"
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:324
    // if (totalStaked === 0) {
    bnz getCurrentAPY_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:325
    // return 0 // Return 0 if no tokens staked
    intc_0 // 0
    swap
    retsub

getCurrentAPY_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:61
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 7 // "weeklyRewards"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:329
    // const annualRewards: uint64 = 52 * this.weeklyRewards.value
    pushint 52 // 52
    *
    // smart_contracts/staking/contract.algo.ts:332
    // const apy: uint64 = (annualRewards * 100) / totalStaked
    pushint 100 // 100
    *
    frame_dig 0
    /
    // smart_contracts/staking/contract.algo.ts:334
    // return apy
    swap
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getPendingRewards(userAddress: bytes) -> uint64:
getPendingRewards:
    // smart_contracts/staking/contract.algo.ts:340-341
    // @abimethod({ readonly: true })
    // public getPendingRewards(userAddress: Account): uint64 {
    proto 1 1
    // smart_contracts/staking/contract.algo.ts:342
    // return this.calculatePendingRewards(userAddress)
    frame_dig -1
    callsub calculatePendingRewards
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.triggerRewardDistribution() -> void:
triggerRewardDistribution:
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_0 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:353
    // assert(Txn.sender === adminAddr, 'Only admin can trigger distribution')
    txn Sender
    ==
    assert // Only admin can trigger distribution
    // smart_contracts/staking/contract.algo.ts:356
    // this.updateRewards()
    callsub updateRewards
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.updateAdmin(newAdminAddress: bytes) -> void:
updateAdmin:
    // smart_contracts/staking/contract.algo.ts:363-364
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    proto 1 0
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_0 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:367
    // assert(Txn.sender === adminAddr, 'Only admin can update admin')
    txn Sender
    ==
    assert // Only admin can update admin
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    bytec_0 // "adminAddress"
    // smart_contracts/staking/contract.algo.ts:370
    // this.adminAddress.value = newAdminAddress
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getUserStats(userAddress: bytes) -> bytes:
getUserStats:
    // smart_contracts/staking/contract.algo.ts:376-377
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    proto 1 1
    // smart_contracts/staking/contract.algo.ts:378
    // const stakeInfo = this.getUserStakeInfo(userAddress)
    frame_dig -1
    callsub getUserStakeInfo
    // smart_contracts/staking/contract.algo.ts:379
    // const pendingRewards = this.calculatePendingRewards(userAddress)
    frame_dig -1
    callsub calculatePendingRewards
    // smart_contracts/staking/contract.algo.ts:382
    // stakeInfo.stakedAmount.native,
    dig 1
    intc_0 // 0
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:383
    // stakeInfo.firstStakeTime.native,
    dig 2
    intc_3 // 8
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:384
    // stakeInfo.lastStakeTime.native,
    dig 3
    pushint 16 // 16
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:385
    // stakeInfo.totalRewardsEarned.native,
    dig 4
    pushint 24 // 24
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:387
    // stakeInfo.rewardDebt.native,
    uncover 5
    pushint 32 // 32
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:382
    // stakeInfo.stakedAmount.native,
    uncover 4
    itob
    // smart_contracts/staking/contract.algo.ts:383
    // stakeInfo.firstStakeTime.native,
    uncover 4
    itob
    // smart_contracts/staking/contract.algo.ts:382-387
    // stakeInfo.stakedAmount.native,
    // stakeInfo.firstStakeTime.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // pendingRewards,
    // stakeInfo.rewardDebt.native,
    concat
    // smart_contracts/staking/contract.algo.ts:384
    // stakeInfo.lastStakeTime.native,
    uncover 3
    itob
    // smart_contracts/staking/contract.algo.ts:382-387
    // stakeInfo.stakedAmount.native,
    // stakeInfo.firstStakeTime.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // pendingRewards,
    // stakeInfo.rewardDebt.native,
    concat
    // smart_contracts/staking/contract.algo.ts:385
    // stakeInfo.totalRewardsEarned.native,
    uncover 2
    itob
    // smart_contracts/staking/contract.algo.ts:382-387
    // stakeInfo.stakedAmount.native,
    // stakeInfo.firstStakeTime.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // pendingRewards,
    // stakeInfo.rewardDebt.native,
    concat
    // smart_contracts/staking/contract.algo.ts:386
    // pendingRewards,
    uncover 2
    itob
    // smart_contracts/staking/contract.algo.ts:382-387
    // stakeInfo.stakedAmount.native,
    // stakeInfo.firstStakeTime.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // pendingRewards,
    // stakeInfo.rewardDebt.native,
    concat
    // smart_contracts/staking/contract.algo.ts:387
    // stakeInfo.rewardDebt.native,
    swap
    itob
    // smart_contracts/staking/contract.algo.ts:382-387
    // stakeInfo.stakedAmount.native,
    // stakeInfo.firstStakeTime.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // pendingRewards,
    // stakeInfo.rewardDebt.native,
    concat
    dup
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:390
    // return result
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getContractStats() -> bytes:
getContractStats:
    // smart_contracts/staking/contract.algo.ts:398
    // const currentAPY = this.getCurrentAPY()
    callsub getCurrentAPY
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_2 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:55
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 5 // "lastRewardTime"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:62
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 8 // "rewardPeriod"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:56
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 6 // "minimumStake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_3 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:58
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 4 // "accumulatedRewardsPerShare"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    uncover 6
    itob
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    uncover 6
    itob
    // smart_contracts/staking/contract.algo.ts:54-403
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    // 
    // // Constants for fixed reward system - now as GlobalState for flexibility
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       rewardDebt: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Update accumulated rewards per share if reward period has passed
    //  */
    // private updateRewards(): void {
    //   const currentTime = Global.latestTimestamp
    //   const lastReward = this.lastRewardTime.value
    //   const rewardPeriod = this.rewardPeriod.value
    // 
    //   // Check if a full reward period has passed
    //   if (currentTime >= lastReward + rewardPeriod && this.totalStaked.value > 0) {
    //     // Calculate how many complete periods have passed
    //     const periodsPassed: uint64 = (currentTime - lastReward) / rewardPeriod
    // 
    //     // Update accumulated rewards per share
    //     const rewardPerPeriod = this.weeklyRewards.value
    //     const totalRewards: uint64 = rewardPerPeriod * periodsPassed
    // 
    //     // Simple division - rewards per token staked
    //     const totalStaked = this.totalStaked.value
    //     const rewardPerShare: uint64 = totalRewards / totalStaked
    // 
    //     this.accumulatedRewardsPerShare.value = this.accumulatedRewardsPerShare.value + rewardPerShare
    // 
    //     // Update last reward time to the most recent complete period
    //     this.lastRewardTime.value = lastReward + (periodsPassed * rewardPeriod)
    // 
    //     // Deduct rewards from pool
    //     this.rewardPool.value = this.rewardPool.value - totalRewards
    //   }
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user
    //  */
    // private calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const userStake = stakeInfo.stakedAmount.native
    //   const accRewardsPerShare = this.accumulatedRewardsPerShare.value
    //   const userRewardDebt = stakeInfo.rewardDebt.native
    // 
    //   // Simple calculation without precision
    //   const totalEarned: uint64 = userStake * accRewardsPerShare
    //   const pendingRewards: uint64 = totalEarned > userRewardDebt ? totalEarned - userRewardDebt : 0
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   minimumStake: uint64,
    //   weeklyRewards: uint64,
    //   rewardPeriod: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.lastRewardTime.value = Global.latestTimestamp
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    //   this.accumulatedRewardsPerShare.value = 0
    // 
    //   // Set reward system parameters
    //   this.weeklyRewards.value = weeklyRewards
    //   this.rewardPeriod.value = rewardPeriod
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    //   const senderAddress = Txn.sender
    // 
    //   // Get the current user stake info
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64(stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64(stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate current APY based on total staked amount
    //  */
    // @abimethod({ readonly: true })
    // public getCurrentAPY(): uint64 {
    //   const totalStaked = this.totalStaked.value
    // 
    //   if (totalStaked === 0) {
    //     return 0 // Return 0 if no tokens staked
    //   }
    // 
    //   // Calculate annual rewards: 52 weeks * weeklyRewards
    //   const annualRewards: uint64 = 52 * this.weeklyRewards.value
    // 
    //   // APY = (annualRewards / totalStaked) * 10000 (in basis points)
    //   const apy: uint64 = (annualRewards * 100) / totalStaked
    // 
    //   return apy
    // }
    // 
    // /**
    //  * Get pending rewards for a specific user
    //  */
    // @abimethod({ readonly: true })
    // public getPendingRewards(userAddress: Account): uint64 {
    //   return this.calculatePendingRewards(userAddress)
    // }
    // 
    // /**
    //  * Trigger reward distribution manually (admin only)
    //  * Updates accumulated rewards per share if period has passed
    //  */
    // @abimethod()
    // public triggerRewardDistribution(): void {
    //   // Ensure only admin can trigger distribution
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can trigger distribution')
    // 
    //   // Update rewards
    //   this.updateRewards()
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.rewardDebt.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const currentAPY = this.getCurrentAPY()
    // 
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     currentAPY,
    concat
    // smart_contracts/staking/contract.algo.ts:403
    // currentAPY,
    uncover 6
    itob
    // smart_contracts/staking/contract.algo.ts:54-403
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    // 
    // // Constants for fixed reward system - now as GlobalState for flexibility
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       rewardDebt: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Update accumulated rewards per share if reward period has passed
    //  */
    // private updateRewards(): void {
    //   const currentTime = Global.latestTimestamp
    //   const lastReward = this.lastRewardTime.value
    //   const rewardPeriod = this.rewardPeriod.value
    // 
    //   // Check if a full reward period has passed
    //   if (currentTime >= lastReward + rewardPeriod && this.totalStaked.value > 0) {
    //     // Calculate how many complete periods have passed
    //     const periodsPassed: uint64 = (currentTime - lastReward) / rewardPeriod
    // 
    //     // Update accumulated rewards per share
    //     const rewardPerPeriod = this.weeklyRewards.value
    //     const totalRewards: uint64 = rewardPerPeriod * periodsPassed
    // 
    //     // Simple division - rewards per token staked
    //     const totalStaked = this.totalStaked.value
    //     const rewardPerShare: uint64 = totalRewards / totalStaked
    // 
    //     this.accumulatedRewardsPerShare.value = this.accumulatedRewardsPerShare.value + rewardPerShare
    // 
    //     // Update last reward time to the most recent complete period
    //     this.lastRewardTime.value = lastReward + (periodsPassed * rewardPeriod)
    // 
    //     // Deduct rewards from pool
    //     this.rewardPool.value = this.rewardPool.value - totalRewards
    //   }
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user
    //  */
    // private calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const userStake = stakeInfo.stakedAmount.native
    //   const accRewardsPerShare = this.accumulatedRewardsPerShare.value
    //   const userRewardDebt = stakeInfo.rewardDebt.native
    // 
    //   // Simple calculation without precision
    //   const totalEarned: uint64 = userStake * accRewardsPerShare
    //   const pendingRewards: uint64 = totalEarned > userRewardDebt ? totalEarned - userRewardDebt : 0
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   minimumStake: uint64,
    //   weeklyRewards: uint64,
    //   rewardPeriod: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.lastRewardTime.value = Global.latestTimestamp
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    //   this.accumulatedRewardsPerShare.value = 0
    // 
    //   // Set reward system parameters
    //   this.weeklyRewards.value = weeklyRewards
    //   this.rewardPeriod.value = rewardPeriod
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    //   const senderAddress = Txn.sender
    // 
    //   // Get the current user stake info
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64(stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64(stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate current APY based on total staked amount
    //  */
    // @abimethod({ readonly: true })
    // public getCurrentAPY(): uint64 {
    //   const totalStaked = this.totalStaked.value
    // 
    //   if (totalStaked === 0) {
    //     return 0 // Return 0 if no tokens staked
    //   }
    // 
    //   // Calculate annual rewards: 52 weeks * weeklyRewards
    //   const annualRewards: uint64 = 52 * this.weeklyRewards.value
    // 
    //   // APY = (annualRewards / totalStaked) * 10000 (in basis points)
    //   const apy: uint64 = (annualRewards * 100) / totalStaked
    // 
    //   return apy
    // }
    // 
    // /**
    //  * Get pending rewards for a specific user
    //  */
    // @abimethod({ readonly: true })
    // public getPendingRewards(userAddress: Account): uint64 {
    //   return this.calculatePendingRewards(userAddress)
    // }
    // 
    // /**
    //  * Trigger reward distribution manually (admin only)
    //  * Updates accumulated rewards per share if period has passed
    //  */
    // @abimethod()
    // public triggerRewardDistribution(): void {
    //   // Ensure only admin can trigger distribution
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can trigger distribution')
    // 
    //   // Update rewards
    //   this.updateRewards()
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.rewardDebt.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const currentAPY = this.getCurrentAPY()
    // 
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     currentAPY,
    concat
    // smart_contracts/staking/contract.algo.ts:55
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    uncover 5
    itob
    // smart_contracts/staking/contract.algo.ts:54-403
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    // 
    // // Constants for fixed reward system - now as GlobalState for flexibility
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       rewardDebt: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Update accumulated rewards per share if reward period has passed
    //  */
    // private updateRewards(): void {
    //   const currentTime = Global.latestTimestamp
    //   const lastReward = this.lastRewardTime.value
    //   const rewardPeriod = this.rewardPeriod.value
    // 
    //   // Check if a full reward period has passed
    //   if (currentTime >= lastReward + rewardPeriod && this.totalStaked.value > 0) {
    //     // Calculate how many complete periods have passed
    //     const periodsPassed: uint64 = (currentTime - lastReward) / rewardPeriod
    // 
    //     // Update accumulated rewards per share
    //     const rewardPerPeriod = this.weeklyRewards.value
    //     const totalRewards: uint64 = rewardPerPeriod * periodsPassed
    // 
    //     // Simple division - rewards per token staked
    //     const totalStaked = this.totalStaked.value
    //     const rewardPerShare: uint64 = totalRewards / totalStaked
    // 
    //     this.accumulatedRewardsPerShare.value = this.accumulatedRewardsPerShare.value + rewardPerShare
    // 
    //     // Update last reward time to the most recent complete period
    //     this.lastRewardTime.value = lastReward + (periodsPassed * rewardPeriod)
    // 
    //     // Deduct rewards from pool
    //     this.rewardPool.value = this.rewardPool.value - totalRewards
    //   }
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user
    //  */
    // private calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const userStake = stakeInfo.stakedAmount.native
    //   const accRewardsPerShare = this.accumulatedRewardsPerShare.value
    //   const userRewardDebt = stakeInfo.rewardDebt.native
    // 
    //   // Simple calculation without precision
    //   const totalEarned: uint64 = userStake * accRewardsPerShare
    //   const pendingRewards: uint64 = totalEarned > userRewardDebt ? totalEarned - userRewardDebt : 0
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   minimumStake: uint64,
    //   weeklyRewards: uint64,
    //   rewardPeriod: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.lastRewardTime.value = Global.latestTimestamp
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    //   this.accumulatedRewardsPerShare.value = 0
    // 
    //   // Set reward system parameters
    //   this.weeklyRewards.value = weeklyRewards
    //   this.rewardPeriod.value = rewardPeriod
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    //   const senderAddress = Txn.sender
    // 
    //   // Get the current user stake info
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64(stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64(stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate current APY based on total staked amount
    //  */
    // @abimethod({ readonly: true })
    // public getCurrentAPY(): uint64 {
    //   const totalStaked = this.totalStaked.value
    // 
    //   if (totalStaked === 0) {
    //     return 0 // Return 0 if no tokens staked
    //   }
    // 
    //   // Calculate annual rewards: 52 weeks * weeklyRewards
    //   const annualRewards: uint64 = 52 * this.weeklyRewards.value
    // 
    //   // APY = (annualRewards / totalStaked) * 10000 (in basis points)
    //   const apy: uint64 = (annualRewards * 100) / totalStaked
    // 
    //   return apy
    // }
    // 
    // /**
    //  * Get pending rewards for a specific user
    //  */
    // @abimethod({ readonly: true })
    // public getPendingRewards(userAddress: Account): uint64 {
    //   return this.calculatePendingRewards(userAddress)
    // }
    // 
    // /**
    //  * Trigger reward distribution manually (admin only)
    //  * Updates accumulated rewards per share if period has passed
    //  */
    // @abimethod()
    // public triggerRewardDistribution(): void {
    //   // Ensure only admin can trigger distribution
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can trigger distribution')
    // 
    //   // Update rewards
    //   this.updateRewards()
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.rewardDebt.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const currentAPY = this.getCurrentAPY()
    // 
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     currentAPY,
    concat
    // smart_contracts/staking/contract.algo.ts:62
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    uncover 4
    itob
    // smart_contracts/staking/contract.algo.ts:54-403
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    // 
    // // Constants for fixed reward system - now as GlobalState for flexibility
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       rewardDebt: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Update accumulated rewards per share if reward period has passed
    //  */
    // private updateRewards(): void {
    //   const currentTime = Global.latestTimestamp
    //   const lastReward = this.lastRewardTime.value
    //   const rewardPeriod = this.rewardPeriod.value
    // 
    //   // Check if a full reward period has passed
    //   if (currentTime >= lastReward + rewardPeriod && this.totalStaked.value > 0) {
    //     // Calculate how many complete periods have passed
    //     const periodsPassed: uint64 = (currentTime - lastReward) / rewardPeriod
    // 
    //     // Update accumulated rewards per share
    //     const rewardPerPeriod = this.weeklyRewards.value
    //     const totalRewards: uint64 = rewardPerPeriod * periodsPassed
    // 
    //     // Simple division - rewards per token staked
    //     const totalStaked = this.totalStaked.value
    //     const rewardPerShare: uint64 = totalRewards / totalStaked
    // 
    //     this.accumulatedRewardsPerShare.value = this.accumulatedRewardsPerShare.value + rewardPerShare
    // 
    //     // Update last reward time to the most recent complete period
    //     this.lastRewardTime.value = lastReward + (periodsPassed * rewardPeriod)
    // 
    //     // Deduct rewards from pool
    //     this.rewardPool.value = this.rewardPool.value - totalRewards
    //   }
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user
    //  */
    // private calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const userStake = stakeInfo.stakedAmount.native
    //   const accRewardsPerShare = this.accumulatedRewardsPerShare.value
    //   const userRewardDebt = stakeInfo.rewardDebt.native
    // 
    //   // Simple calculation without precision
    //   const totalEarned: uint64 = userStake * accRewardsPerShare
    //   const pendingRewards: uint64 = totalEarned > userRewardDebt ? totalEarned - userRewardDebt : 0
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   minimumStake: uint64,
    //   weeklyRewards: uint64,
    //   rewardPeriod: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.lastRewardTime.value = Global.latestTimestamp
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    //   this.accumulatedRewardsPerShare.value = 0
    // 
    //   // Set reward system parameters
    //   this.weeklyRewards.value = weeklyRewards
    //   this.rewardPeriod.value = rewardPeriod
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    //   const senderAddress = Txn.sender
    // 
    //   // Get the current user stake info
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64(stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64(stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate current APY based on total staked amount
    //  */
    // @abimethod({ readonly: true })
    // public getCurrentAPY(): uint64 {
    //   const totalStaked = this.totalStaked.value
    // 
    //   if (totalStaked === 0) {
    //     return 0 // Return 0 if no tokens staked
    //   }
    // 
    //   // Calculate annual rewards: 52 weeks * weeklyRewards
    //   const annualRewards: uint64 = 52 * this.weeklyRewards.value
    // 
    //   // APY = (annualRewards / totalStaked) * 10000 (in basis points)
    //   const apy: uint64 = (annualRewards * 100) / totalStaked
    // 
    //   return apy
    // }
    // 
    // /**
    //  * Get pending rewards for a specific user
    //  */
    // @abimethod({ readonly: true })
    // public getPendingRewards(userAddress: Account): uint64 {
    //   return this.calculatePendingRewards(userAddress)
    // }
    // 
    // /**
    //  * Trigger reward distribution manually (admin only)
    //  * Updates accumulated rewards per share if period has passed
    //  */
    // @abimethod()
    // public triggerRewardDistribution(): void {
    //   // Ensure only admin can trigger distribution
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can trigger distribution')
    // 
    //   // Update rewards
    //   this.updateRewards()
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.rewardDebt.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const currentAPY = this.getCurrentAPY()
    // 
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     currentAPY,
    concat
    // smart_contracts/staking/contract.algo.ts:56
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    uncover 3
    itob
    // smart_contracts/staking/contract.algo.ts:54-403
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    // 
    // // Constants for fixed reward system - now as GlobalState for flexibility
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       rewardDebt: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Update accumulated rewards per share if reward period has passed
    //  */
    // private updateRewards(): void {
    //   const currentTime = Global.latestTimestamp
    //   const lastReward = this.lastRewardTime.value
    //   const rewardPeriod = this.rewardPeriod.value
    // 
    //   // Check if a full reward period has passed
    //   if (currentTime >= lastReward + rewardPeriod && this.totalStaked.value > 0) {
    //     // Calculate how many complete periods have passed
    //     const periodsPassed: uint64 = (currentTime - lastReward) / rewardPeriod
    // 
    //     // Update accumulated rewards per share
    //     const rewardPerPeriod = this.weeklyRewards.value
    //     const totalRewards: uint64 = rewardPerPeriod * periodsPassed
    // 
    //     // Simple division - rewards per token staked
    //     const totalStaked = this.totalStaked.value
    //     const rewardPerShare: uint64 = totalRewards / totalStaked
    // 
    //     this.accumulatedRewardsPerShare.value = this.accumulatedRewardsPerShare.value + rewardPerShare
    // 
    //     // Update last reward time to the most recent complete period
    //     this.lastRewardTime.value = lastReward + (periodsPassed * rewardPeriod)
    // 
    //     // Deduct rewards from pool
    //     this.rewardPool.value = this.rewardPool.value - totalRewards
    //   }
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user
    //  */
    // private calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const userStake = stakeInfo.stakedAmount.native
    //   const accRewardsPerShare = this.accumulatedRewardsPerShare.value
    //   const userRewardDebt = stakeInfo.rewardDebt.native
    // 
    //   // Simple calculation without precision
    //   const totalEarned: uint64 = userStake * accRewardsPerShare
    //   const pendingRewards: uint64 = totalEarned > userRewardDebt ? totalEarned - userRewardDebt : 0
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   minimumStake: uint64,
    //   weeklyRewards: uint64,
    //   rewardPeriod: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.lastRewardTime.value = Global.latestTimestamp
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    //   this.accumulatedRewardsPerShare.value = 0
    // 
    //   // Set reward system parameters
    //   this.weeklyRewards.value = weeklyRewards
    //   this.rewardPeriod.value = rewardPeriod
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    //   const senderAddress = Txn.sender
    // 
    //   // Get the current user stake info
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64(stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64(stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate current APY based on total staked amount
    //  */
    // @abimethod({ readonly: true })
    // public getCurrentAPY(): uint64 {
    //   const totalStaked = this.totalStaked.value
    // 
    //   if (totalStaked === 0) {
    //     return 0 // Return 0 if no tokens staked
    //   }
    // 
    //   // Calculate annual rewards: 52 weeks * weeklyRewards
    //   const annualRewards: uint64 = 52 * this.weeklyRewards.value
    // 
    //   // APY = (annualRewards / totalStaked) * 10000 (in basis points)
    //   const apy: uint64 = (annualRewards * 100) / totalStaked
    // 
    //   return apy
    // }
    // 
    // /**
    //  * Get pending rewards for a specific user
    //  */
    // @abimethod({ readonly: true })
    // public getPendingRewards(userAddress: Account): uint64 {
    //   return this.calculatePendingRewards(userAddress)
    // }
    // 
    // /**
    //  * Trigger reward distribution manually (admin only)
    //  * Updates accumulated rewards per share if period has passed
    //  */
    // @abimethod()
    // public triggerRewardDistribution(): void {
    //   // Ensure only admin can trigger distribution
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can trigger distribution')
    // 
    //   // Update rewards
    //   this.updateRewards()
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.rewardDebt.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const currentAPY = this.getCurrentAPY()
    // 
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     currentAPY,
    concat
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    uncover 2
    itob
    // smart_contracts/staking/contract.algo.ts:54-403
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    // 
    // // Constants for fixed reward system - now as GlobalState for flexibility
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       rewardDebt: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Update accumulated rewards per share if reward period has passed
    //  */
    // private updateRewards(): void {
    //   const currentTime = Global.latestTimestamp
    //   const lastReward = this.lastRewardTime.value
    //   const rewardPeriod = this.rewardPeriod.value
    // 
    //   // Check if a full reward period has passed
    //   if (currentTime >= lastReward + rewardPeriod && this.totalStaked.value > 0) {
    //     // Calculate how many complete periods have passed
    //     const periodsPassed: uint64 = (currentTime - lastReward) / rewardPeriod
    // 
    //     // Update accumulated rewards per share
    //     const rewardPerPeriod = this.weeklyRewards.value
    //     const totalRewards: uint64 = rewardPerPeriod * periodsPassed
    // 
    //     // Simple division - rewards per token staked
    //     const totalStaked = this.totalStaked.value
    //     const rewardPerShare: uint64 = totalRewards / totalStaked
    // 
    //     this.accumulatedRewardsPerShare.value = this.accumulatedRewardsPerShare.value + rewardPerShare
    // 
    //     // Update last reward time to the most recent complete period
    //     this.lastRewardTime.value = lastReward + (periodsPassed * rewardPeriod)
    // 
    //     // Deduct rewards from pool
    //     this.rewardPool.value = this.rewardPool.value - totalRewards
    //   }
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user
    //  */
    // private calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const userStake = stakeInfo.stakedAmount.native
    //   const accRewardsPerShare = this.accumulatedRewardsPerShare.value
    //   const userRewardDebt = stakeInfo.rewardDebt.native
    // 
    //   // Simple calculation without precision
    //   const totalEarned: uint64 = userStake * accRewardsPerShare
    //   const pendingRewards: uint64 = totalEarned > userRewardDebt ? totalEarned - userRewardDebt : 0
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   minimumStake: uint64,
    //   weeklyRewards: uint64,
    //   rewardPeriod: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.lastRewardTime.value = Global.latestTimestamp
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    //   this.accumulatedRewardsPerShare.value = 0
    // 
    //   // Set reward system parameters
    //   this.weeklyRewards.value = weeklyRewards
    //   this.rewardPeriod.value = rewardPeriod
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    //   const senderAddress = Txn.sender
    // 
    //   // Get the current user stake info
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64(stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64(stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate current APY based on total staked amount
    //  */
    // @abimethod({ readonly: true })
    // public getCurrentAPY(): uint64 {
    //   const totalStaked = this.totalStaked.value
    // 
    //   if (totalStaked === 0) {
    //     return 0 // Return 0 if no tokens staked
    //   }
    // 
    //   // Calculate annual rewards: 52 weeks * weeklyRewards
    //   const annualRewards: uint64 = 52 * this.weeklyRewards.value
    // 
    //   // APY = (annualRewards / totalStaked) * 10000 (in basis points)
    //   const apy: uint64 = (annualRewards * 100) / totalStaked
    // 
    //   return apy
    // }
    // 
    // /**
    //  * Get pending rewards for a specific user
    //  */
    // @abimethod({ readonly: true })
    // public getPendingRewards(userAddress: Account): uint64 {
    //   return this.calculatePendingRewards(userAddress)
    // }
    // 
    // /**
    //  * Trigger reward distribution manually (admin only)
    //  * Updates accumulated rewards per share if period has passed
    //  */
    // @abimethod()
    // public triggerRewardDistribution(): void {
    //   // Ensure only admin can trigger distribution
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can trigger distribution')
    // 
    //   // Update rewards
    //   this.updateRewards()
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.rewardDebt.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const currentAPY = this.getCurrentAPY()
    // 
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     currentAPY,
    concat
    // smart_contracts/staking/contract.algo.ts:58
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    swap
    itob
    // smart_contracts/staking/contract.algo.ts:54-403
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    // 
    // // Constants for fixed reward system - now as GlobalState for flexibility
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       rewardDebt: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Update accumulated rewards per share if reward period has passed
    //  */
    // private updateRewards(): void {
    //   const currentTime = Global.latestTimestamp
    //   const lastReward = this.lastRewardTime.value
    //   const rewardPeriod = this.rewardPeriod.value
    // 
    //   // Check if a full reward period has passed
    //   if (currentTime >= lastReward + rewardPeriod && this.totalStaked.value > 0) {
    //     // Calculate how many complete periods have passed
    //     const periodsPassed: uint64 = (currentTime - lastReward) / rewardPeriod
    // 
    //     // Update accumulated rewards per share
    //     const rewardPerPeriod = this.weeklyRewards.value
    //     const totalRewards: uint64 = rewardPerPeriod * periodsPassed
    // 
    //     // Simple division - rewards per token staked
    //     const totalStaked = this.totalStaked.value
    //     const rewardPerShare: uint64 = totalRewards / totalStaked
    // 
    //     this.accumulatedRewardsPerShare.value = this.accumulatedRewardsPerShare.value + rewardPerShare
    // 
    //     // Update last reward time to the most recent complete period
    //     this.lastRewardTime.value = lastReward + (periodsPassed * rewardPeriod)
    // 
    //     // Deduct rewards from pool
    //     this.rewardPool.value = this.rewardPool.value - totalRewards
    //   }
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user
    //  */
    // private calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const userStake = stakeInfo.stakedAmount.native
    //   const accRewardsPerShare = this.accumulatedRewardsPerShare.value
    //   const userRewardDebt = stakeInfo.rewardDebt.native
    // 
    //   // Simple calculation without precision
    //   const totalEarned: uint64 = userStake * accRewardsPerShare
    //   const pendingRewards: uint64 = totalEarned > userRewardDebt ? totalEarned - userRewardDebt : 0
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   minimumStake: uint64,
    //   weeklyRewards: uint64,
    //   rewardPeriod: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.lastRewardTime.value = Global.latestTimestamp
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    //   this.accumulatedRewardsPerShare.value = 0
    // 
    //   // Set reward system parameters
    //   this.weeklyRewards.value = weeklyRewards
    //   this.rewardPeriod.value = rewardPeriod
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    //   const senderAddress = Txn.sender
    // 
    //   // Get the current user stake info
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64(stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64(stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate current APY based on total staked amount
    //  */
    // @abimethod({ readonly: true })
    // public getCurrentAPY(): uint64 {
    //   const totalStaked = this.totalStaked.value
    // 
    //   if (totalStaked === 0) {
    //     return 0 // Return 0 if no tokens staked
    //   }
    // 
    //   // Calculate annual rewards: 52 weeks * weeklyRewards
    //   const annualRewards: uint64 = 52 * this.weeklyRewards.value
    // 
    //   // APY = (annualRewards / totalStaked) * 10000 (in basis points)
    //   const apy: uint64 = (annualRewards * 100) / totalStaked
    // 
    //   return apy
    // }
    // 
    // /**
    //  * Get pending rewards for a specific user
    //  */
    // @abimethod({ readonly: true })
    // public getPendingRewards(userAddress: Account): uint64 {
    //   return this.calculatePendingRewards(userAddress)
    // }
    // 
    // /**
    //  * Trigger reward distribution manually (admin only)
    //  * Updates accumulated rewards per share if period has passed
    //  */
    // @abimethod()
    // public triggerRewardDistribution(): void {
    //   // Ensure only admin can trigger distribution
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can trigger distribution')
    // 
    //   // Update rewards
    //   this.updateRewards()
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.rewardDebt.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const currentAPY = this.getCurrentAPY()
    // 
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     currentAPY,
    concat
    dup
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:411
    // return result
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.emergencyWithdrawRewards(amount: uint64) -> void:
emergencyWithdrawRewards:
    // smart_contracts/staking/contract.algo.ts:417-418
    // @abimethod()
    // public emergencyWithdrawRewards(amount: uint64): void {
    proto 1 0
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_0 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:421
    // assert(Txn.sender === adminAddr, 'Only admin can emergency withdraw')
    txn Sender
    dig 1
    ==
    assert // Only admin can emergency withdraw
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_3 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:424
    // assert(this.rewardPool.value >= amount, 'Insufficient reward pool')
    frame_dig -1
    >=
    assert // Insufficient reward pool
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_3 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:427
    // this.rewardPool.value = this.rewardPool.value - amount
    frame_dig -1
    -
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    bytec_3 // "rewardPool"
    // smart_contracts/staking/contract.algo.ts:427
    // this.rewardPool.value = this.rewardPool.value - amount
    swap
    app_global_put
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:431-438
    // itxn
    //   .assetTransfer({
    //     assetReceiver: adminAddr,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_begin
    itxn_field XferAsset
    frame_dig -1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/staking/contract.algo.ts:431-437
    // itxn
    //   .assetTransfer({
    //     assetReceiver: adminAddr,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/contract.algo.ts:436
    // fee: 1000,
    pushint 1000 // 1000
    itxn_field Fee
    // smart_contracts/staking/contract.algo.ts:431-438
    // itxn
    //   .assetTransfer({
    //     assetReceiver: adminAddr,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.deleteUserBox(userAddress: bytes) -> void:
deleteUserBox:
    // smart_contracts/staking/contract.algo.ts:445-446
    // @abimethod()
    // public deleteUserBox(userAddress: Account): void {
    proto 1 0
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    dup
    bytec_0 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:451
    // assert(Txn.sender === boxOwner || Txn.sender === adminAddr, 'Only box owner or admin can delete box')
    txn Sender
    frame_dig -1
    ==
    bnz deleteUserBox_bool_true@2
    txn Sender
    frame_dig 1
    ==
    bz deleteUserBox_bool_false@3

deleteUserBox_bool_true@2:
    intc_1 // 1

deleteUserBox_bool_merge@4:
    // smart_contracts/staking/contract.algo.ts:451
    // assert(Txn.sender === boxOwner || Txn.sender === adminAddr, 'Only box owner or admin can delete box')
    assert // Only box owner or admin can delete box
    // smart_contracts/staking/contract.algo.ts:454
    // const stakeInfo = this.getUserStakeInfo(userAddress)
    frame_dig -1
    callsub getUserStakeInfo
    // smart_contracts/staking/contract.algo.ts:455
    // assert(stakeInfo.stakedAmount.native === 0, 'User still has active stake')
    intc_0 // 0
    extract_uint64
    !
    assert // User still has active stake
    // smart_contracts/staking/contract.algo.ts:64
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    bytec 10 // "stakers"
    // smart_contracts/staking/contract.algo.ts:458
    // const userBox = this.stakers(userAddress)
    frame_dig -1
    // smart_contracts/staking/contract.algo.ts:64
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    concat
    // smart_contracts/staking/contract.algo.ts:458
    // const userBox = this.stakers(userAddress)
    dup
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:459
    // if (userBox.exists) {
    box_len
    bury 1
    bz deleteUserBox_after_if_else@6
    // smart_contracts/staking/contract.algo.ts:460
    // userBox.delete()
    frame_dig 0
    box_del
    pop

deleteUserBox_after_if_else@6:
    retsub

deleteUserBox_bool_false@3:
    intc_0 // 0
    b deleteUserBox_bool_merge@4


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.updateWeeklyRewards(newWeeklyRewards: uint64) -> void:
updateWeeklyRewards:
    // smart_contracts/staking/contract.algo.ts:467-468
    // @abimethod()
    // public updateWeeklyRewards(newWeeklyRewards: uint64): void {
    proto 1 0
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_0 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:471
    // assert(Txn.sender === adminAddr, 'Only admin can update weekly rewards')
    txn Sender
    ==
    assert // Only admin can update weekly rewards
    // smart_contracts/staking/contract.algo.ts:474
    // this.updateRewards()
    callsub updateRewards
    // smart_contracts/staking/contract.algo.ts:61
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    bytec 7 // "weeklyRewards"
    // smart_contracts/staking/contract.algo.ts:477
    // this.weeklyRewards.value = newWeeklyRewards
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.updateRewardPeriod(newRewardPeriod: uint64) -> void:
updateRewardPeriod:
    // smart_contracts/staking/contract.algo.ts:483-484
    // @abimethod()
    // public updateRewardPeriod(newRewardPeriod: uint64): void {
    proto 1 0
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_0 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:487
    // assert(Txn.sender === adminAddr, 'Only admin can update reward period')
    txn Sender
    ==
    assert // Only admin can update reward period
    // smart_contracts/staking/contract.algo.ts:490
    // this.updateRewards()
    callsub updateRewards
    // smart_contracts/staking/contract.algo.ts:62
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    bytec 8 // "rewardPeriod"
    // smart_contracts/staking/contract.algo.ts:493
    // this.rewardPeriod.value = newRewardPeriod
    frame_dig -1
    app_global_put
    retsub
