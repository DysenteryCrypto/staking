#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 4 8
    bytecblock "totalStaked" "asset" "adminAddress" "lastDistributionTime" "aprBasisPoints" "minimumStake" 0x151f7c75 "distributionPeriodSeconds" "stakers"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:46
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    bytec_1 // "asset"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:47
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    bytec_2 // "adminAddress"
    global ZeroAddress
    app_global_put
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "totalStaked"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:49
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    bytec 4 // "aprBasisPoints"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:50
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    bytec_3 // "lastDistributionTime"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:51
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    bytec 7 // "distributionPeriodSeconds"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:52
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    bytec 5 // "minimumStake"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txn NumAppArgs
    bz main_bare_routing@22
    pushbytess 0xa9b56b38 0x124ba026 0x83786954 0x667c5d30 0x9ffd3e53 0x0890bd58 0x21f1ddff 0xb0a93807 0x411cec23 0xa5ae6bd1 0x1e6612bd 0x82ab1ec4 0x15766b09 0xbfe31564 0xdc9a2a05 // method "getUserBoxName(account)address", method "getUserStakeInfo(account)(uint64,uint64,uint64)", method "storeUserStakeInfo(account,(uint64,uint64,uint64))void", method "initialize(asset,account,uint64,uint64,uint64)void", method "optInToAsset()void", method "stake()void", method "withdraw(uint64)void", method "distributeRewards()void", method "calculateUserRewards(account)uint64", method "claimRewards()void", method "updateAPR(uint64)void", method "updateAdmin(account)void", method "getUserStats(account)uint64[]", method "getContractStats()uint64[]", method "deleteUserBox(account)void"
    txna ApplicationArgs 0
    match main_getUserBoxName_route@5 main_getUserStakeInfo_route@6 main_storeUserStakeInfo_route@7 main_initialize_route@8 main_optInToAsset_route@9 main_stake_route@10 main_withdraw_route@11 main_distributeRewards_route@12 main_calculateUserRewards_route@13 main_claimRewards_route@14 main_updateAPR_route@15 main_updateAdmin_route@16 main_getUserStats_route@17 main_getContractStats_route@18 main_deleteUserBox_route@19

main_after_if_else@26:
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    intc_0 // 0
    return

main_deleteUserBox_route@19:
    // smart_contracts/staking/contract.algo.ts:398
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:398
    // @abimethod()
    callsub deleteUserBox
    intc_1 // 1
    return

main_getContractStats_route@18:
    // smart_contracts/staking/contract.algo.ts:380
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getContractStats
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getUserStats_route@17:
    // smart_contracts/staking/contract.algo.ts:363
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:363
    // @abimethod({ readonly: true })
    callsub getUserStats
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_updateAdmin_route@16:
    // smart_contracts/staking/contract.algo.ts:350
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:350
    // @abimethod()
    callsub updateAdmin
    intc_1 // 1
    return

main_updateAPR_route@15:
    // smart_contracts/staking/contract.algo.ts:336
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/staking/contract.algo.ts:336
    // @abimethod()
    callsub updateAPR
    intc_1 // 1
    return

main_claimRewards_route@14:
    // smart_contracts/staking/contract.algo.ts:307
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub claimRewards
    intc_1 // 1
    return

main_calculateUserRewards_route@13:
    // smart_contracts/staking/contract.algo.ts:263
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:263
    // @abimethod({ readonly: true })
    callsub calculateUserRewards
    itob
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_distributeRewards_route@12:
    // smart_contracts/staking/contract.algo.ts:230
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub distributeRewards
    intc_1 // 1
    return

main_withdraw_route@11:
    // smart_contracts/staking/contract.algo.ts:186
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/staking/contract.algo.ts:186
    // @abimethod()
    callsub withdraw
    intc_1 // 1
    return

main_stake_route@10:
    // smart_contracts/staking/contract.algo.ts:143
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub stake
    intc_1 // 1
    return

main_optInToAsset_route@9:
    // smart_contracts/staking/contract.algo.ts:122
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub optInToAsset
    intc_1 // 1
    return

main_initialize_route@8:
    // smart_contracts/staking/contract.algo.ts:95
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    btoi
    txnas Accounts
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    // smart_contracts/staking/contract.algo.ts:95
    // @abimethod()
    callsub initialize
    intc_1 // 1
    return

main_storeUserStakeInfo_route@7:
    // smart_contracts/staking/contract.algo.ts:88
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    // smart_contracts/staking/contract.algo.ts:88
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    callsub storeUserStakeInfo
    pop
    intc_1 // 1
    return

main_getUserStakeInfo_route@6:
    // smart_contracts/staking/contract.algo.ts:68
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:68
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    callsub getUserStakeInfo
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getUserBoxName_route@5:
    // smart_contracts/staking/contract.algo.ts:60
    // public getUserBoxName(userAddress: Account): arc4.Address {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:60
    // public getUserBoxName(userAddress: Account): arc4.Address {
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@22:
    // smart_contracts/staking/contract.algo.ts:44-45
    // @contract({ stateTotals: { globalBytes: 7 } })
    // export class ASAStakingContract extends Contract {
    txn OnCompletion
    bnz main_after_if_else@26
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getUserStakeInfo(userAddress: bytes) -> bytes:
getUserStakeInfo:
    // smart_contracts/staking/contract.algo.ts:68
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    proto 1 1
    // smart_contracts/staking/contract.algo.ts:54
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    bytec 8 // "stakers"
    // smart_contracts/staking/contract.algo.ts:69
    // const userBox = this.stakers(userAddress)
    frame_dig -1
    // smart_contracts/staking/contract.algo.ts:54
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    concat
    // smart_contracts/staking/contract.algo.ts:69
    // const userBox = this.stakers(userAddress)
    dup
    // smart_contracts/staking/contract.algo.ts:72
    // if (userBox.exists) {
    box_len
    bury 1
    bz getUserStakeInfo_else_body@2
    // smart_contracts/staking/contract.algo.ts:73
    // const boxData = userBox.value.copy()
    frame_dig 0
    box_get
    assert // Box must have value
    // smart_contracts/staking/contract.algo.ts:75
    // return boxData
    swap
    retsub

getUserStakeInfo_else_body@2:
    // smart_contracts/staking/contract.algo.ts:77-81
    // return new UserStakeInfo({
    //   stakedAmount: new arc4.UintN64(0),
    //   lastStakeTime: new arc4.UintN64(0),
    //   totalRewardsEarned: new arc4.UintN64(0),
    // })
    pushbytes 0x000000000000000000000000000000000000000000000000
    swap
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.storeUserStakeInfo(userAddress: bytes, stakeInfo: bytes) -> bytes:
storeUserStakeInfo:
    // smart_contracts/staking/contract.algo.ts:88
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    proto 2 1
    // smart_contracts/staking/contract.algo.ts:54
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    bytec 8 // "stakers"
    frame_dig -2
    concat
    // smart_contracts/staking/contract.algo.ts:89
    // this.stakers(userAddress).value = stakeInfo.copy()
    frame_dig -1
    box_put
    frame_dig -1
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.initialize(asset: uint64, adminAddress: bytes, aprBasisPoints: uint64, distributionPeriodSeconds: uint64, minimumStake: uint64) -> void:
initialize:
    // smart_contracts/staking/contract.algo.ts:95-102
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   aprBasisPoints: uint64,
    //   distributionPeriodSeconds: uint64,
    //   minimumStake: uint64,
    // ): void {
    proto 5 0
    // smart_contracts/staking/contract.algo.ts:46
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:104
    // assert(this.asset.value === Asset(), 'Already initialized')
    !
    assert // Already initialized
    // smart_contracts/staking/contract.algo.ts:107
    // assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can initialize
    // smart_contracts/staking/contract.algo.ts:46
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    bytec_1 // "asset"
    // smart_contracts/staking/contract.algo.ts:110
    // this.asset.value = asset
    frame_dig -5
    app_global_put
    // smart_contracts/staking/contract.algo.ts:47
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    bytec_2 // "adminAddress"
    // smart_contracts/staking/contract.algo.ts:111
    // this.adminAddress.value = adminAddress
    frame_dig -4
    app_global_put
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "totalStaked"
    // smart_contracts/staking/contract.algo.ts:112
    // this.totalStaked.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:49
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    bytec 4 // "aprBasisPoints"
    // smart_contracts/staking/contract.algo.ts:113
    // this.aprBasisPoints.value = aprBasisPoints
    frame_dig -3
    app_global_put
    // smart_contracts/staking/contract.algo.ts:50
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    bytec_3 // "lastDistributionTime"
    // smart_contracts/staking/contract.algo.ts:114
    // this.lastDistributionTime.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/staking/contract.algo.ts:51
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    bytec 7 // "distributionPeriodSeconds"
    // smart_contracts/staking/contract.algo.ts:115
    // this.distributionPeriodSeconds.value = distributionPeriodSeconds
    frame_dig -2
    app_global_put
    // smart_contracts/staking/contract.algo.ts:52
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    bytec 5 // "minimumStake"
    // smart_contracts/staking/contract.algo.ts:116
    // this.minimumStake.value = minimumStake
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.optInToAsset() -> void:
optInToAsset:
    // smart_contracts/staking/contract.algo.ts:122-123
    // @abimethod()
    // public optInToAsset(): void {
    proto 0 0
    // smart_contracts/staking/contract.algo.ts:47
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_2 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:126
    // assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    txn Sender
    global CreatorAddress
    ==
    bnz optInToAsset_bool_true@2
    txn Sender
    frame_dig 0
    ==
    bz optInToAsset_bool_false@3

optInToAsset_bool_true@2:
    intc_1 // 1

optInToAsset_bool_merge@4:
    // smart_contracts/staking/contract.algo.ts:126
    // assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    assert // Only creator or admin can opt in
    // smart_contracts/staking/contract.algo.ts:46
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:130-136
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/staking/contract.algo.ts:132
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    swap
    itxn_field XferAsset
    // smart_contracts/staking/contract.algo.ts:133
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/staking/contract.algo.ts:130-135
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/contract.algo.ts:130-136
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_submit
    retsub

optInToAsset_bool_false@3:
    intc_0 // 0
    b optInToAsset_bool_merge@4


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.stake() -> void:
stake:
    // smart_contracts/staking/contract.algo.ts:143-144
    // @abimethod()
    // public stake(): void {
    proto 0 0
    // smart_contracts/staking/contract.algo.ts:46
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:147
    // assert(this.asset.value !== Asset(), 'Contract not opted in to ASA')
    assert // Contract not opted in to ASA
    // smart_contracts/staking/contract.algo.ts:150
    // assert(Global.groupSize === 2, 'Expected 2 txns in group')
    global GroupSize
    pushint 2 // 2
    ==
    assert // Expected 2 txns in group
    // smart_contracts/staking/contract.algo.ts:153
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    gtxns TypeEnum
    dup
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/staking/contract.algo.ts:154
    // assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 1 must be asset transfer')
    intc_2 // 4
    ==
    assert // Transaction 1 must be asset transfer
    // smart_contracts/staking/contract.algo.ts:153
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:155
    // assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // Asset transfer must be to contract
    // smart_contracts/staking/contract.algo.ts:153
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:156
    // assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    gtxns AssetAmount
    dup
    cover 2
    assert // Must stake non-zero amount
    // smart_contracts/staking/contract.algo.ts:153
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:157
    // assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    gtxns XferAsset
    ==
    assert // Incorrect asset ID
    // smart_contracts/staking/contract.algo.ts:52
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 5 // "minimumStake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:164
    // const senderAddress = Txn.sender
    txn Sender
    dup
    // smart_contracts/staking/contract.algo.ts:165
    // const stakeInfo = this.getUserStakeInfo(senderAddress)
    callsub getUserStakeInfo
    dup
    // smart_contracts/staking/contract.algo.ts:168
    // if (stakeInfo.stakedAmount.native === 0) {
    intc_0 // 0
    extract_uint64
    dup
    bnz stake_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:169
    // assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    frame_dig 0
    frame_dig 1
    >=
    assert // Initial stake below minimum

stake_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:173
    // stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    frame_dig 4
    frame_dig 0
    dup
    cover 2
    +
    itob
    frame_dig 3
    swap
    replace2 0
    // smart_contracts/staking/contract.algo.ts:174
    // stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    global LatestTimestamp
    itob
    replace2 8
    // smart_contracts/staking/contract.algo.ts:177
    // this.storeUserStakeInfo(senderAddress, stakeInfo)
    frame_dig 2
    swap
    callsub storeUserStakeInfo
    pop
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:180
    // this.totalStaked.value = this.totalStaked.value + stakeAmount
    +
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "totalStaked"
    // smart_contracts/staking/contract.algo.ts:180
    // this.totalStaked.value = this.totalStaked.value + stakeAmount
    swap
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.withdraw(amount: uint64) -> void:
withdraw:
    // smart_contracts/staking/contract.algo.ts:186-187
    // @abimethod()
    // public withdraw(amount: uint64): void {
    proto 1 0
    // smart_contracts/staking/contract.algo.ts:188
    // const senderAddress = Txn.sender
    txn Sender
    dup
    // smart_contracts/staking/contract.algo.ts:189
    // const stakeInfo = this.getUserStakeInfo(senderAddress)
    callsub getUserStakeInfo
    dup
    // smart_contracts/staking/contract.algo.ts:192
    // assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    intc_0 // 0
    extract_uint64
    dupn 2
    assert // No stake found
    // smart_contracts/staking/contract.algo.ts:193
    // assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    frame_dig -1
    dig 1
    <=
    assert // Withdrawal amount exceeds stake
    // smart_contracts/staking/contract.algo.ts:194
    // assert(amount > 0, 'Withdrawal amount must be positive')
    frame_dig -1
    assert // Withdrawal amount must be positive
    // smart_contracts/staking/contract.algo.ts:198
    // if (amount < stakeInfo.stakedAmount.native) {
    frame_dig -1
    >
    bz withdraw_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:199
    // const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    frame_dig 2
    frame_dig -1
    -
    // smart_contracts/staking/contract.algo.ts:52
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 5 // "minimumStake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:201
    // assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    >=
    assert // Remaining stake would be below minimum

withdraw_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:205
    // stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    frame_dig 2
    frame_dig -1
    -
    itob
    frame_dig 1
    swap
    replace2 0
    // smart_contracts/staking/contract.algo.ts:208
    // this.storeUserStakeInfo(senderAddress, stakeInfo)
    frame_dig 0
    swap
    callsub storeUserStakeInfo
    pop
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:211
    // this.totalStaked.value = this.totalStaked.value - amount
    frame_dig -1
    -
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "totalStaked"
    // smart_contracts/staking/contract.algo.ts:211
    // this.totalStaked.value = this.totalStaked.value - amount
    swap
    app_global_put
    // smart_contracts/staking/contract.algo.ts:46
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:215-222
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/staking/contract.algo.ts:217
    // assetReceiver: Txn.sender,
    txn Sender
    swap
    itxn_field XferAsset
    frame_dig -1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/staking/contract.algo.ts:215-221
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/contract.algo.ts:220
    // fee: 1000,
    pushint 1000 // 1000
    itxn_field Fee
    // smart_contracts/staking/contract.algo.ts:215-222
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Txn.sender,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.distributeRewards() -> void:
distributeRewards:
    // smart_contracts/staking/contract.algo.ts:47
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_2 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:234
    // assert(Txn.sender === adminAddr, 'Only admin can distribute rewards')
    txn Sender
    ==
    assert // Only admin can distribute rewards
    // smart_contracts/staking/contract.algo.ts:237
    // assert(Global.groupSize === 2, 'Expected 2 txns in group')
    global GroupSize
    pushint 2 // 2
    ==
    assert // Expected 2 txns in group
    // smart_contracts/staking/contract.algo.ts:46
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:241
    // const xferTxn = gtxn.AssetTransferTxn(1)
    intc_1 // 1
    gtxns TypeEnum
    dup
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/staking/contract.algo.ts:242
    // assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 1 must be asset transfer')
    intc_2 // 4
    ==
    assert // Transaction 1 must be asset transfer
    // smart_contracts/staking/contract.algo.ts:241
    // const xferTxn = gtxn.AssetTransferTxn(1)
    intc_1 // 1
    // smart_contracts/staking/contract.algo.ts:243
    // assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // Asset transfer must be to contract
    // smart_contracts/staking/contract.algo.ts:241
    // const xferTxn = gtxn.AssetTransferTxn(1)
    intc_1 // 1
    // smart_contracts/staking/contract.algo.ts:244
    // assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    gtxns AssetAmount
    assert // Must provide non-zero rewards
    // smart_contracts/staking/contract.algo.ts:241
    // const xferTxn = gtxn.AssetTransferTxn(1)
    intc_1 // 1
    // smart_contracts/staking/contract.algo.ts:245
    // assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    gtxns XferAsset
    ==
    assert // Incorrect asset ID
    // smart_contracts/staking/contract.algo.ts:248
    // const currentTime = Global.latestTimestamp
    global LatestTimestamp
    // smart_contracts/staking/contract.algo.ts:50
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_3 // "lastDistributionTime"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:51
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 7 // "distributionPeriodSeconds"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:251
    // assert(currentTime >= lastDistributionTime + periodSeconds, 'Distribution period has not passed')
    +
    dig 1
    <=
    assert // Distribution period has not passed
    // smart_contracts/staking/contract.algo.ts:50
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    bytec_3 // "lastDistributionTime"
    // smart_contracts/staking/contract.algo.ts:254
    // this.lastDistributionTime.value = currentTime
    swap
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.calculateUserRewards(userAddress: bytes) -> uint64:
calculateUserRewards:
    // smart_contracts/staking/contract.algo.ts:263-264
    // @abimethod({ readonly: true })
    // public calculateUserRewards(userAddress: Account): uint64 {
    proto 1 1
    intc_0 // 0
    pushbytes ""
    // smart_contracts/staking/contract.algo.ts:49
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 4 // "aprBasisPoints"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:269
    // if (totalStaked === 0) {
    bnz calculateUserRewards_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:270
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

calculateUserRewards_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:275
    // const stakeInfo = this.getUserStakeInfo(userAddr)
    frame_dig -1
    callsub getUserStakeInfo
    dup
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:278
    // if (stakeInfo.stakedAmount.native === 0) {
    intc_0 // 0
    extract_uint64
    dup
    frame_bury 1
    bnz calculateUserRewards_after_if_else@4
    // smart_contracts/staking/contract.algo.ts:279
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

calculateUserRewards_after_if_else@4:
    // smart_contracts/staking/contract.algo.ts:50
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_3 // "lastDistributionTime"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:290
    // if (lastStakeTime.native + 86400 > lastDistributionTime) {
    frame_dig 0
    // smart_contracts/staking/contract.algo.ts:284
    // const lastStakeTime = stakeInfo.lastStakeTime
    intc_3 // 8
    // smart_contracts/staking/contract.algo.ts:290
    // if (lastStakeTime.native + 86400 > lastDistributionTime) {
    extract_uint64
    pushint 86400 // 86400
    +
    <
    bz calculateUserRewards_after_if_else@6
    // smart_contracts/staking/contract.algo.ts:291
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

calculateUserRewards_after_if_else@6:
    // smart_contracts/staking/contract.algo.ts:297
    // const dailyRateBasisPoints: uint64 = ((apr * 100) / 365) * 10000
    frame_dig 2
    pushint 100 // 100
    *
    pushint 365 // 365
    /
    pushint 10000 // 10000
    *
    // smart_contracts/staking/contract.algo.ts:298
    // const reward: uint64 = (userStake.native * dailyRateBasisPoints) / 10000
    frame_dig 1
    *
    pushint 10000 // 10000
    /
    // smart_contracts/staking/contract.algo.ts:300
    // return reward
    frame_bury 0
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.claimRewards() -> void:
claimRewards:
    // smart_contracts/staking/contract.algo.ts:309
    // const senderAddress = Txn.sender
    txn Sender
    // smart_contracts/staking/contract.algo.ts:310
    // const stakeInfo = this.getUserStakeInfo(senderAddress)
    dup
    callsub getUserStakeInfo
    // smart_contracts/staking/contract.algo.ts:313
    // assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    dup
    intc_0 // 0
    extract_uint64
    dup
    assert // No stake found
    // smart_contracts/staking/contract.algo.ts:316
    // const reward = this.calculateUserRewards(Txn.sender)
    txn Sender
    callsub calculateUserRewards
    // smart_contracts/staking/contract.algo.ts:317
    // assert(reward > 0, 'No rewards to claim')
    dup
    assert // No rewards to claim
    // smart_contracts/staking/contract.algo.ts:320
    // stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + reward)
    swap
    dig 1
    +
    itob
    uncover 2
    swap
    replace2 0
    // smart_contracts/staking/contract.algo.ts:323
    // stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + reward)
    dup
    pushint 16 // 16
    extract_uint64
    dig 2
    +
    itob
    replace2 16
    // smart_contracts/staking/contract.algo.ts:326
    // this.storeUserStakeInfo(senderAddress, stakeInfo)
    uncover 2
    swap
    callsub storeUserStakeInfo
    pop
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:329
    // this.totalStaked.value = this.totalStaked.value + reward
    +
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "totalStaked"
    // smart_contracts/staking/contract.algo.ts:329
    // this.totalStaked.value = this.totalStaked.value + reward
    swap
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.updateAPR(newAprBasisPoints: uint64) -> void:
updateAPR:
    // smart_contracts/staking/contract.algo.ts:336-337
    // @abimethod()
    // public updateAPR(newAprBasisPoints: uint64): void {
    proto 1 0
    // smart_contracts/staking/contract.algo.ts:47
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_2 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:340
    // assert(Txn.sender === adminAddr, 'Only admin can update APR')
    txn Sender
    ==
    assert // Only admin can update APR
    // smart_contracts/staking/contract.algo.ts:49
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    bytec 4 // "aprBasisPoints"
    // smart_contracts/staking/contract.algo.ts:343
    // this.aprBasisPoints.value = newAprBasisPoints
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.updateAdmin(newAdminAddress: bytes) -> void:
updateAdmin:
    // smart_contracts/staking/contract.algo.ts:350-351
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    proto 1 0
    // smart_contracts/staking/contract.algo.ts:47
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_2 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:354
    // assert(Txn.sender === adminAddr, 'Only admin can update admin')
    txn Sender
    ==
    assert // Only admin can update admin
    // smart_contracts/staking/contract.algo.ts:47
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    bytec_2 // "adminAddress"
    // smart_contracts/staking/contract.algo.ts:357
    // this.adminAddress.value = newAdminAddress
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getUserStats(userAddress: bytes) -> bytes:
getUserStats:
    // smart_contracts/staking/contract.algo.ts:363-364
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    proto 1 1
    // smart_contracts/staking/contract.algo.ts:366
    // const stakeInfo = this.getUserStakeInfo(userAddr)
    frame_dig -1
    callsub getUserStakeInfo
    // smart_contracts/staking/contract.algo.ts:368
    // stakeInfo.stakedAmount.native,
    dup
    intc_0 // 0
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:369
    // stakeInfo.lastStakeTime.native,
    dig 1
    intc_3 // 8
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:370
    // stakeInfo.totalRewardsEarned.native,
    uncover 2
    pushint 16 // 16
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:371
    // this.calculateUserRewards(userAddress),
    frame_dig -1
    callsub calculateUserRewards
    // smart_contracts/staking/contract.algo.ts:368
    // stakeInfo.stakedAmount.native,
    uncover 3
    itob
    // smart_contracts/staking/contract.algo.ts:369
    // stakeInfo.lastStakeTime.native,
    uncover 3
    itob
    // smart_contracts/staking/contract.algo.ts:368-371
    // stakeInfo.stakedAmount.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // this.calculateUserRewards(userAddress),
    concat
    // smart_contracts/staking/contract.algo.ts:370
    // stakeInfo.totalRewardsEarned.native,
    uncover 2
    itob
    // smart_contracts/staking/contract.algo.ts:368-371
    // stakeInfo.stakedAmount.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // this.calculateUserRewards(userAddress),
    concat
    // smart_contracts/staking/contract.algo.ts:371
    // this.calculateUserRewards(userAddress),
    swap
    itob
    // smart_contracts/staking/contract.algo.ts:368-371
    // stakeInfo.stakedAmount.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // this.calculateUserRewards(userAddress),
    concat
    dup
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:374
    // return result
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getContractStats() -> bytes:
getContractStats:
    // smart_contracts/staking/contract.algo.ts:46
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:49
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 4 // "aprBasisPoints"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:50
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_3 // "lastDistributionTime"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:51
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 7 // "distributionPeriodSeconds"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:52
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 5 // "minimumStake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:46
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    uncover 5
    itob
    // smart_contracts/staking/contract.algo.ts:48
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    uncover 5
    itob
    // smart_contracts/staking/contract.algo.ts:48-383
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to get a user's box name
    //  * User address is used as the box name for simplicity
    //  */
    // public getUserBoxName(userAddress: Account): arc4.Address {
    //   const addr = new arc4.Address(userAddress.bytes)
    //   return addr
    // }
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   // Check if box exists
    //   if (userBox.exists) {
    //     const boxData = userBox.value.copy()
    // 
    //     return boxData
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   aprBasisPoints: uint64,
    //   distributionPeriodSeconds: uint64,
    //   minimumStake: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.aprBasisPoints.value = aprBasisPoints
    //   this.lastDistributionTime.value = Global.latestTimestamp
    //   this.distributionPeriodSeconds.value = distributionPeriodSeconds
    //   this.minimumStake.value = minimumStake
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not opted in to ASA')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 1 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    // 
    //   // Get the current user stake info
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Txn.sender,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Distribute rewards to all stakers
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public distributeRewards(): void {
    //   // Ensure only admin can distribute rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can distribute rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(1)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 1 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Check if enough time has passed since last distribution
    //   const currentTime = Global.latestTimestamp
    //   const lastDistributionTime = this.lastDistributionTime.value
    //   const periodSeconds = this.distributionPeriodSeconds.value
    //   assert(currentTime >= lastDistributionTime + periodSeconds, 'Distribution period has not passed')
    // 
    //   // Update last distribution time
    //   this.lastDistributionTime.value = currentTime
    // 
    //   // Note: Actual reward distribution happens via users claiming rewards
    // }
    // 
    // /**
    //  * Calculate rewards for a specific user
    //  * This is a read-only method that doesn't modify state
    //  */
    // @abimethod({ readonly: true })
    // public calculateUserRewards(userAddress: Account): uint64 {
    //   const apr = this.aprBasisPoints.value
    //   const totalStaked = this.totalStaked.value
    // 
    //   // If no total stake, return 0
    //   if (totalStaked === 0) {
    //     return 0
    //   }
    // 
    //   // Get the user's stake info
    //   const userAddr = userAddress
    //   const stakeInfo = this.getUserStakeInfo(userAddr)
    // 
    //   // If user has no stake, return 0
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   // Get user's stake amount and last stake time
    //   const userStake = stakeInfo.stakedAmount
    //   const lastStakeTime = stakeInfo.lastStakeTime
    // 
    //   // Get last distribution time
    //   const lastDistributionTime = this.lastDistributionTime.value
    // 
    //   // User must have been staked for at least 24 hours before the last distribution
    //   if (lastStakeTime.native + 86400 > lastDistributionTime) {
    //     return 0
    //   }
    // 
    //   // Calculate daily reward based on APR
    //   // Daily rate = APR / 365 / 10000 (to account for basis points)
    //   // For a 5% APR (500 basis points), daily rate would be ~0.0137%
    //   const dailyRateBasisPoints: uint64 = ((apr * 100) / 365) * 10000
    //   const reward: uint64 = (userStake.native * dailyRateBasisPoints) / 10000
    // 
    //   return reward
    // }
    // 
    // /**
    //  * Claim rewards for the caller
    //  * This implements the pull-based reward model
    //  */
    // @abimethod()
    // public claimRewards(): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has a stake
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    // 
    //   // Calculate rewards
    //   const reward = this.calculateUserRewards(Txn.sender)
    //   assert(reward > 0, 'No rewards to claim')
    // 
    //   // Update user's staked amount (auto-compound)
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + reward)
    // 
    //   // Update total rewards earned
    //   stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + reward)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global staked amount
    //   this.totalStaked.value = this.totalStaked.value + reward
    // }
    // 
    // /**
    //  * Update the APR basis points
    //  * Only the admin can call this
    //  */
    // @abimethod()
    // public updateAPR(newAprBasisPoints: uint64): void {
    //   // Ensure only admin can update APR
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update APR')
    // 
    //   // Update APR
    //   this.aprBasisPoints.value = newAprBasisPoints
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const userAddr = userAddress
    //   const stakeInfo = this.getUserStakeInfo(userAddr)
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     this.calculateUserRewards(userAddress),
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const result: uint64[] = [
    //     this.asset.value.id,
    concat
    // smart_contracts/staking/contract.algo.ts:49
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    uncover 4
    itob
    // smart_contracts/staking/contract.algo.ts:48-383
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to get a user's box name
    //  * User address is used as the box name for simplicity
    //  */
    // public getUserBoxName(userAddress: Account): arc4.Address {
    //   const addr = new arc4.Address(userAddress.bytes)
    //   return addr
    // }
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   // Check if box exists
    //   if (userBox.exists) {
    //     const boxData = userBox.value.copy()
    // 
    //     return boxData
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   aprBasisPoints: uint64,
    //   distributionPeriodSeconds: uint64,
    //   minimumStake: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.aprBasisPoints.value = aprBasisPoints
    //   this.lastDistributionTime.value = Global.latestTimestamp
    //   this.distributionPeriodSeconds.value = distributionPeriodSeconds
    //   this.minimumStake.value = minimumStake
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not opted in to ASA')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 1 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    // 
    //   // Get the current user stake info
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Txn.sender,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Distribute rewards to all stakers
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public distributeRewards(): void {
    //   // Ensure only admin can distribute rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can distribute rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(1)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 1 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Check if enough time has passed since last distribution
    //   const currentTime = Global.latestTimestamp
    //   const lastDistributionTime = this.lastDistributionTime.value
    //   const periodSeconds = this.distributionPeriodSeconds.value
    //   assert(currentTime >= lastDistributionTime + periodSeconds, 'Distribution period has not passed')
    // 
    //   // Update last distribution time
    //   this.lastDistributionTime.value = currentTime
    // 
    //   // Note: Actual reward distribution happens via users claiming rewards
    // }
    // 
    // /**
    //  * Calculate rewards for a specific user
    //  * This is a read-only method that doesn't modify state
    //  */
    // @abimethod({ readonly: true })
    // public calculateUserRewards(userAddress: Account): uint64 {
    //   const apr = this.aprBasisPoints.value
    //   const totalStaked = this.totalStaked.value
    // 
    //   // If no total stake, return 0
    //   if (totalStaked === 0) {
    //     return 0
    //   }
    // 
    //   // Get the user's stake info
    //   const userAddr = userAddress
    //   const stakeInfo = this.getUserStakeInfo(userAddr)
    // 
    //   // If user has no stake, return 0
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   // Get user's stake amount and last stake time
    //   const userStake = stakeInfo.stakedAmount
    //   const lastStakeTime = stakeInfo.lastStakeTime
    // 
    //   // Get last distribution time
    //   const lastDistributionTime = this.lastDistributionTime.value
    // 
    //   // User must have been staked for at least 24 hours before the last distribution
    //   if (lastStakeTime.native + 86400 > lastDistributionTime) {
    //     return 0
    //   }
    // 
    //   // Calculate daily reward based on APR
    //   // Daily rate = APR / 365 / 10000 (to account for basis points)
    //   // For a 5% APR (500 basis points), daily rate would be ~0.0137%
    //   const dailyRateBasisPoints: uint64 = ((apr * 100) / 365) * 10000
    //   const reward: uint64 = (userStake.native * dailyRateBasisPoints) / 10000
    // 
    //   return reward
    // }
    // 
    // /**
    //  * Claim rewards for the caller
    //  * This implements the pull-based reward model
    //  */
    // @abimethod()
    // public claimRewards(): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has a stake
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    // 
    //   // Calculate rewards
    //   const reward = this.calculateUserRewards(Txn.sender)
    //   assert(reward > 0, 'No rewards to claim')
    // 
    //   // Update user's staked amount (auto-compound)
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + reward)
    // 
    //   // Update total rewards earned
    //   stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + reward)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global staked amount
    //   this.totalStaked.value = this.totalStaked.value + reward
    // }
    // 
    // /**
    //  * Update the APR basis points
    //  * Only the admin can call this
    //  */
    // @abimethod()
    // public updateAPR(newAprBasisPoints: uint64): void {
    //   // Ensure only admin can update APR
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update APR')
    // 
    //   // Update APR
    //   this.aprBasisPoints.value = newAprBasisPoints
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const userAddr = userAddress
    //   const stakeInfo = this.getUserStakeInfo(userAddr)
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     this.calculateUserRewards(userAddress),
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const result: uint64[] = [
    //     this.asset.value.id,
    concat
    // smart_contracts/staking/contract.algo.ts:50
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    uncover 3
    itob
    // smart_contracts/staking/contract.algo.ts:48-383
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to get a user's box name
    //  * User address is used as the box name for simplicity
    //  */
    // public getUserBoxName(userAddress: Account): arc4.Address {
    //   const addr = new arc4.Address(userAddress.bytes)
    //   return addr
    // }
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   // Check if box exists
    //   if (userBox.exists) {
    //     const boxData = userBox.value.copy()
    // 
    //     return boxData
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   aprBasisPoints: uint64,
    //   distributionPeriodSeconds: uint64,
    //   minimumStake: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.aprBasisPoints.value = aprBasisPoints
    //   this.lastDistributionTime.value = Global.latestTimestamp
    //   this.distributionPeriodSeconds.value = distributionPeriodSeconds
    //   this.minimumStake.value = minimumStake
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not opted in to ASA')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 1 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    // 
    //   // Get the current user stake info
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Txn.sender,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Distribute rewards to all stakers
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public distributeRewards(): void {
    //   // Ensure only admin can distribute rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can distribute rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(1)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 1 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Check if enough time has passed since last distribution
    //   const currentTime = Global.latestTimestamp
    //   const lastDistributionTime = this.lastDistributionTime.value
    //   const periodSeconds = this.distributionPeriodSeconds.value
    //   assert(currentTime >= lastDistributionTime + periodSeconds, 'Distribution period has not passed')
    // 
    //   // Update last distribution time
    //   this.lastDistributionTime.value = currentTime
    // 
    //   // Note: Actual reward distribution happens via users claiming rewards
    // }
    // 
    // /**
    //  * Calculate rewards for a specific user
    //  * This is a read-only method that doesn't modify state
    //  */
    // @abimethod({ readonly: true })
    // public calculateUserRewards(userAddress: Account): uint64 {
    //   const apr = this.aprBasisPoints.value
    //   const totalStaked = this.totalStaked.value
    // 
    //   // If no total stake, return 0
    //   if (totalStaked === 0) {
    //     return 0
    //   }
    // 
    //   // Get the user's stake info
    //   const userAddr = userAddress
    //   const stakeInfo = this.getUserStakeInfo(userAddr)
    // 
    //   // If user has no stake, return 0
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   // Get user's stake amount and last stake time
    //   const userStake = stakeInfo.stakedAmount
    //   const lastStakeTime = stakeInfo.lastStakeTime
    // 
    //   // Get last distribution time
    //   const lastDistributionTime = this.lastDistributionTime.value
    // 
    //   // User must have been staked for at least 24 hours before the last distribution
    //   if (lastStakeTime.native + 86400 > lastDistributionTime) {
    //     return 0
    //   }
    // 
    //   // Calculate daily reward based on APR
    //   // Daily rate = APR / 365 / 10000 (to account for basis points)
    //   // For a 5% APR (500 basis points), daily rate would be ~0.0137%
    //   const dailyRateBasisPoints: uint64 = ((apr * 100) / 365) * 10000
    //   const reward: uint64 = (userStake.native * dailyRateBasisPoints) / 10000
    // 
    //   return reward
    // }
    // 
    // /**
    //  * Claim rewards for the caller
    //  * This implements the pull-based reward model
    //  */
    // @abimethod()
    // public claimRewards(): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has a stake
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    // 
    //   // Calculate rewards
    //   const reward = this.calculateUserRewards(Txn.sender)
    //   assert(reward > 0, 'No rewards to claim')
    // 
    //   // Update user's staked amount (auto-compound)
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + reward)
    // 
    //   // Update total rewards earned
    //   stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + reward)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global staked amount
    //   this.totalStaked.value = this.totalStaked.value + reward
    // }
    // 
    // /**
    //  * Update the APR basis points
    //  * Only the admin can call this
    //  */
    // @abimethod()
    // public updateAPR(newAprBasisPoints: uint64): void {
    //   // Ensure only admin can update APR
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update APR')
    // 
    //   // Update APR
    //   this.aprBasisPoints.value = newAprBasisPoints
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const userAddr = userAddress
    //   const stakeInfo = this.getUserStakeInfo(userAddr)
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     this.calculateUserRewards(userAddress),
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const result: uint64[] = [
    //     this.asset.value.id,
    concat
    // smart_contracts/staking/contract.algo.ts:51
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    uncover 2
    itob
    // smart_contracts/staking/contract.algo.ts:48-383
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to get a user's box name
    //  * User address is used as the box name for simplicity
    //  */
    // public getUserBoxName(userAddress: Account): arc4.Address {
    //   const addr = new arc4.Address(userAddress.bytes)
    //   return addr
    // }
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   // Check if box exists
    //   if (userBox.exists) {
    //     const boxData = userBox.value.copy()
    // 
    //     return boxData
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   aprBasisPoints: uint64,
    //   distributionPeriodSeconds: uint64,
    //   minimumStake: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.aprBasisPoints.value = aprBasisPoints
    //   this.lastDistributionTime.value = Global.latestTimestamp
    //   this.distributionPeriodSeconds.value = distributionPeriodSeconds
    //   this.minimumStake.value = minimumStake
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not opted in to ASA')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 1 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    // 
    //   // Get the current user stake info
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Txn.sender,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Distribute rewards to all stakers
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public distributeRewards(): void {
    //   // Ensure only admin can distribute rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can distribute rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(1)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 1 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Check if enough time has passed since last distribution
    //   const currentTime = Global.latestTimestamp
    //   const lastDistributionTime = this.lastDistributionTime.value
    //   const periodSeconds = this.distributionPeriodSeconds.value
    //   assert(currentTime >= lastDistributionTime + periodSeconds, 'Distribution period has not passed')
    // 
    //   // Update last distribution time
    //   this.lastDistributionTime.value = currentTime
    // 
    //   // Note: Actual reward distribution happens via users claiming rewards
    // }
    // 
    // /**
    //  * Calculate rewards for a specific user
    //  * This is a read-only method that doesn't modify state
    //  */
    // @abimethod({ readonly: true })
    // public calculateUserRewards(userAddress: Account): uint64 {
    //   const apr = this.aprBasisPoints.value
    //   const totalStaked = this.totalStaked.value
    // 
    //   // If no total stake, return 0
    //   if (totalStaked === 0) {
    //     return 0
    //   }
    // 
    //   // Get the user's stake info
    //   const userAddr = userAddress
    //   const stakeInfo = this.getUserStakeInfo(userAddr)
    // 
    //   // If user has no stake, return 0
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   // Get user's stake amount and last stake time
    //   const userStake = stakeInfo.stakedAmount
    //   const lastStakeTime = stakeInfo.lastStakeTime
    // 
    //   // Get last distribution time
    //   const lastDistributionTime = this.lastDistributionTime.value
    // 
    //   // User must have been staked for at least 24 hours before the last distribution
    //   if (lastStakeTime.native + 86400 > lastDistributionTime) {
    //     return 0
    //   }
    // 
    //   // Calculate daily reward based on APR
    //   // Daily rate = APR / 365 / 10000 (to account for basis points)
    //   // For a 5% APR (500 basis points), daily rate would be ~0.0137%
    //   const dailyRateBasisPoints: uint64 = ((apr * 100) / 365) * 10000
    //   const reward: uint64 = (userStake.native * dailyRateBasisPoints) / 10000
    // 
    //   return reward
    // }
    // 
    // /**
    //  * Claim rewards for the caller
    //  * This implements the pull-based reward model
    //  */
    // @abimethod()
    // public claimRewards(): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has a stake
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    // 
    //   // Calculate rewards
    //   const reward = this.calculateUserRewards(Txn.sender)
    //   assert(reward > 0, 'No rewards to claim')
    // 
    //   // Update user's staked amount (auto-compound)
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + reward)
    // 
    //   // Update total rewards earned
    //   stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + reward)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global staked amount
    //   this.totalStaked.value = this.totalStaked.value + reward
    // }
    // 
    // /**
    //  * Update the APR basis points
    //  * Only the admin can call this
    //  */
    // @abimethod()
    // public updateAPR(newAprBasisPoints: uint64): void {
    //   // Ensure only admin can update APR
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update APR')
    // 
    //   // Update APR
    //   this.aprBasisPoints.value = newAprBasisPoints
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const userAddr = userAddress
    //   const stakeInfo = this.getUserStakeInfo(userAddr)
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     this.calculateUserRewards(userAddress),
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const result: uint64[] = [
    //     this.asset.value.id,
    concat
    // smart_contracts/staking/contract.algo.ts:52
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    swap
    itob
    // smart_contracts/staking/contract.algo.ts:48-383
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public aprBasisPoints = GlobalState<uint64>({ initialValue: 0 })
    // public lastDistributionTime = GlobalState<uint64>({ initialValue: 0 })
    // public distributionPeriodSeconds = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to get a user's box name
    //  * User address is used as the box name for simplicity
    //  */
    // public getUserBoxName(userAddress: Account): arc4.Address {
    //   const addr = new arc4.Address(userAddress.bytes)
    //   return addr
    // }
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   // Check if box exists
    //   if (userBox.exists) {
    //     const boxData = userBox.value.copy()
    // 
    //     return boxData
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   aprBasisPoints: uint64,
    //   distributionPeriodSeconds: uint64,
    //   minimumStake: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.aprBasisPoints.value = aprBasisPoints
    //   this.lastDistributionTime.value = Global.latestTimestamp
    //   this.distributionPeriodSeconds.value = distributionPeriodSeconds
    //   this.minimumStake.value = minimumStake
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not opted in to ASA')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 1 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    // 
    //   // Get the current user stake info
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Txn.sender,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Distribute rewards to all stakers
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public distributeRewards(): void {
    //   // Ensure only admin can distribute rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can distribute rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(1)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 1 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Check if enough time has passed since last distribution
    //   const currentTime = Global.latestTimestamp
    //   const lastDistributionTime = this.lastDistributionTime.value
    //   const periodSeconds = this.distributionPeriodSeconds.value
    //   assert(currentTime >= lastDistributionTime + periodSeconds, 'Distribution period has not passed')
    // 
    //   // Update last distribution time
    //   this.lastDistributionTime.value = currentTime
    // 
    //   // Note: Actual reward distribution happens via users claiming rewards
    // }
    // 
    // /**
    //  * Calculate rewards for a specific user
    //  * This is a read-only method that doesn't modify state
    //  */
    // @abimethod({ readonly: true })
    // public calculateUserRewards(userAddress: Account): uint64 {
    //   const apr = this.aprBasisPoints.value
    //   const totalStaked = this.totalStaked.value
    // 
    //   // If no total stake, return 0
    //   if (totalStaked === 0) {
    //     return 0
    //   }
    // 
    //   // Get the user's stake info
    //   const userAddr = userAddress
    //   const stakeInfo = this.getUserStakeInfo(userAddr)
    // 
    //   // If user has no stake, return 0
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   // Get user's stake amount and last stake time
    //   const userStake = stakeInfo.stakedAmount
    //   const lastStakeTime = stakeInfo.lastStakeTime
    // 
    //   // Get last distribution time
    //   const lastDistributionTime = this.lastDistributionTime.value
    // 
    //   // User must have been staked for at least 24 hours before the last distribution
    //   if (lastStakeTime.native + 86400 > lastDistributionTime) {
    //     return 0
    //   }
    // 
    //   // Calculate daily reward based on APR
    //   // Daily rate = APR / 365 / 10000 (to account for basis points)
    //   // For a 5% APR (500 basis points), daily rate would be ~0.0137%
    //   const dailyRateBasisPoints: uint64 = ((apr * 100) / 365) * 10000
    //   const reward: uint64 = (userStake.native * dailyRateBasisPoints) / 10000
    // 
    //   return reward
    // }
    // 
    // /**
    //  * Claim rewards for the caller
    //  * This implements the pull-based reward model
    //  */
    // @abimethod()
    // public claimRewards(): void {
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has a stake
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    // 
    //   // Calculate rewards
    //   const reward = this.calculateUserRewards(Txn.sender)
    //   assert(reward > 0, 'No rewards to claim')
    // 
    //   // Update user's staked amount (auto-compound)
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + reward)
    // 
    //   // Update total rewards earned
    //   stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + reward)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global staked amount
    //   this.totalStaked.value = this.totalStaked.value + reward
    // }
    // 
    // /**
    //  * Update the APR basis points
    //  * Only the admin can call this
    //  */
    // @abimethod()
    // public updateAPR(newAprBasisPoints: uint64): void {
    //   // Ensure only admin can update APR
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update APR')
    // 
    //   // Update APR
    //   this.aprBasisPoints.value = newAprBasisPoints
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const userAddr = userAddress
    //   const stakeInfo = this.getUserStakeInfo(userAddr)
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     this.calculateUserRewards(userAddress),
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const result: uint64[] = [
    //     this.asset.value.id,
    concat
    dup
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:391
    // return result
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.deleteUserBox(userAddress: bytes) -> void:
deleteUserBox:
    // smart_contracts/staking/contract.algo.ts:398-399
    // @abimethod()
    // public deleteUserBox(userAddress: Account): void {
    proto 1 0
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:47
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    dup
    bytec_2 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:404
    // assert(Txn.sender === boxOwner || Txn.sender === adminAddr, 'Only box owner or admin can delete box')
    txn Sender
    frame_dig -1
    ==
    bnz deleteUserBox_bool_true@2
    txn Sender
    frame_dig 1
    ==
    bz deleteUserBox_bool_false@3

deleteUserBox_bool_true@2:
    intc_1 // 1

deleteUserBox_bool_merge@4:
    // smart_contracts/staking/contract.algo.ts:404
    // assert(Txn.sender === boxOwner || Txn.sender === adminAddr, 'Only box owner or admin can delete box')
    assert // Only box owner or admin can delete box
    // smart_contracts/staking/contract.algo.ts:408
    // const stakeInfo = this.getUserStakeInfo(userAddr)
    frame_dig -1
    callsub getUserStakeInfo
    // smart_contracts/staking/contract.algo.ts:409
    // assert(stakeInfo.stakedAmount.native === 0, 'User still has active stake')
    intc_0 // 0
    extract_uint64
    !
    assert // User still has active stake
    // smart_contracts/staking/contract.algo.ts:54
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    bytec 8 // "stakers"
    // smart_contracts/staking/contract.algo.ts:412
    // const userBox = this.stakers(userAddress)
    frame_dig -1
    // smart_contracts/staking/contract.algo.ts:54
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    concat
    // smart_contracts/staking/contract.algo.ts:412
    // const userBox = this.stakers(userAddress)
    dup
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:413
    // if (userBox.exists) {
    box_len
    bury 1
    bz deleteUserBox_after_if_else@6
    // smart_contracts/staking/contract.algo.ts:414
    // userBox.delete()
    frame_dig 0
    box_del
    pop

deleteUserBox_after_if_else@6:
    retsub

deleteUserBox_bool_false@3:
    intc_0 // 0
    b deleteUserBox_bool_merge@4
