#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 4 24 1000
    bytecblock "rewardPool" "asset" "totalStaked" "adminAddress" "accumulatedRewardsPerShare" "precision" "lastRewardTime" "minimumStake" "weeklyRewards" "rewardPeriod" 0x151f7c75 "stakers"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    bytec_1 // "asset"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    bytec_3 // "adminAddress"
    global ZeroAddress
    app_global_put
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_2 // "totalStaked"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:55
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    bytec 6 // "lastRewardTime"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:56
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    bytec 7 // "minimumStake"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "rewardPool"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:58
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    bytec 4 // "accumulatedRewardsPerShare"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:61
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    bytec 8 // "weeklyRewards"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:62
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    bytec 9 // "rewardPeriod"
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:63
    // public precision = GlobalState<uint64>({ initialValue: 0 })
    bytec 5 // "precision"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txn NumAppArgs
    bz main_bare_routing@25
    pushbytess 0x5d789521 0x080f6ecd 0x667c5d30 0x9ffd3e53 0x0890bd58 0x21f1ddff 0xa5ae6bd1 0xb3b70146 0xbf8b766d 0x183838e9 0x21b1b022 0x82ab1ec4 0x15766b09 0xbfe31564 0xce963b1d 0xdc9a2a05 0x1e2b52ab 0x1b874ad6 // method "getUserStakeInfo(account)(uint64,uint64,uint64,uint64,uint64)", method "storeUserStakeInfo(account,(uint64,uint64,uint64,uint64,uint64))void", method "initialize(asset,account,uint64,uint64,uint64)void", method "optInToAsset()void", method "stake()void", method "withdraw(uint64)void", method "claimRewards()void", method "addRewards()void", method "getCurrentAPY()uint64", method "getPendingRewards(account)uint64", method "triggerRewardDistribution()void", method "updateAdmin(account)void", method "getUserStats(account)uint64[]", method "getContractStats()uint64[]", method "emergencyWithdrawRewards(uint64)void", method "deleteUserBox(account)void", method "updateWeeklyRewards(uint64)void", method "updateRewardPeriod(uint64)void"
    txna ApplicationArgs 0
    match main_getUserStakeInfo_route@5 main_storeUserStakeInfo_route@6 main_initialize_route@7 main_optInToAsset_route@8 main_stake_route@9 main_withdraw_route@10 main_claimRewards_route@11 main_addRewards_route@12 main_getCurrentAPY_route@13 main_getPendingRewards_route@14 main_triggerRewardDistribution_route@15 main_updateAdmin_route@16 main_getUserStats_route@17 main_getContractStats_route@18 main_emergencyWithdrawRewards_route@19 main_deleteUserBox_route@20 main_updateWeeklyRewards_route@21 main_updateRewardPeriod_route@22

main_after_if_else@29:
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    intc_0 // 0
    return

main_updateRewardPeriod_route@22:
    // smart_contracts/staking/contract.algo.ts:564
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/staking/contract.algo.ts:564
    // @abimethod()
    callsub updateRewardPeriod
    intc_1 // 1
    return

main_updateWeeklyRewards_route@21:
    // smart_contracts/staking/contract.algo.ts:548
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/staking/contract.algo.ts:548
    // @abimethod()
    callsub updateWeeklyRewards
    intc_1 // 1
    return

main_deleteUserBox_route@20:
    // smart_contracts/staking/contract.algo.ts:526
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:526
    // @abimethod()
    callsub deleteUserBox
    intc_1 // 1
    return

main_emergencyWithdrawRewards_route@19:
    // smart_contracts/staking/contract.algo.ts:498
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/staking/contract.algo.ts:498
    // @abimethod()
    callsub emergencyWithdrawRewards
    intc_1 // 1
    return

main_getContractStats_route@18:
    // smart_contracts/staking/contract.algo.ts:477
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getContractStats
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getUserStats_route@17:
    // smart_contracts/staking/contract.algo.ts:457
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:457
    // @abimethod({ readonly: true })
    callsub getUserStats
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_updateAdmin_route@16:
    // smart_contracts/staking/contract.algo.ts:444
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:444
    // @abimethod()
    callsub updateAdmin
    intc_1 // 1
    return

main_triggerRewardDistribution_route@15:
    // smart_contracts/staking/contract.algo.ts:430
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub triggerRewardDistribution
    intc_1 // 1
    return

main_getPendingRewards_route@14:
    // smart_contracts/staking/contract.algo.ts:421
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:421
    // @abimethod({ readonly: true })
    callsub getPendingRewards
    itob
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getCurrentAPY_route@13:
    // smart_contracts/staking/contract.algo.ts:401
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getCurrentAPY
    itob
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_addRewards_route@12:
    // smart_contracts/staking/contract.algo.ts:377
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub addRewards
    intc_1 // 1
    return

main_claimRewards_route@11:
    // smart_contracts/staking/contract.algo.ts:334
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub claimRewards
    intc_1 // 1
    return

main_withdraw_route@10:
    // smart_contracts/staking/contract.algo.ts:268
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/staking/contract.algo.ts:268
    // @abimethod()
    callsub withdraw
    intc_1 // 1
    return

main_stake_route@9:
    // smart_contracts/staking/contract.algo.ts:204
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub stake
    intc_1 // 1
    return

main_optInToAsset_route@8:
    // smart_contracts/staking/contract.algo.ts:182
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub optInToAsset
    intc_1 // 1
    return

main_initialize_route@7:
    // smart_contracts/staking/contract.algo.ts:150
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    btoi
    txnas Accounts
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    // smart_contracts/staking/contract.algo.ts:150
    // @abimethod()
    callsub initialize
    intc_1 // 1
    return

main_storeUserStakeInfo_route@6:
    // smart_contracts/staking/contract.algo.ts:89
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    // smart_contracts/staking/contract.algo.ts:89
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    callsub storeUserStakeInfo
    pop
    intc_1 // 1
    return

main_getUserStakeInfo_route@5:
    // smart_contracts/staking/contract.algo.ts:70
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/staking/contract.algo.ts:70
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    callsub getUserStakeInfo
    bytec 10 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@25:
    // smart_contracts/staking/contract.algo.ts:50-51
    // @contract({ stateTotals: { globalBytes: 8 } })
    // export class ASAStakingContract extends Contract {
    txn OnCompletion
    bnz main_after_if_else@29
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getUserStakeInfo(userAddress: bytes) -> bytes:
getUserStakeInfo:
    // smart_contracts/staking/contract.algo.ts:70
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    proto 1 1
    // smart_contracts/staking/contract.algo.ts:65
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    bytec 11 // "stakers"
    // smart_contracts/staking/contract.algo.ts:71
    // const userBox = this.stakers(userAddress)
    frame_dig -1
    // smart_contracts/staking/contract.algo.ts:65
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    concat
    // smart_contracts/staking/contract.algo.ts:71
    // const userBox = this.stakers(userAddress)
    dup
    // smart_contracts/staking/contract.algo.ts:73
    // if (userBox.exists) {
    box_len
    bury 1
    bz getUserStakeInfo_else_body@2
    // smart_contracts/staking/contract.algo.ts:74
    // return userBox.value.copy()
    frame_dig 0
    box_get
    assert // Box must have value
    swap
    retsub

getUserStakeInfo_else_body@2:
    // smart_contracts/staking/contract.algo.ts:76-82
    // return new UserStakeInfo({
    //   stakedAmount: new arc4.UintN64(0),
    //   firstStakeTime: new arc4.UintN64(0),
    //   lastStakeTime: new arc4.UintN64(0),
    //   totalRewardsEarned: new arc4.UintN64(0),
    //   rewardDebt: new arc4.UintN64(0),
    // })
    pushbytes 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000
    swap
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.storeUserStakeInfo(userAddress: bytes, stakeInfo: bytes) -> bytes:
storeUserStakeInfo:
    // smart_contracts/staking/contract.algo.ts:89
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    proto 2 1
    // smart_contracts/staking/contract.algo.ts:65
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    bytec 11 // "stakers"
    frame_dig -2
    concat
    // smart_contracts/staking/contract.algo.ts:90
    // this.stakers(userAddress).value = stakeInfo.copy()
    frame_dig -1
    box_put
    frame_dig -1
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.updateRewards() -> void:
updateRewards:
    // smart_contracts/staking/contract.algo.ts:96
    // private updateRewards(): void {
    proto 0 0
    // smart_contracts/staking/contract.algo.ts:97
    // const currentTime = Global.latestTimestamp
    global LatestTimestamp
    dup
    // smart_contracts/staking/contract.algo.ts:55
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 6 // "lastRewardTime"
    app_global_get_ex
    swap
    dup
    cover 2
    cover 3
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:62
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 9 // "rewardPeriod"
    app_global_get_ex
    swap
    dup
    cover 2
    cover 4
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:102
    // if (currentTime >= lastReward + rewardPeriod && this.totalStaked.value > 0) {
    +
    >=
    bz updateRewards_after_if_else@3
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_2 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:102
    // if (currentTime >= lastReward + rewardPeriod && this.totalStaked.value > 0) {
    bz updateRewards_after_if_else@3
    // smart_contracts/staking/contract.algo.ts:104
    // const periodsPassed: uint64 = (currentTime - lastReward) / rewardPeriod
    frame_dig 0
    frame_dig 1
    dup
    cover 2
    -
    frame_dig 2
    dup
    cover 2
    /
    // smart_contracts/staking/contract.algo.ts:61
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 8 // "weeklyRewards"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:108
    // const totalRewards: uint64 = rewardPerPeriod * periodsPassed
    dig 1
    *
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_2 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:63
    // public precision = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 5 // "precision"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:113
    // const rewardPerShare: uint64 = (totalRewards * precision) / totalStaked
    dig 2
    *
    swap
    /
    // smart_contracts/staking/contract.algo.ts:58
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 4 // "accumulatedRewardsPerShare"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:115
    // this.accumulatedRewardsPerShare.value = this.accumulatedRewardsPerShare.value + rewardPerShare
    +
    // smart_contracts/staking/contract.algo.ts:58
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    bytec 4 // "accumulatedRewardsPerShare"
    // smart_contracts/staking/contract.algo.ts:115
    // this.accumulatedRewardsPerShare.value = this.accumulatedRewardsPerShare.value + rewardPerShare
    swap
    app_global_put
    // smart_contracts/staking/contract.algo.ts:118
    // this.lastRewardTime.value = lastReward + (periodsPassed * rewardPeriod)
    swap
    uncover 2
    *
    uncover 2
    +
    // smart_contracts/staking/contract.algo.ts:55
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    bytec 6 // "lastRewardTime"
    // smart_contracts/staking/contract.algo.ts:118
    // this.lastRewardTime.value = lastReward + (periodsPassed * rewardPeriod)
    swap
    app_global_put
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:121
    // this.rewardPool.value = this.rewardPool.value - totalRewards
    swap
    -
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "rewardPool"
    // smart_contracts/staking/contract.algo.ts:121
    // this.rewardPool.value = this.rewardPool.value - totalRewards
    swap
    app_global_put

updateRewards_after_if_else@3:
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.calculatePendingRewards(userAddress: bytes) -> uint64:
calculatePendingRewards:
    // smart_contracts/staking/contract.algo.ts:128
    // private calculatePendingRewards(userAddress: Account): uint64 {
    proto 1 1
    pushbytes ""
    dup
    // smart_contracts/staking/contract.algo.ts:129
    // const stakeInfo = this.getUserStakeInfo(userAddress)
    frame_dig -1
    callsub getUserStakeInfo
    dup
    // smart_contracts/staking/contract.algo.ts:131
    // if (stakeInfo.stakedAmount.native === 0) {
    intc_0 // 0
    extract_uint64
    dup
    bnz calculatePendingRewards_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:132
    // return 0
    intc_0 // 0
    frame_bury 0
    retsub

calculatePendingRewards_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:58
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 4 // "accumulatedRewardsPerShare"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:137
    // const userRewardDebt = stakeInfo.rewardDebt.native
    frame_dig 2
    pushint 32 // 32
    extract_uint64
    dup
    cover 2
    frame_bury 1
    // smart_contracts/staking/contract.algo.ts:63
    // public precision = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 5 // "precision"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:141
    // const totalEarned: uint64 = (userStake * accRewardsPerShare) / precision
    frame_dig 3
    uncover 2
    *
    swap
    /
    dup
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:142
    // const pendingRewards: uint64 = totalEarned > userRewardDebt ? totalEarned - userRewardDebt : 0
    <
    bz calculatePendingRewards_ternary_false@4
    frame_dig 0
    frame_dig 1
    -

calculatePendingRewards_ternary_merge@5:
    // smart_contracts/staking/contract.algo.ts:144
    // return pendingRewards
    frame_bury 0
    retsub

calculatePendingRewards_ternary_false@4:
    // smart_contracts/staking/contract.algo.ts:142
    // const pendingRewards: uint64 = totalEarned > userRewardDebt ? totalEarned - userRewardDebt : 0
    intc_0 // 0
    b calculatePendingRewards_ternary_merge@5


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.initialize(asset: uint64, adminAddress: bytes, minimumStake: uint64, weeklyRewards: uint64, rewardPeriod: uint64) -> void:
initialize:
    // smart_contracts/staking/contract.algo.ts:150-157
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   minimumStake: uint64,
    //   weeklyRewards: uint64,
    //   rewardPeriod: uint64,
    // ): void {
    proto 5 0
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:159
    // assert(this.asset.value === Asset(), 'Already initialized')
    !
    assert // Already initialized
    // smart_contracts/staking/contract.algo.ts:162
    // assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can initialize
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    bytec_1 // "asset"
    // smart_contracts/staking/contract.algo.ts:165
    // this.asset.value = asset
    frame_dig -5
    app_global_put
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    bytec_3 // "adminAddress"
    // smart_contracts/staking/contract.algo.ts:166
    // this.adminAddress.value = adminAddress
    frame_dig -4
    app_global_put
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_2 // "totalStaked"
    // smart_contracts/staking/contract.algo.ts:167
    // this.totalStaked.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:55
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    bytec 6 // "lastRewardTime"
    // smart_contracts/staking/contract.algo.ts:168
    // this.lastRewardTime.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/staking/contract.algo.ts:56
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    bytec 7 // "minimumStake"
    // smart_contracts/staking/contract.algo.ts:169
    // this.minimumStake.value = minimumStake
    frame_dig -3
    app_global_put
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "rewardPool"
    // smart_contracts/staking/contract.algo.ts:170
    // this.rewardPool.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:58
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    bytec 4 // "accumulatedRewardsPerShare"
    // smart_contracts/staking/contract.algo.ts:171
    // this.accumulatedRewardsPerShare.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/staking/contract.algo.ts:61
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    bytec 8 // "weeklyRewards"
    // smart_contracts/staking/contract.algo.ts:174
    // this.weeklyRewards.value = weeklyRewards
    frame_dig -2
    app_global_put
    // smart_contracts/staking/contract.algo.ts:62
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    bytec 9 // "rewardPeriod"
    // smart_contracts/staking/contract.algo.ts:175
    // this.rewardPeriod.value = rewardPeriod
    frame_dig -1
    app_global_put
    // smart_contracts/staking/contract.algo.ts:63
    // public precision = GlobalState<uint64>({ initialValue: 0 })
    bytec 5 // "precision"
    // smart_contracts/staking/contract.algo.ts:176
    // this.precision.value = 1_000_000 // Reduced precision from 1e12 to 1e6 to avoid overflow
    pushint 1000000 // 1000000
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.optInToAsset() -> void:
optInToAsset:
    // smart_contracts/staking/contract.algo.ts:182-183
    // @abimethod()
    // public optInToAsset(): void {
    proto 0 0
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_3 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:186
    // assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    txn Sender
    global CreatorAddress
    ==
    bnz optInToAsset_bool_true@2
    txn Sender
    frame_dig 0
    ==
    bz optInToAsset_bool_false@3

optInToAsset_bool_true@2:
    intc_1 // 1

optInToAsset_bool_merge@4:
    // smart_contracts/staking/contract.algo.ts:186
    // assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    assert // Only creator or admin can opt in
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:190-196
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/staking/contract.algo.ts:192
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    swap
    itxn_field XferAsset
    // smart_contracts/staking/contract.algo.ts:193
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/staking/contract.algo.ts:190-195
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/contract.algo.ts:190-196
    // itxn
    //   .assetTransfer({
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     xferAsset: asset,
    //   })
    //   .submit()
    itxn_submit
    retsub

optInToAsset_bool_false@3:
    intc_0 // 0
    b optInToAsset_bool_merge@4


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.stake() -> void:
stake:
    // smart_contracts/staking/contract.algo.ts:204-205
    // @abimethod()
    // public stake(): void {
    proto 0 0
    pushbytes ""
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:208
    // assert(this.asset.value !== Asset(), 'Contract not initialized')
    assert // Contract not initialized
    // smart_contracts/staking/contract.algo.ts:211
    // assert(Global.groupSize === 2, 'Expected 2 txns in group')
    global GroupSize
    pushint 2 // 2
    ==
    assert // Expected 2 txns in group
    // smart_contracts/staking/contract.algo.ts:214
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    gtxns TypeEnum
    dup
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/staking/contract.algo.ts:215
    // assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    intc_2 // 4
    ==
    assert // Transaction 0 must be asset transfer
    // smart_contracts/staking/contract.algo.ts:214
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:216
    // assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // Asset transfer must be to contract
    // smart_contracts/staking/contract.algo.ts:214
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:217
    // assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    gtxns AssetAmount
    dup
    cover 2
    assert // Must stake non-zero amount
    // smart_contracts/staking/contract.algo.ts:214
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:218
    // assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    gtxns XferAsset
    ==
    assert // Incorrect asset ID
    // smart_contracts/staking/contract.algo.ts:221
    // this.updateRewards()
    callsub updateRewards
    // smart_contracts/staking/contract.algo.ts:56
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 7 // "minimumStake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:226
    // const senderAddress = Txn.sender
    txn Sender
    dup
    // smart_contracts/staking/contract.algo.ts:229
    // const stakeInfo = this.getUserStakeInfo(senderAddress)
    callsub getUserStakeInfo
    dupn 2
    // smart_contracts/staking/contract.algo.ts:232
    // if (stakeInfo.stakedAmount.native > 0) {
    intc_0 // 0
    extract_uint64
    dup
    uncover 2
    swap
    bz stake_after_if_else@5
    // smart_contracts/staking/contract.algo.ts:233
    // const pendingRewards = this.calculatePendingRewards(senderAddress)
    frame_dig 3
    callsub calculatePendingRewards
    dup
    frame_bury 0
    frame_dig 4
    frame_bury 6
    // smart_contracts/staking/contract.algo.ts:234
    // if (pendingRewards > 0 && this.rewardPool.value >= pendingRewards) {
    bz stake_after_if_else@5
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:234
    // if (pendingRewards > 0 && this.rewardPool.value >= pendingRewards) {
    frame_dig 0
    >=
    frame_dig 4
    frame_bury 6
    bz stake_after_if_else@5
    // smart_contracts/staking/contract.algo.ts:236
    // stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + pendingRewards)
    frame_dig 5
    frame_dig 0
    dup
    cover 2
    +
    itob
    frame_dig 4
    swap
    replace2 0
    // smart_contracts/staking/contract.algo.ts:237
    // stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    dup
    intc_3 // 24
    extract_uint64
    dig 2
    +
    itob
    replace2 24
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_2 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:238
    // this.totalStaked.value = this.totalStaked.value + pendingRewards
    dig 2
    +
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_2 // "totalStaked"
    // smart_contracts/staking/contract.algo.ts:238
    // this.totalStaked.value = this.totalStaked.value + pendingRewards
    swap
    app_global_put
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:239
    // this.rewardPool.value = this.rewardPool.value - pendingRewards
    uncover 2
    -
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "rewardPool"
    // smart_contracts/staking/contract.algo.ts:239
    // this.rewardPool.value = this.rewardPool.value - pendingRewards
    swap
    app_global_put
    frame_bury 6

stake_after_if_else@5:
    frame_dig 6
    dup
    frame_bury 4
    // smart_contracts/staking/contract.algo.ts:244
    // if (stakeInfo.stakedAmount.native === 0) {
    dup
    intc_0 // 0
    extract_uint64
    swap
    frame_bury 6
    bnz stake_after_if_else@7
    // smart_contracts/staking/contract.algo.ts:245
    // assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    frame_dig 1
    frame_dig 2
    >=
    assert // Initial stake below minimum
    // smart_contracts/staking/contract.algo.ts:247
    // stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    global LatestTimestamp
    itob
    frame_dig 4
    swap
    replace2 8
    frame_bury 6

stake_after_if_else@7:
    frame_dig 6
    // smart_contracts/staking/contract.algo.ts:251
    // stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    dup
    intc_0 // 0
    extract_uint64
    frame_dig 1
    dup
    cover 3
    +
    itob
    replace2 0
    // smart_contracts/staking/contract.algo.ts:252
    // stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    global LatestTimestamp
    itob
    replace2 16
    // smart_contracts/staking/contract.algo.ts:255
    // stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    dup
    intc_0 // 0
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:58
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 4 // "accumulatedRewardsPerShare"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:255
    // stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    *
    // smart_contracts/staking/contract.algo.ts:63
    // public precision = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 5 // "precision"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:255
    // stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    /
    itob
    replace2 32
    // smart_contracts/staking/contract.algo.ts:258
    // this.storeUserStakeInfo(senderAddress, stakeInfo)
    frame_dig 3
    swap
    callsub storeUserStakeInfo
    pop
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_2 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:261
    // this.totalStaked.value = this.totalStaked.value + stakeAmount
    +
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_2 // "totalStaked"
    // smart_contracts/staking/contract.algo.ts:261
    // this.totalStaked.value = this.totalStaked.value + stakeAmount
    swap
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.withdraw(amount: uint64) -> void:
withdraw:
    // smart_contracts/staking/contract.algo.ts:268-269
    // @abimethod()
    // public withdraw(amount: uint64): void {
    proto 1 0
    pushbytes ""
    // smart_contracts/staking/contract.algo.ts:271
    // this.updateRewards()
    callsub updateRewards
    // smart_contracts/staking/contract.algo.ts:273
    // const senderAddress = Txn.sender
    txn Sender
    // smart_contracts/staking/contract.algo.ts:273-274
    // const senderAddress = Txn.sender
    // const stakeInfo = this.getUserStakeInfo(senderAddress)
    dupn 2
    // smart_contracts/staking/contract.algo.ts:274
    // const stakeInfo = this.getUserStakeInfo(senderAddress)
    callsub getUserStakeInfo
    dup
    cover 2
    // smart_contracts/staking/contract.algo.ts:277
    // assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    dup
    intc_0 // 0
    extract_uint64
    dup
    assert // No stake found
    // smart_contracts/staking/contract.algo.ts:278
    // assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    frame_dig -1
    >=
    assert // Withdrawal amount exceeds stake
    // smart_contracts/staking/contract.algo.ts:279
    // assert(amount > 0, 'Withdrawal amount must be positive')
    frame_dig -1
    assert // Withdrawal amount must be positive
    // smart_contracts/staking/contract.algo.ts:282
    // const pendingRewards = this.calculatePendingRewards(senderAddress)
    swap
    callsub calculatePendingRewards
    dup
    uncover 2
    swap
    // smart_contracts/staking/contract.algo.ts:283
    // if (pendingRewards > 0 && this.rewardPool.value >= pendingRewards) {
    bz withdraw_after_if_else@4
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:283
    // if (pendingRewards > 0 && this.rewardPool.value >= pendingRewards) {
    frame_dig 3
    >=
    frame_dig 2
    frame_bury 4
    bz withdraw_after_if_else@4
    // smart_contracts/staking/contract.algo.ts:284
    // stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    frame_dig 2
    dup
    intc_3 // 24
    extract_uint64
    frame_dig 3
    dup
    cover 3
    +
    itob
    replace2 24
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:285
    // this.rewardPool.value = this.rewardPool.value - pendingRewards
    dig 2
    -
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "rewardPool"
    // smart_contracts/staking/contract.algo.ts:285
    // this.rewardPool.value = this.rewardPool.value - pendingRewards
    swap
    app_global_put
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:289-296
    // itxn
    //   .assetTransfer({
    //     assetReceiver: senderAddress,
    //     assetAmount: pendingRewards,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_begin
    itxn_field XferAsset
    swap
    itxn_field AssetAmount
    frame_dig 1
    itxn_field AssetReceiver
    // smart_contracts/staking/contract.algo.ts:289-295
    // itxn
    //   .assetTransfer({
    //     assetReceiver: senderAddress,
    //     assetAmount: pendingRewards,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/contract.algo.ts:294
    // fee: 1000,
    intc 4 // 1000
    itxn_field Fee
    // smart_contracts/staking/contract.algo.ts:289-296
    // itxn
    //   .assetTransfer({
    //     assetReceiver: senderAddress,
    //     assetAmount: pendingRewards,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_submit
    frame_bury 4

withdraw_after_if_else@4:
    frame_dig 4
    dup
    frame_bury 2
    // smart_contracts/staking/contract.algo.ts:301
    // if (amount < stakeInfo.stakedAmount.native) {
    intc_0 // 0
    extract_uint64
    dup
    frame_bury 0
    frame_dig -1
    >
    bz withdraw_after_if_else@6
    // smart_contracts/staking/contract.algo.ts:302
    // const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    frame_dig 0
    frame_dig -1
    -
    // smart_contracts/staking/contract.algo.ts:56
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 7 // "minimumStake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:304
    // assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    >=
    assert // Remaining stake would be below minimum

withdraw_after_if_else@6:
    // smart_contracts/staking/contract.algo.ts:308
    // stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    frame_dig 0
    frame_dig -1
    -
    itob
    frame_dig 2
    swap
    replace2 0
    // smart_contracts/staking/contract.algo.ts:311
    // stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    dup
    intc_0 // 0
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:58
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 4 // "accumulatedRewardsPerShare"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:311
    // stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    *
    // smart_contracts/staking/contract.algo.ts:63
    // public precision = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 5 // "precision"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:311
    // stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    /
    itob
    replace2 32
    // smart_contracts/staking/contract.algo.ts:314
    // this.storeUserStakeInfo(senderAddress, stakeInfo)
    frame_dig 1
    dup
    uncover 2
    callsub storeUserStakeInfo
    pop
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_2 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:317
    // this.totalStaked.value = this.totalStaked.value - amount
    frame_dig -1
    -
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    bytec_2 // "totalStaked"
    // smart_contracts/staking/contract.algo.ts:317
    // this.totalStaked.value = this.totalStaked.value - amount
    swap
    app_global_put
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:321-328
    // itxn
    //   .assetTransfer({
    //     assetReceiver: senderAddress,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_begin
    itxn_field XferAsset
    frame_dig -1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/staking/contract.algo.ts:321-327
    // itxn
    //   .assetTransfer({
    //     assetReceiver: senderAddress,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/contract.algo.ts:326
    // fee: 1000,
    intc 4 // 1000
    itxn_field Fee
    // smart_contracts/staking/contract.algo.ts:321-328
    // itxn
    //   .assetTransfer({
    //     assetReceiver: senderAddress,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.claimRewards() -> void:
claimRewards:
    // smart_contracts/staking/contract.algo.ts:337
    // this.updateRewards()
    callsub updateRewards
    // smart_contracts/staking/contract.algo.ts:339
    // const senderAddress = Txn.sender
    txn Sender
    // smart_contracts/staking/contract.algo.ts:340
    // const stakeInfo = this.getUserStakeInfo(senderAddress)
    dup
    callsub getUserStakeInfo
    // smart_contracts/staking/contract.algo.ts:343
    // assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    dup
    intc_0 // 0
    extract_uint64
    assert // No stake found
    // smart_contracts/staking/contract.algo.ts:346
    // const pendingRewards = this.calculatePendingRewards(senderAddress)
    dig 1
    callsub calculatePendingRewards
    // smart_contracts/staking/contract.algo.ts:347
    // assert(pendingRewards > 0, 'No pending rewards')
    dup
    assert // No pending rewards
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:348
    // assert(this.rewardPool.value >= pendingRewards, 'Insufficient reward pool')
    dig 1
    >=
    assert // Insufficient reward pool
    // smart_contracts/staking/contract.algo.ts:351
    // stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    dig 1
    intc_3 // 24
    extract_uint64
    dig 1
    +
    itob
    uncover 2
    swap
    replace2 24
    // smart_contracts/staking/contract.algo.ts:352
    // stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    dup
    intc_0 // 0
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:58
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 4 // "accumulatedRewardsPerShare"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:352
    // stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    *
    // smart_contracts/staking/contract.algo.ts:63
    // public precision = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 5 // "precision"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:352
    // stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    /
    itob
    replace2 32
    // smart_contracts/staking/contract.algo.ts:355
    // this.storeUserStakeInfo(senderAddress, stakeInfo)
    dig 2
    swap
    callsub storeUserStakeInfo
    pop
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:358
    // this.rewardPool.value = this.rewardPool.value - pendingRewards
    dig 1
    -
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "rewardPool"
    // smart_contracts/staking/contract.algo.ts:358
    // this.rewardPool.value = this.rewardPool.value - pendingRewards
    swap
    app_global_put
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:362-369
    // itxn
    //   .assetTransfer({
    //     assetReceiver: senderAddress,
    //     assetAmount: pendingRewards,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_begin
    itxn_field XferAsset
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/staking/contract.algo.ts:362-368
    // itxn
    //   .assetTransfer({
    //     assetReceiver: senderAddress,
    //     assetAmount: pendingRewards,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/contract.algo.ts:367
    // fee: 1000,
    intc 4 // 1000
    itxn_field Fee
    // smart_contracts/staking/contract.algo.ts:362-369
    // itxn
    //   .assetTransfer({
    //     assetReceiver: senderAddress,
    //     assetAmount: pendingRewards,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.addRewards() -> void:
addRewards:
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_3 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:381
    // assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    txn Sender
    ==
    assert // Only admin can add rewards
    // smart_contracts/staking/contract.algo.ts:384
    // assert(Global.groupSize === 2, 'Expected 2 txns in group')
    global GroupSize
    pushint 2 // 2
    ==
    assert // Expected 2 txns in group
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:388
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    gtxns TypeEnum
    dup
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/staking/contract.algo.ts:389
    // assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    intc_2 // 4
    ==
    assert // Transaction 0 must be asset transfer
    // smart_contracts/staking/contract.algo.ts:388
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:390
    // assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // Asset transfer must be to contract
    // smart_contracts/staking/contract.algo.ts:388
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:391
    // assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    gtxns AssetAmount
    dup
    assert // Must provide non-zero rewards
    // smart_contracts/staking/contract.algo.ts:388
    // const xferTxn = gtxn.AssetTransferTxn(0)
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:392
    // assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    gtxns XferAsset
    uncover 2
    ==
    assert // Incorrect asset ID
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:395
    // this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    +
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "rewardPool"
    // smart_contracts/staking/contract.algo.ts:395
    // this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    swap
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getCurrentAPY() -> uint64:
getCurrentAPY:
    // smart_contracts/staking/contract.algo.ts:401-402
    // @abimethod({ readonly: true })
    // public getCurrentAPY(): uint64 {
    proto 0 1
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_2 // "totalStaked"
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:405
    // if (totalStaked === 0) {
    bnz getCurrentAPY_after_if_else@2
    // smart_contracts/staking/contract.algo.ts:406
    // return 0 // Return 0 if no tokens staked
    intc_0 // 0
    swap
    retsub

getCurrentAPY_after_if_else@2:
    // smart_contracts/staking/contract.algo.ts:61
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 8 // "weeklyRewards"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:410
    // const annualRewards: uint64 = 52 * this.weeklyRewards.value
    pushint 52 // 52
    *
    // smart_contracts/staking/contract.algo.ts:413
    // const apy: uint64 = (annualRewards * 10000) / totalStaked
    pushint 10000 // 10000
    *
    frame_dig 0
    /
    // smart_contracts/staking/contract.algo.ts:415
    // return apy
    swap
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getPendingRewards(userAddress: bytes) -> uint64:
getPendingRewards:
    // smart_contracts/staking/contract.algo.ts:421-422
    // @abimethod({ readonly: true })
    // public getPendingRewards(userAddress: Account): uint64 {
    proto 1 1
    // smart_contracts/staking/contract.algo.ts:423
    // return this.calculatePendingRewards(userAddress)
    frame_dig -1
    callsub calculatePendingRewards
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.triggerRewardDistribution() -> void:
triggerRewardDistribution:
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_3 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:434
    // assert(Txn.sender === adminAddr, 'Only admin can trigger distribution')
    txn Sender
    ==
    assert // Only admin can trigger distribution
    // smart_contracts/staking/contract.algo.ts:437
    // this.updateRewards()
    callsub updateRewards
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.updateAdmin(newAdminAddress: bytes) -> void:
updateAdmin:
    // smart_contracts/staking/contract.algo.ts:444-445
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    proto 1 0
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_3 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:448
    // assert(Txn.sender === adminAddr, 'Only admin can update admin')
    txn Sender
    ==
    assert // Only admin can update admin
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    bytec_3 // "adminAddress"
    // smart_contracts/staking/contract.algo.ts:451
    // this.adminAddress.value = newAdminAddress
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getUserStats(userAddress: bytes) -> bytes:
getUserStats:
    // smart_contracts/staking/contract.algo.ts:457-458
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    proto 1 1
    // smart_contracts/staking/contract.algo.ts:459
    // const stakeInfo = this.getUserStakeInfo(userAddress)
    frame_dig -1
    callsub getUserStakeInfo
    // smart_contracts/staking/contract.algo.ts:460
    // const pendingRewards = this.calculatePendingRewards(userAddress)
    frame_dig -1
    callsub calculatePendingRewards
    // smart_contracts/staking/contract.algo.ts:463
    // stakeInfo.stakedAmount.native,
    dig 1
    intc_0 // 0
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:464
    // stakeInfo.firstStakeTime.native,
    dig 2
    pushint 8 // 8
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:465
    // stakeInfo.lastStakeTime.native,
    dig 3
    pushint 16 // 16
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:466
    // stakeInfo.totalRewardsEarned.native,
    dig 4
    intc_3 // 24
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:468
    // stakeInfo.rewardDebt.native,
    uncover 5
    pushint 32 // 32
    extract_uint64
    // smart_contracts/staking/contract.algo.ts:463
    // stakeInfo.stakedAmount.native,
    uncover 4
    itob
    // smart_contracts/staking/contract.algo.ts:464
    // stakeInfo.firstStakeTime.native,
    uncover 4
    itob
    // smart_contracts/staking/contract.algo.ts:463-468
    // stakeInfo.stakedAmount.native,
    // stakeInfo.firstStakeTime.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // pendingRewards,
    // stakeInfo.rewardDebt.native,
    concat
    // smart_contracts/staking/contract.algo.ts:465
    // stakeInfo.lastStakeTime.native,
    uncover 3
    itob
    // smart_contracts/staking/contract.algo.ts:463-468
    // stakeInfo.stakedAmount.native,
    // stakeInfo.firstStakeTime.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // pendingRewards,
    // stakeInfo.rewardDebt.native,
    concat
    // smart_contracts/staking/contract.algo.ts:466
    // stakeInfo.totalRewardsEarned.native,
    uncover 2
    itob
    // smart_contracts/staking/contract.algo.ts:463-468
    // stakeInfo.stakedAmount.native,
    // stakeInfo.firstStakeTime.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // pendingRewards,
    // stakeInfo.rewardDebt.native,
    concat
    // smart_contracts/staking/contract.algo.ts:467
    // pendingRewards,
    uncover 2
    itob
    // smart_contracts/staking/contract.algo.ts:463-468
    // stakeInfo.stakedAmount.native,
    // stakeInfo.firstStakeTime.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // pendingRewards,
    // stakeInfo.rewardDebt.native,
    concat
    // smart_contracts/staking/contract.algo.ts:468
    // stakeInfo.rewardDebt.native,
    swap
    itob
    // smart_contracts/staking/contract.algo.ts:463-468
    // stakeInfo.stakedAmount.native,
    // stakeInfo.firstStakeTime.native,
    // stakeInfo.lastStakeTime.native,
    // stakeInfo.totalRewardsEarned.native,
    // pendingRewards,
    // stakeInfo.rewardDebt.native,
    concat
    dup
    len
    pushint 8 // 8
    /
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:471
    // return result
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.getContractStats() -> bytes:
getContractStats:
    // smart_contracts/staking/contract.algo.ts:479
    // const currentAPY = this.getCurrentAPY()
    callsub getCurrentAPY
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_2 // "totalStaked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:55
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 6 // "lastRewardTime"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:62
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 9 // "rewardPeriod"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:56
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 7 // "minimumStake"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:58
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec 4 // "accumulatedRewardsPerShare"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    uncover 6
    itob
    // smart_contracts/staking/contract.algo.ts:54
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    uncover 6
    itob
    // smart_contracts/staking/contract.algo.ts:54-484
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    // 
    // // Constants for fixed reward system - now as GlobalState for flexibility
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    // public precision = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       rewardDebt: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Update accumulated rewards per share if reward period has passed
    //  */
    // private updateRewards(): void {
    //   const currentTime = Global.latestTimestamp
    //   const lastReward = this.lastRewardTime.value
    //   const rewardPeriod = this.rewardPeriod.value
    // 
    //   // Check if a full reward period has passed
    //   if (currentTime >= lastReward + rewardPeriod && this.totalStaked.value > 0) {
    //     // Calculate how many complete periods have passed
    //     const periodsPassed: uint64 = (currentTime - lastReward) / rewardPeriod
    // 
    //     // Update accumulated rewards per share
    //     const rewardPerPeriod = this.weeklyRewards.value
    //     const totalRewards: uint64 = rewardPerPeriod * periodsPassed
    // 
    //     // Avoid overflow by calculating: (totalRewards / totalStaked) * precision
    //     const totalStaked = this.totalStaked.value
    //     const precision = this.precision.value
    //     const rewardPerShare: uint64 = (totalRewards * precision) / totalStaked
    // 
    //     this.accumulatedRewardsPerShare.value = this.accumulatedRewardsPerShare.value + rewardPerShare
    // 
    //     // Update last reward time to the most recent complete period
    //     this.lastRewardTime.value = lastReward + (periodsPassed * rewardPeriod)
    // 
    //     // Deduct rewards from pool
    //     this.rewardPool.value = this.rewardPool.value - totalRewards
    //   }
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user
    //  */
    // private calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const userStake = stakeInfo.stakedAmount.native
    //   const accRewardsPerShare = this.accumulatedRewardsPerShare.value
    //   const userRewardDebt = stakeInfo.rewardDebt.native
    //   const precision = this.precision.value
    // 
    //   // Avoid overflow: calculate total earned carefully
    //   const totalEarned: uint64 = (userStake * accRewardsPerShare) / precision
    //   const pendingRewards: uint64 = totalEarned > userRewardDebt ? totalEarned - userRewardDebt : 0
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   minimumStake: uint64,
    //   weeklyRewards: uint64,
    //   rewardPeriod: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.lastRewardTime.value = Global.latestTimestamp
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    //   this.accumulatedRewardsPerShare.value = 0
    // 
    //   // Set reward system parameters with defaults
    //   this.weeklyRewards.value = weeklyRewards
    //   this.rewardPeriod.value = rewardPeriod
    //   this.precision.value = 1_000_000 // Reduced precision from 1e12 to 1e6 to avoid overflow
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Update rewards before processing stake
    //   this.updateRewards()
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    //   const senderAddress = Txn.sender
    // 
    //   // Get the current user stake info
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Claim pending rewards if user has existing stake
    //   if (stakeInfo.stakedAmount.native > 0) {
    //     const pendingRewards = this.calculatePendingRewards(senderAddress)
    //     if (pendingRewards > 0 && this.rewardPool.value >= pendingRewards) {
    //       // Auto-compound rewards to stake
    //       stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + pendingRewards)
    //       stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //       this.totalStaked.value = this.totalStaked.value + pendingRewards
    //       this.rewardPool.value = this.rewardPool.value - pendingRewards
    //     }
    //   }
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   // Update rewards before processing withdrawal
    //   this.updateRewards()
    // 
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // Claim pending rewards
    //   const pendingRewards = this.calculatePendingRewards(senderAddress)
    //   if (pendingRewards > 0 && this.rewardPool.value >= pendingRewards) {
    //     stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //     this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //     // Transfer rewards to user
    //     const asset = this.asset.value
    //     itxn
    //       .assetTransfer({
    //         assetReceiver: senderAddress,
    //         assetAmount: pendingRewards,
    //         xferAsset: asset,
    //         fee: 1000,
    //       })
    //       .submit()
    //   }
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Claim pending rewards without changing stake
    //  */
    // @abimethod()
    // public claimRewards(): void {
    //   // Update rewards before claiming
    //   this.updateRewards()
    // 
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has stake
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    // 
    //   // Calculate pending rewards
    //   const pendingRewards = this.calculatePendingRewards(senderAddress)
    //   assert(pendingRewards > 0, 'No pending rewards')
    //   assert(this.rewardPool.value >= pendingRewards, 'Insufficient reward pool')
    // 
    //   // Update user stats
    //   stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update reward pool
    //   this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //   // Transfer rewards to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: pendingRewards,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate current APY based on total staked amount
    //  */
    // @abimethod({ readonly: true })
    // public getCurrentAPY(): uint64 {
    //   const totalStaked = this.totalStaked.value
    // 
    //   if (totalStaked === 0) {
    //     return 0 // Return 0 if no tokens staked
    //   }
    // 
    //   // Calculate annual rewards: 52 weeks * weeklyRewards
    //   const annualRewards: uint64 = 52 * this.weeklyRewards.value
    // 
    //   // APY = (annualRewards / totalStaked) * 10000 (in basis points)
    //   const apy: uint64 = (annualRewards * 10000) / totalStaked
    // 
    //   return apy
    // }
    // 
    // /**
    //  * Get pending rewards for a specific user
    //  */
    // @abimethod({ readonly: true })
    // public getPendingRewards(userAddress: Account): uint64 {
    //   return this.calculatePendingRewards(userAddress)
    // }
    // 
    // /**
    //  * Trigger reward distribution manually (admin only)
    //  * Updates accumulated rewards per share if period has passed
    //  */
    // @abimethod()
    // public triggerRewardDistribution(): void {
    //   // Ensure only admin can trigger distribution
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can trigger distribution')
    // 
    //   // Update rewards
    //   this.updateRewards()
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.rewardDebt.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const currentAPY = this.getCurrentAPY()
    // 
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     currentAPY,
    concat
    // smart_contracts/staking/contract.algo.ts:484
    // currentAPY,
    uncover 6
    itob
    // smart_contracts/staking/contract.algo.ts:54-484
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    // 
    // // Constants for fixed reward system - now as GlobalState for flexibility
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    // public precision = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       rewardDebt: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Update accumulated rewards per share if reward period has passed
    //  */
    // private updateRewards(): void {
    //   const currentTime = Global.latestTimestamp
    //   const lastReward = this.lastRewardTime.value
    //   const rewardPeriod = this.rewardPeriod.value
    // 
    //   // Check if a full reward period has passed
    //   if (currentTime >= lastReward + rewardPeriod && this.totalStaked.value > 0) {
    //     // Calculate how many complete periods have passed
    //     const periodsPassed: uint64 = (currentTime - lastReward) / rewardPeriod
    // 
    //     // Update accumulated rewards per share
    //     const rewardPerPeriod = this.weeklyRewards.value
    //     const totalRewards: uint64 = rewardPerPeriod * periodsPassed
    // 
    //     // Avoid overflow by calculating: (totalRewards / totalStaked) * precision
    //     const totalStaked = this.totalStaked.value
    //     const precision = this.precision.value
    //     const rewardPerShare: uint64 = (totalRewards * precision) / totalStaked
    // 
    //     this.accumulatedRewardsPerShare.value = this.accumulatedRewardsPerShare.value + rewardPerShare
    // 
    //     // Update last reward time to the most recent complete period
    //     this.lastRewardTime.value = lastReward + (periodsPassed * rewardPeriod)
    // 
    //     // Deduct rewards from pool
    //     this.rewardPool.value = this.rewardPool.value - totalRewards
    //   }
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user
    //  */
    // private calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const userStake = stakeInfo.stakedAmount.native
    //   const accRewardsPerShare = this.accumulatedRewardsPerShare.value
    //   const userRewardDebt = stakeInfo.rewardDebt.native
    //   const precision = this.precision.value
    // 
    //   // Avoid overflow: calculate total earned carefully
    //   const totalEarned: uint64 = (userStake * accRewardsPerShare) / precision
    //   const pendingRewards: uint64 = totalEarned > userRewardDebt ? totalEarned - userRewardDebt : 0
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   minimumStake: uint64,
    //   weeklyRewards: uint64,
    //   rewardPeriod: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.lastRewardTime.value = Global.latestTimestamp
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    //   this.accumulatedRewardsPerShare.value = 0
    // 
    //   // Set reward system parameters with defaults
    //   this.weeklyRewards.value = weeklyRewards
    //   this.rewardPeriod.value = rewardPeriod
    //   this.precision.value = 1_000_000 // Reduced precision from 1e12 to 1e6 to avoid overflow
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Update rewards before processing stake
    //   this.updateRewards()
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    //   const senderAddress = Txn.sender
    // 
    //   // Get the current user stake info
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Claim pending rewards if user has existing stake
    //   if (stakeInfo.stakedAmount.native > 0) {
    //     const pendingRewards = this.calculatePendingRewards(senderAddress)
    //     if (pendingRewards > 0 && this.rewardPool.value >= pendingRewards) {
    //       // Auto-compound rewards to stake
    //       stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + pendingRewards)
    //       stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //       this.totalStaked.value = this.totalStaked.value + pendingRewards
    //       this.rewardPool.value = this.rewardPool.value - pendingRewards
    //     }
    //   }
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   // Update rewards before processing withdrawal
    //   this.updateRewards()
    // 
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // Claim pending rewards
    //   const pendingRewards = this.calculatePendingRewards(senderAddress)
    //   if (pendingRewards > 0 && this.rewardPool.value >= pendingRewards) {
    //     stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //     this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //     // Transfer rewards to user
    //     const asset = this.asset.value
    //     itxn
    //       .assetTransfer({
    //         assetReceiver: senderAddress,
    //         assetAmount: pendingRewards,
    //         xferAsset: asset,
    //         fee: 1000,
    //       })
    //       .submit()
    //   }
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Claim pending rewards without changing stake
    //  */
    // @abimethod()
    // public claimRewards(): void {
    //   // Update rewards before claiming
    //   this.updateRewards()
    // 
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has stake
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    // 
    //   // Calculate pending rewards
    //   const pendingRewards = this.calculatePendingRewards(senderAddress)
    //   assert(pendingRewards > 0, 'No pending rewards')
    //   assert(this.rewardPool.value >= pendingRewards, 'Insufficient reward pool')
    // 
    //   // Update user stats
    //   stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update reward pool
    //   this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //   // Transfer rewards to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: pendingRewards,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate current APY based on total staked amount
    //  */
    // @abimethod({ readonly: true })
    // public getCurrentAPY(): uint64 {
    //   const totalStaked = this.totalStaked.value
    // 
    //   if (totalStaked === 0) {
    //     return 0 // Return 0 if no tokens staked
    //   }
    // 
    //   // Calculate annual rewards: 52 weeks * weeklyRewards
    //   const annualRewards: uint64 = 52 * this.weeklyRewards.value
    // 
    //   // APY = (annualRewards / totalStaked) * 10000 (in basis points)
    //   const apy: uint64 = (annualRewards * 10000) / totalStaked
    // 
    //   return apy
    // }
    // 
    // /**
    //  * Get pending rewards for a specific user
    //  */
    // @abimethod({ readonly: true })
    // public getPendingRewards(userAddress: Account): uint64 {
    //   return this.calculatePendingRewards(userAddress)
    // }
    // 
    // /**
    //  * Trigger reward distribution manually (admin only)
    //  * Updates accumulated rewards per share if period has passed
    //  */
    // @abimethod()
    // public triggerRewardDistribution(): void {
    //   // Ensure only admin can trigger distribution
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can trigger distribution')
    // 
    //   // Update rewards
    //   this.updateRewards()
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.rewardDebt.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const currentAPY = this.getCurrentAPY()
    // 
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     currentAPY,
    concat
    // smart_contracts/staking/contract.algo.ts:55
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    uncover 5
    itob
    // smart_contracts/staking/contract.algo.ts:54-484
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    // 
    // // Constants for fixed reward system - now as GlobalState for flexibility
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    // public precision = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       rewardDebt: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Update accumulated rewards per share if reward period has passed
    //  */
    // private updateRewards(): void {
    //   const currentTime = Global.latestTimestamp
    //   const lastReward = this.lastRewardTime.value
    //   const rewardPeriod = this.rewardPeriod.value
    // 
    //   // Check if a full reward period has passed
    //   if (currentTime >= lastReward + rewardPeriod && this.totalStaked.value > 0) {
    //     // Calculate how many complete periods have passed
    //     const periodsPassed: uint64 = (currentTime - lastReward) / rewardPeriod
    // 
    //     // Update accumulated rewards per share
    //     const rewardPerPeriod = this.weeklyRewards.value
    //     const totalRewards: uint64 = rewardPerPeriod * periodsPassed
    // 
    //     // Avoid overflow by calculating: (totalRewards / totalStaked) * precision
    //     const totalStaked = this.totalStaked.value
    //     const precision = this.precision.value
    //     const rewardPerShare: uint64 = (totalRewards * precision) / totalStaked
    // 
    //     this.accumulatedRewardsPerShare.value = this.accumulatedRewardsPerShare.value + rewardPerShare
    // 
    //     // Update last reward time to the most recent complete period
    //     this.lastRewardTime.value = lastReward + (periodsPassed * rewardPeriod)
    // 
    //     // Deduct rewards from pool
    //     this.rewardPool.value = this.rewardPool.value - totalRewards
    //   }
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user
    //  */
    // private calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const userStake = stakeInfo.stakedAmount.native
    //   const accRewardsPerShare = this.accumulatedRewardsPerShare.value
    //   const userRewardDebt = stakeInfo.rewardDebt.native
    //   const precision = this.precision.value
    // 
    //   // Avoid overflow: calculate total earned carefully
    //   const totalEarned: uint64 = (userStake * accRewardsPerShare) / precision
    //   const pendingRewards: uint64 = totalEarned > userRewardDebt ? totalEarned - userRewardDebt : 0
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   minimumStake: uint64,
    //   weeklyRewards: uint64,
    //   rewardPeriod: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.lastRewardTime.value = Global.latestTimestamp
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    //   this.accumulatedRewardsPerShare.value = 0
    // 
    //   // Set reward system parameters with defaults
    //   this.weeklyRewards.value = weeklyRewards
    //   this.rewardPeriod.value = rewardPeriod
    //   this.precision.value = 1_000_000 // Reduced precision from 1e12 to 1e6 to avoid overflow
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Update rewards before processing stake
    //   this.updateRewards()
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    //   const senderAddress = Txn.sender
    // 
    //   // Get the current user stake info
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Claim pending rewards if user has existing stake
    //   if (stakeInfo.stakedAmount.native > 0) {
    //     const pendingRewards = this.calculatePendingRewards(senderAddress)
    //     if (pendingRewards > 0 && this.rewardPool.value >= pendingRewards) {
    //       // Auto-compound rewards to stake
    //       stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + pendingRewards)
    //       stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //       this.totalStaked.value = this.totalStaked.value + pendingRewards
    //       this.rewardPool.value = this.rewardPool.value - pendingRewards
    //     }
    //   }
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   // Update rewards before processing withdrawal
    //   this.updateRewards()
    // 
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // Claim pending rewards
    //   const pendingRewards = this.calculatePendingRewards(senderAddress)
    //   if (pendingRewards > 0 && this.rewardPool.value >= pendingRewards) {
    //     stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //     this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //     // Transfer rewards to user
    //     const asset = this.asset.value
    //     itxn
    //       .assetTransfer({
    //         assetReceiver: senderAddress,
    //         assetAmount: pendingRewards,
    //         xferAsset: asset,
    //         fee: 1000,
    //       })
    //       .submit()
    //   }
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Claim pending rewards without changing stake
    //  */
    // @abimethod()
    // public claimRewards(): void {
    //   // Update rewards before claiming
    //   this.updateRewards()
    // 
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has stake
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    // 
    //   // Calculate pending rewards
    //   const pendingRewards = this.calculatePendingRewards(senderAddress)
    //   assert(pendingRewards > 0, 'No pending rewards')
    //   assert(this.rewardPool.value >= pendingRewards, 'Insufficient reward pool')
    // 
    //   // Update user stats
    //   stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update reward pool
    //   this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //   // Transfer rewards to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: pendingRewards,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate current APY based on total staked amount
    //  */
    // @abimethod({ readonly: true })
    // public getCurrentAPY(): uint64 {
    //   const totalStaked = this.totalStaked.value
    // 
    //   if (totalStaked === 0) {
    //     return 0 // Return 0 if no tokens staked
    //   }
    // 
    //   // Calculate annual rewards: 52 weeks * weeklyRewards
    //   const annualRewards: uint64 = 52 * this.weeklyRewards.value
    // 
    //   // APY = (annualRewards / totalStaked) * 10000 (in basis points)
    //   const apy: uint64 = (annualRewards * 10000) / totalStaked
    // 
    //   return apy
    // }
    // 
    // /**
    //  * Get pending rewards for a specific user
    //  */
    // @abimethod({ readonly: true })
    // public getPendingRewards(userAddress: Account): uint64 {
    //   return this.calculatePendingRewards(userAddress)
    // }
    // 
    // /**
    //  * Trigger reward distribution manually (admin only)
    //  * Updates accumulated rewards per share if period has passed
    //  */
    // @abimethod()
    // public triggerRewardDistribution(): void {
    //   // Ensure only admin can trigger distribution
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can trigger distribution')
    // 
    //   // Update rewards
    //   this.updateRewards()
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.rewardDebt.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const currentAPY = this.getCurrentAPY()
    // 
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     currentAPY,
    concat
    // smart_contracts/staking/contract.algo.ts:62
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    uncover 4
    itob
    // smart_contracts/staking/contract.algo.ts:54-484
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    // 
    // // Constants for fixed reward system - now as GlobalState for flexibility
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    // public precision = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       rewardDebt: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Update accumulated rewards per share if reward period has passed
    //  */
    // private updateRewards(): void {
    //   const currentTime = Global.latestTimestamp
    //   const lastReward = this.lastRewardTime.value
    //   const rewardPeriod = this.rewardPeriod.value
    // 
    //   // Check if a full reward period has passed
    //   if (currentTime >= lastReward + rewardPeriod && this.totalStaked.value > 0) {
    //     // Calculate how many complete periods have passed
    //     const periodsPassed: uint64 = (currentTime - lastReward) / rewardPeriod
    // 
    //     // Update accumulated rewards per share
    //     const rewardPerPeriod = this.weeklyRewards.value
    //     const totalRewards: uint64 = rewardPerPeriod * periodsPassed
    // 
    //     // Avoid overflow by calculating: (totalRewards / totalStaked) * precision
    //     const totalStaked = this.totalStaked.value
    //     const precision = this.precision.value
    //     const rewardPerShare: uint64 = (totalRewards * precision) / totalStaked
    // 
    //     this.accumulatedRewardsPerShare.value = this.accumulatedRewardsPerShare.value + rewardPerShare
    // 
    //     // Update last reward time to the most recent complete period
    //     this.lastRewardTime.value = lastReward + (periodsPassed * rewardPeriod)
    // 
    //     // Deduct rewards from pool
    //     this.rewardPool.value = this.rewardPool.value - totalRewards
    //   }
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user
    //  */
    // private calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const userStake = stakeInfo.stakedAmount.native
    //   const accRewardsPerShare = this.accumulatedRewardsPerShare.value
    //   const userRewardDebt = stakeInfo.rewardDebt.native
    //   const precision = this.precision.value
    // 
    //   // Avoid overflow: calculate total earned carefully
    //   const totalEarned: uint64 = (userStake * accRewardsPerShare) / precision
    //   const pendingRewards: uint64 = totalEarned > userRewardDebt ? totalEarned - userRewardDebt : 0
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   minimumStake: uint64,
    //   weeklyRewards: uint64,
    //   rewardPeriod: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.lastRewardTime.value = Global.latestTimestamp
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    //   this.accumulatedRewardsPerShare.value = 0
    // 
    //   // Set reward system parameters with defaults
    //   this.weeklyRewards.value = weeklyRewards
    //   this.rewardPeriod.value = rewardPeriod
    //   this.precision.value = 1_000_000 // Reduced precision from 1e12 to 1e6 to avoid overflow
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Update rewards before processing stake
    //   this.updateRewards()
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    //   const senderAddress = Txn.sender
    // 
    //   // Get the current user stake info
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Claim pending rewards if user has existing stake
    //   if (stakeInfo.stakedAmount.native > 0) {
    //     const pendingRewards = this.calculatePendingRewards(senderAddress)
    //     if (pendingRewards > 0 && this.rewardPool.value >= pendingRewards) {
    //       // Auto-compound rewards to stake
    //       stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + pendingRewards)
    //       stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //       this.totalStaked.value = this.totalStaked.value + pendingRewards
    //       this.rewardPool.value = this.rewardPool.value - pendingRewards
    //     }
    //   }
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   // Update rewards before processing withdrawal
    //   this.updateRewards()
    // 
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // Claim pending rewards
    //   const pendingRewards = this.calculatePendingRewards(senderAddress)
    //   if (pendingRewards > 0 && this.rewardPool.value >= pendingRewards) {
    //     stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //     this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //     // Transfer rewards to user
    //     const asset = this.asset.value
    //     itxn
    //       .assetTransfer({
    //         assetReceiver: senderAddress,
    //         assetAmount: pendingRewards,
    //         xferAsset: asset,
    //         fee: 1000,
    //       })
    //       .submit()
    //   }
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Claim pending rewards without changing stake
    //  */
    // @abimethod()
    // public claimRewards(): void {
    //   // Update rewards before claiming
    //   this.updateRewards()
    // 
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has stake
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    // 
    //   // Calculate pending rewards
    //   const pendingRewards = this.calculatePendingRewards(senderAddress)
    //   assert(pendingRewards > 0, 'No pending rewards')
    //   assert(this.rewardPool.value >= pendingRewards, 'Insufficient reward pool')
    // 
    //   // Update user stats
    //   stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update reward pool
    //   this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //   // Transfer rewards to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: pendingRewards,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate current APY based on total staked amount
    //  */
    // @abimethod({ readonly: true })
    // public getCurrentAPY(): uint64 {
    //   const totalStaked = this.totalStaked.value
    // 
    //   if (totalStaked === 0) {
    //     return 0 // Return 0 if no tokens staked
    //   }
    // 
    //   // Calculate annual rewards: 52 weeks * weeklyRewards
    //   const annualRewards: uint64 = 52 * this.weeklyRewards.value
    // 
    //   // APY = (annualRewards / totalStaked) * 10000 (in basis points)
    //   const apy: uint64 = (annualRewards * 10000) / totalStaked
    // 
    //   return apy
    // }
    // 
    // /**
    //  * Get pending rewards for a specific user
    //  */
    // @abimethod({ readonly: true })
    // public getPendingRewards(userAddress: Account): uint64 {
    //   return this.calculatePendingRewards(userAddress)
    // }
    // 
    // /**
    //  * Trigger reward distribution manually (admin only)
    //  * Updates accumulated rewards per share if period has passed
    //  */
    // @abimethod()
    // public triggerRewardDistribution(): void {
    //   // Ensure only admin can trigger distribution
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can trigger distribution')
    // 
    //   // Update rewards
    //   this.updateRewards()
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.rewardDebt.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const currentAPY = this.getCurrentAPY()
    // 
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     currentAPY,
    concat
    // smart_contracts/staking/contract.algo.ts:56
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    uncover 3
    itob
    // smart_contracts/staking/contract.algo.ts:54-484
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    // 
    // // Constants for fixed reward system - now as GlobalState for flexibility
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    // public precision = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       rewardDebt: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Update accumulated rewards per share if reward period has passed
    //  */
    // private updateRewards(): void {
    //   const currentTime = Global.latestTimestamp
    //   const lastReward = this.lastRewardTime.value
    //   const rewardPeriod = this.rewardPeriod.value
    // 
    //   // Check if a full reward period has passed
    //   if (currentTime >= lastReward + rewardPeriod && this.totalStaked.value > 0) {
    //     // Calculate how many complete periods have passed
    //     const periodsPassed: uint64 = (currentTime - lastReward) / rewardPeriod
    // 
    //     // Update accumulated rewards per share
    //     const rewardPerPeriod = this.weeklyRewards.value
    //     const totalRewards: uint64 = rewardPerPeriod * periodsPassed
    // 
    //     // Avoid overflow by calculating: (totalRewards / totalStaked) * precision
    //     const totalStaked = this.totalStaked.value
    //     const precision = this.precision.value
    //     const rewardPerShare: uint64 = (totalRewards * precision) / totalStaked
    // 
    //     this.accumulatedRewardsPerShare.value = this.accumulatedRewardsPerShare.value + rewardPerShare
    // 
    //     // Update last reward time to the most recent complete period
    //     this.lastRewardTime.value = lastReward + (periodsPassed * rewardPeriod)
    // 
    //     // Deduct rewards from pool
    //     this.rewardPool.value = this.rewardPool.value - totalRewards
    //   }
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user
    //  */
    // private calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const userStake = stakeInfo.stakedAmount.native
    //   const accRewardsPerShare = this.accumulatedRewardsPerShare.value
    //   const userRewardDebt = stakeInfo.rewardDebt.native
    //   const precision = this.precision.value
    // 
    //   // Avoid overflow: calculate total earned carefully
    //   const totalEarned: uint64 = (userStake * accRewardsPerShare) / precision
    //   const pendingRewards: uint64 = totalEarned > userRewardDebt ? totalEarned - userRewardDebt : 0
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   minimumStake: uint64,
    //   weeklyRewards: uint64,
    //   rewardPeriod: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.lastRewardTime.value = Global.latestTimestamp
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    //   this.accumulatedRewardsPerShare.value = 0
    // 
    //   // Set reward system parameters with defaults
    //   this.weeklyRewards.value = weeklyRewards
    //   this.rewardPeriod.value = rewardPeriod
    //   this.precision.value = 1_000_000 // Reduced precision from 1e12 to 1e6 to avoid overflow
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Update rewards before processing stake
    //   this.updateRewards()
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    //   const senderAddress = Txn.sender
    // 
    //   // Get the current user stake info
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Claim pending rewards if user has existing stake
    //   if (stakeInfo.stakedAmount.native > 0) {
    //     const pendingRewards = this.calculatePendingRewards(senderAddress)
    //     if (pendingRewards > 0 && this.rewardPool.value >= pendingRewards) {
    //       // Auto-compound rewards to stake
    //       stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + pendingRewards)
    //       stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //       this.totalStaked.value = this.totalStaked.value + pendingRewards
    //       this.rewardPool.value = this.rewardPool.value - pendingRewards
    //     }
    //   }
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   // Update rewards before processing withdrawal
    //   this.updateRewards()
    // 
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // Claim pending rewards
    //   const pendingRewards = this.calculatePendingRewards(senderAddress)
    //   if (pendingRewards > 0 && this.rewardPool.value >= pendingRewards) {
    //     stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //     this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //     // Transfer rewards to user
    //     const asset = this.asset.value
    //     itxn
    //       .assetTransfer({
    //         assetReceiver: senderAddress,
    //         assetAmount: pendingRewards,
    //         xferAsset: asset,
    //         fee: 1000,
    //       })
    //       .submit()
    //   }
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Claim pending rewards without changing stake
    //  */
    // @abimethod()
    // public claimRewards(): void {
    //   // Update rewards before claiming
    //   this.updateRewards()
    // 
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has stake
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    // 
    //   // Calculate pending rewards
    //   const pendingRewards = this.calculatePendingRewards(senderAddress)
    //   assert(pendingRewards > 0, 'No pending rewards')
    //   assert(this.rewardPool.value >= pendingRewards, 'Insufficient reward pool')
    // 
    //   // Update user stats
    //   stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update reward pool
    //   this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //   // Transfer rewards to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: pendingRewards,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate current APY based on total staked amount
    //  */
    // @abimethod({ readonly: true })
    // public getCurrentAPY(): uint64 {
    //   const totalStaked = this.totalStaked.value
    // 
    //   if (totalStaked === 0) {
    //     return 0 // Return 0 if no tokens staked
    //   }
    // 
    //   // Calculate annual rewards: 52 weeks * weeklyRewards
    //   const annualRewards: uint64 = 52 * this.weeklyRewards.value
    // 
    //   // APY = (annualRewards / totalStaked) * 10000 (in basis points)
    //   const apy: uint64 = (annualRewards * 10000) / totalStaked
    // 
    //   return apy
    // }
    // 
    // /**
    //  * Get pending rewards for a specific user
    //  */
    // @abimethod({ readonly: true })
    // public getPendingRewards(userAddress: Account): uint64 {
    //   return this.calculatePendingRewards(userAddress)
    // }
    // 
    // /**
    //  * Trigger reward distribution manually (admin only)
    //  * Updates accumulated rewards per share if period has passed
    //  */
    // @abimethod()
    // public triggerRewardDistribution(): void {
    //   // Ensure only admin can trigger distribution
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can trigger distribution')
    // 
    //   // Update rewards
    //   this.updateRewards()
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.rewardDebt.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const currentAPY = this.getCurrentAPY()
    // 
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     currentAPY,
    concat
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    uncover 2
    itob
    // smart_contracts/staking/contract.algo.ts:54-484
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    // 
    // // Constants for fixed reward system - now as GlobalState for flexibility
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    // public precision = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       rewardDebt: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Update accumulated rewards per share if reward period has passed
    //  */
    // private updateRewards(): void {
    //   const currentTime = Global.latestTimestamp
    //   const lastReward = this.lastRewardTime.value
    //   const rewardPeriod = this.rewardPeriod.value
    // 
    //   // Check if a full reward period has passed
    //   if (currentTime >= lastReward + rewardPeriod && this.totalStaked.value > 0) {
    //     // Calculate how many complete periods have passed
    //     const periodsPassed: uint64 = (currentTime - lastReward) / rewardPeriod
    // 
    //     // Update accumulated rewards per share
    //     const rewardPerPeriod = this.weeklyRewards.value
    //     const totalRewards: uint64 = rewardPerPeriod * periodsPassed
    // 
    //     // Avoid overflow by calculating: (totalRewards / totalStaked) * precision
    //     const totalStaked = this.totalStaked.value
    //     const precision = this.precision.value
    //     const rewardPerShare: uint64 = (totalRewards * precision) / totalStaked
    // 
    //     this.accumulatedRewardsPerShare.value = this.accumulatedRewardsPerShare.value + rewardPerShare
    // 
    //     // Update last reward time to the most recent complete period
    //     this.lastRewardTime.value = lastReward + (periodsPassed * rewardPeriod)
    // 
    //     // Deduct rewards from pool
    //     this.rewardPool.value = this.rewardPool.value - totalRewards
    //   }
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user
    //  */
    // private calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const userStake = stakeInfo.stakedAmount.native
    //   const accRewardsPerShare = this.accumulatedRewardsPerShare.value
    //   const userRewardDebt = stakeInfo.rewardDebt.native
    //   const precision = this.precision.value
    // 
    //   // Avoid overflow: calculate total earned carefully
    //   const totalEarned: uint64 = (userStake * accRewardsPerShare) / precision
    //   const pendingRewards: uint64 = totalEarned > userRewardDebt ? totalEarned - userRewardDebt : 0
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   minimumStake: uint64,
    //   weeklyRewards: uint64,
    //   rewardPeriod: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.lastRewardTime.value = Global.latestTimestamp
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    //   this.accumulatedRewardsPerShare.value = 0
    // 
    //   // Set reward system parameters with defaults
    //   this.weeklyRewards.value = weeklyRewards
    //   this.rewardPeriod.value = rewardPeriod
    //   this.precision.value = 1_000_000 // Reduced precision from 1e12 to 1e6 to avoid overflow
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Update rewards before processing stake
    //   this.updateRewards()
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    //   const senderAddress = Txn.sender
    // 
    //   // Get the current user stake info
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Claim pending rewards if user has existing stake
    //   if (stakeInfo.stakedAmount.native > 0) {
    //     const pendingRewards = this.calculatePendingRewards(senderAddress)
    //     if (pendingRewards > 0 && this.rewardPool.value >= pendingRewards) {
    //       // Auto-compound rewards to stake
    //       stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + pendingRewards)
    //       stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //       this.totalStaked.value = this.totalStaked.value + pendingRewards
    //       this.rewardPool.value = this.rewardPool.value - pendingRewards
    //     }
    //   }
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   // Update rewards before processing withdrawal
    //   this.updateRewards()
    // 
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // Claim pending rewards
    //   const pendingRewards = this.calculatePendingRewards(senderAddress)
    //   if (pendingRewards > 0 && this.rewardPool.value >= pendingRewards) {
    //     stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //     this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //     // Transfer rewards to user
    //     const asset = this.asset.value
    //     itxn
    //       .assetTransfer({
    //         assetReceiver: senderAddress,
    //         assetAmount: pendingRewards,
    //         xferAsset: asset,
    //         fee: 1000,
    //       })
    //       .submit()
    //   }
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Claim pending rewards without changing stake
    //  */
    // @abimethod()
    // public claimRewards(): void {
    //   // Update rewards before claiming
    //   this.updateRewards()
    // 
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has stake
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    // 
    //   // Calculate pending rewards
    //   const pendingRewards = this.calculatePendingRewards(senderAddress)
    //   assert(pendingRewards > 0, 'No pending rewards')
    //   assert(this.rewardPool.value >= pendingRewards, 'Insufficient reward pool')
    // 
    //   // Update user stats
    //   stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update reward pool
    //   this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //   // Transfer rewards to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: pendingRewards,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate current APY based on total staked amount
    //  */
    // @abimethod({ readonly: true })
    // public getCurrentAPY(): uint64 {
    //   const totalStaked = this.totalStaked.value
    // 
    //   if (totalStaked === 0) {
    //     return 0 // Return 0 if no tokens staked
    //   }
    // 
    //   // Calculate annual rewards: 52 weeks * weeklyRewards
    //   const annualRewards: uint64 = 52 * this.weeklyRewards.value
    // 
    //   // APY = (annualRewards / totalStaked) * 10000 (in basis points)
    //   const apy: uint64 = (annualRewards * 10000) / totalStaked
    // 
    //   return apy
    // }
    // 
    // /**
    //  * Get pending rewards for a specific user
    //  */
    // @abimethod({ readonly: true })
    // public getPendingRewards(userAddress: Account): uint64 {
    //   return this.calculatePendingRewards(userAddress)
    // }
    // 
    // /**
    //  * Trigger reward distribution manually (admin only)
    //  * Updates accumulated rewards per share if period has passed
    //  */
    // @abimethod()
    // public triggerRewardDistribution(): void {
    //   // Ensure only admin can trigger distribution
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can trigger distribution')
    // 
    //   // Update rewards
    //   this.updateRewards()
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.rewardDebt.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const currentAPY = this.getCurrentAPY()
    // 
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     currentAPY,
    concat
    // smart_contracts/staking/contract.algo.ts:58
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    swap
    itob
    // smart_contracts/staking/contract.algo.ts:54-484
    // public totalStaked = GlobalState<uint64>({ initialValue: 0 })
    // public lastRewardTime = GlobalState<uint64>({ initialValue: 0 })
    // public minimumStake = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    // public accumulatedRewardsPerShare = GlobalState<uint64>({ initialValue: 0 })
    // 
    // // Constants for fixed reward system - now as GlobalState for flexibility
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    // public precision = GlobalState<uint64>({ initialValue: 0 })
    // 
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    // 
    // /**
    //  * Helper function to read user stake info from box storage
    //  */
    // public getUserStakeInfo(userAddress: Account): UserStakeInfo {
    //   const userBox = this.stakers(userAddress)
    // 
    //   if (userBox.exists) {
    //     return userBox.value.copy()
    //   } else {
    //     return new UserStakeInfo({
    //       stakedAmount: new arc4.UintN64(0),
    //       firstStakeTime: new arc4.UintN64(0),
    //       lastStakeTime: new arc4.UintN64(0),
    //       totalRewardsEarned: new arc4.UintN64(0),
    //       rewardDebt: new arc4.UintN64(0),
    //     })
    //   }
    // }
    // 
    // /**
    //  * Helper function to store user stake info in box storage
    //  */
    // public storeUserStakeInfo(userAddress: Account, stakeInfo: UserStakeInfo): void {
    //   this.stakers(userAddress).value = stakeInfo.copy()
    // }
    // 
    // /**
    //  * Update accumulated rewards per share if reward period has passed
    //  */
    // private updateRewards(): void {
    //   const currentTime = Global.latestTimestamp
    //   const lastReward = this.lastRewardTime.value
    //   const rewardPeriod = this.rewardPeriod.value
    // 
    //   // Check if a full reward period has passed
    //   if (currentTime >= lastReward + rewardPeriod && this.totalStaked.value > 0) {
    //     // Calculate how many complete periods have passed
    //     const periodsPassed: uint64 = (currentTime - lastReward) / rewardPeriod
    // 
    //     // Update accumulated rewards per share
    //     const rewardPerPeriod = this.weeklyRewards.value
    //     const totalRewards: uint64 = rewardPerPeriod * periodsPassed
    // 
    //     // Avoid overflow by calculating: (totalRewards / totalStaked) * precision
    //     const totalStaked = this.totalStaked.value
    //     const precision = this.precision.value
    //     const rewardPerShare: uint64 = (totalRewards * precision) / totalStaked
    // 
    //     this.accumulatedRewardsPerShare.value = this.accumulatedRewardsPerShare.value + rewardPerShare
    // 
    //     // Update last reward time to the most recent complete period
    //     this.lastRewardTime.value = lastReward + (periodsPassed * rewardPeriod)
    // 
    //     // Deduct rewards from pool
    //     this.rewardPool.value = this.rewardPool.value - totalRewards
    //   }
    // }
    // 
    // /**
    //  * Calculate pending rewards for a user
    //  */
    // private calculatePendingRewards(userAddress: Account): uint64 {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    // 
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     return 0
    //   }
    // 
    //   const userStake = stakeInfo.stakedAmount.native
    //   const accRewardsPerShare = this.accumulatedRewardsPerShare.value
    //   const userRewardDebt = stakeInfo.rewardDebt.native
    //   const precision = this.precision.value
    // 
    //   // Avoid overflow: calculate total earned carefully
    //   const totalEarned: uint64 = (userStake * accRewardsPerShare) / precision
    //   const pendingRewards: uint64 = totalEarned > userRewardDebt ? totalEarned - userRewardDebt : 0
    // 
    //   return pendingRewards
    // }
    // 
    // /**
    //  * Initialize the contract with the ASA token ID and other parameters
    //  */
    // @abimethod()
    // public initialize(
    //   asset: Asset,
    //   adminAddress: Account,
    //   minimumStake: uint64,
    //   weeklyRewards: uint64,
    //   rewardPeriod: uint64,
    // ): void {
    //   // Ensure this is only called during contract creation
    //   assert(this.asset.value === Asset(), 'Already initialized')
    // 
    //   // Ensure only the creator can initialize
    //   assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    // 
    //   // Store the initial parameters
    //   this.asset.value = asset
    //   this.adminAddress.value = adminAddress
    //   this.totalStaked.value = 0
    //   this.lastRewardTime.value = Global.latestTimestamp
    //   this.minimumStake.value = minimumStake
    //   this.rewardPool.value = 0
    //   this.accumulatedRewardsPerShare.value = 0
    // 
    //   // Set reward system parameters with defaults
    //   this.weeklyRewards.value = weeklyRewards
    //   this.rewardPeriod.value = rewardPeriod
    //   this.precision.value = 1_000_000 // Reduced precision from 1e12 to 1e6 to avoid overflow
    // }
    // 
    // /**
    //  * Opt the contract into the ASA
    //  */
    // @abimethod()
    // public optInToAsset(): void {
    //   // Ensure only the creator or admin can opt in
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === Global.creatorAddress || Txn.sender === adminAddr, 'Only creator or admin can opt in')
    // 
    //   // Opt the contract into the ASA
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: Global.currentApplicationAddress,
    //       assetAmount: 0,
    //       xferAsset: asset,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Stake tokens
    //  * Requires a companion ASA transfer transaction
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public stake(): void {
    //   // Ensure the contract has opted into the ASA
    //   const asset = this.asset.value
    //   assert(this.asset.value !== Asset(), 'Contract not initialized')
    // 
    //   // Ensure this call has a companion ASA transfer transaction
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must stake non-zero amount')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Update rewards before processing stake
    //   this.updateRewards()
    // 
    //   // Get the stake amount from the transaction
    //   const stakeAmount = xferTxn.assetAmount
    //   const minimumStake = this.minimumStake.value
    //   const senderAddress = Txn.sender
    // 
    //   // Get the current user stake info
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Claim pending rewards if user has existing stake
    //   if (stakeInfo.stakedAmount.native > 0) {
    //     const pendingRewards = this.calculatePendingRewards(senderAddress)
    //     if (pendingRewards > 0 && this.rewardPool.value >= pendingRewards) {
    //       // Auto-compound rewards to stake
    //       stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + pendingRewards)
    //       stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //       this.totalStaked.value = this.totalStaked.value + pendingRewards
    //       this.rewardPool.value = this.rewardPool.value - pendingRewards
    //     }
    //   }
    // 
    //   // If this is a new stake, ensure it meets minimum
    //   if (stakeInfo.stakedAmount.native === 0) {
    //     assert(stakeAmount >= minimumStake, 'Initial stake below minimum')
    //     // Set the first stake time (this never changes after initial stake)
    //     stakeInfo.firstStakeTime = new arc4.UintN64(Global.latestTimestamp)
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native + stakeAmount)
    //   stakeInfo.lastStakeTime = new arc4.UintN64(Global.latestTimestamp)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value + stakeAmount
    // }
    // 
    // /**
    //  * Withdraw staked tokens
    //  * Automatically claims pending rewards
    //  */
    // @abimethod()
    // public withdraw(amount: uint64): void {
    //   // Update rewards before processing withdrawal
    //   this.updateRewards()
    // 
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has enough staked
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    //   assert(amount <= stakeInfo.stakedAmount.native, 'Withdrawal amount exceeds stake')
    //   assert(amount > 0, 'Withdrawal amount must be positive')
    // 
    //   // Claim pending rewards
    //   const pendingRewards = this.calculatePendingRewards(senderAddress)
    //   if (pendingRewards > 0 && this.rewardPool.value >= pendingRewards) {
    //     stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //     this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //     // Transfer rewards to user
    //     const asset = this.asset.value
    //     itxn
    //       .assetTransfer({
    //         assetReceiver: senderAddress,
    //         assetAmount: pendingRewards,
    //         xferAsset: asset,
    //         fee: 1000,
    //       })
    //       .submit()
    //   }
    // 
    //   // If withdrawing all, no need to check minimum remaining
    //   // If partial withdrawal, ensure remaining stake meets minimum
    //   if (amount < stakeInfo.stakedAmount.native) {
    //     const remainingStake: uint64 = stakeInfo.stakedAmount.native - amount
    //     const minimumStake = this.minimumStake.value
    //     assert(remainingStake >= minimumStake, 'Remaining stake would be below minimum')
    //   }
    // 
    //   // Update stake info
    //   stakeInfo.stakedAmount = new arc4.UintN64(stakeInfo.stakedAmount.native - amount)
    // 
    //   // Update reward debt
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update global state
    //   this.totalStaked.value = this.totalStaked.value - amount
    // 
    //   // Transfer tokens back to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: amount,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Claim pending rewards without changing stake
    //  */
    // @abimethod()
    // public claimRewards(): void {
    //   // Update rewards before claiming
    //   this.updateRewards()
    // 
    //   const senderAddress = Txn.sender
    //   const stakeInfo = this.getUserStakeInfo(senderAddress)
    // 
    //   // Ensure user has stake
    //   assert(stakeInfo.stakedAmount.native > 0, 'No stake found')
    // 
    //   // Calculate pending rewards
    //   const pendingRewards = this.calculatePendingRewards(senderAddress)
    //   assert(pendingRewards > 0, 'No pending rewards')
    //   assert(this.rewardPool.value >= pendingRewards, 'Insufficient reward pool')
    // 
    //   // Update user stats
    //   stakeInfo.totalRewardsEarned = new arc4.UintN64(stakeInfo.totalRewardsEarned.native + pendingRewards)
    //   stakeInfo.rewardDebt = new arc4.UintN64((stakeInfo.stakedAmount.native * this.accumulatedRewardsPerShare.value) / this.precision.value)
    // 
    //   // Store updated stake info
    //   this.storeUserStakeInfo(senderAddress, stakeInfo)
    // 
    //   // Update reward pool
    //   this.rewardPool.value = this.rewardPool.value - pendingRewards
    // 
    //   // Transfer rewards to user
    //   const asset = this.asset.value
    //   itxn
    //     .assetTransfer({
    //       assetReceiver: senderAddress,
    //       assetAmount: pendingRewards,
    //       xferAsset: asset,
    //       fee: 1000,
    //     })
    //     .submit()
    // }
    // 
    // /**
    //  * Add rewards to the reward pool
    //  * Only the admin can call this
    //  * Requires a companion ASA transfer transaction with the rewards
    //  */
    // @abimethod()
    // public addRewards(): void {
    //   // Ensure only admin can add rewards
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can add rewards')
    // 
    //   // Ensure this call has a companion ASA transfer transaction with rewards
    //   assert(Global.groupSize === 2, 'Expected 2 txns in group')
    // 
    //   // Get the ASA transfer details
    //   const asset = this.asset.value
    //   const xferTxn = gtxn.AssetTransferTxn(0)
    //   assert(xferTxn.type === TransactionType.AssetTransfer, 'Transaction 0 must be asset transfer')
    //   assert(xferTxn.assetReceiver === Global.currentApplicationAddress, 'Asset transfer must be to contract')
    //   assert(xferTxn.assetAmount > 0, 'Must provide non-zero rewards')
    //   assert(xferTxn.xferAsset === asset, 'Incorrect asset ID')
    // 
    //   // Add rewards to the pool
    //   this.rewardPool.value = this.rewardPool.value + xferTxn.assetAmount
    // }
    // 
    // /**
    //  * Calculate current APY based on total staked amount
    //  */
    // @abimethod({ readonly: true })
    // public getCurrentAPY(): uint64 {
    //   const totalStaked = this.totalStaked.value
    // 
    //   if (totalStaked === 0) {
    //     return 0 // Return 0 if no tokens staked
    //   }
    // 
    //   // Calculate annual rewards: 52 weeks * weeklyRewards
    //   const annualRewards: uint64 = 52 * this.weeklyRewards.value
    // 
    //   // APY = (annualRewards / totalStaked) * 10000 (in basis points)
    //   const apy: uint64 = (annualRewards * 10000) / totalStaked
    // 
    //   return apy
    // }
    // 
    // /**
    //  * Get pending rewards for a specific user
    //  */
    // @abimethod({ readonly: true })
    // public getPendingRewards(userAddress: Account): uint64 {
    //   return this.calculatePendingRewards(userAddress)
    // }
    // 
    // /**
    //  * Trigger reward distribution manually (admin only)
    //  * Updates accumulated rewards per share if period has passed
    //  */
    // @abimethod()
    // public triggerRewardDistribution(): void {
    //   // Ensure only admin can trigger distribution
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can trigger distribution')
    // 
    //   // Update rewards
    //   this.updateRewards()
    // }
    // 
    // /**
    //  * Update the admin address
    //  * Only the current admin can call this
    //  */
    // @abimethod()
    // public updateAdmin(newAdminAddress: Account): void {
    //   // Ensure only admin can update admin
    //   const adminAddr = this.adminAddress.value
    //   assert(Txn.sender === adminAddr, 'Only admin can update admin')
    // 
    //   // Update admin address
    //   this.adminAddress.value = newAdminAddress
    // }
    // 
    // /**
    //  * Get current staking statistics for a user
    //  */
    // @abimethod({ readonly: true })
    // public getUserStats(userAddress: Account): Array<uint64> {
    //   const stakeInfo = this.getUserStakeInfo(userAddress)
    //   const pendingRewards = this.calculatePendingRewards(userAddress)
    // 
    //   const result: uint64[] = [
    //     stakeInfo.stakedAmount.native,
    //     stakeInfo.firstStakeTime.native,
    //     stakeInfo.lastStakeTime.native,
    //     stakeInfo.totalRewardsEarned.native,
    //     pendingRewards,
    //     stakeInfo.rewardDebt.native,
    //   ]
    // 
    //   return result
    // }
    // 
    // /**
    //  * Get contract global statistics
    //  */
    // @abimethod({ readonly: true })
    // public getContractStats(): Array<uint64> {
    //   const currentAPY = this.getCurrentAPY()
    // 
    //   const result: uint64[] = [
    //     this.asset.value.id,
    //     this.totalStaked.value,
    //     currentAPY,
    concat
    dup
    len
    pushint 8 // 8
    /
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/staking/contract.algo.ts:492
    // return result
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.emergencyWithdrawRewards(amount: uint64) -> void:
emergencyWithdrawRewards:
    // smart_contracts/staking/contract.algo.ts:498-499
    // @abimethod()
    // public emergencyWithdrawRewards(amount: uint64): void {
    proto 1 0
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_3 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:502
    // assert(Txn.sender === adminAddr, 'Only admin can emergency withdraw')
    txn Sender
    dig 1
    ==
    assert // Only admin can emergency withdraw
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:505
    // assert(this.rewardPool.value >= amount, 'Insufficient reward pool')
    frame_dig -1
    >=
    assert // Insufficient reward pool
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    intc_0 // 0
    bytec_0 // "rewardPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:508
    // this.rewardPool.value = this.rewardPool.value - amount
    frame_dig -1
    -
    // smart_contracts/staking/contract.algo.ts:57
    // public rewardPool = GlobalState<uint64>({ initialValue: 0 })
    bytec_0 // "rewardPool"
    // smart_contracts/staking/contract.algo.ts:508
    // this.rewardPool.value = this.rewardPool.value - amount
    swap
    app_global_put
    // smart_contracts/staking/contract.algo.ts:52
    // public asset = GlobalState<Asset>({ initialValue: Asset() })
    intc_0 // 0
    bytec_1 // "asset"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:512-519
    // itxn
    //   .assetTransfer({
    //     assetReceiver: adminAddr,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_begin
    itxn_field XferAsset
    frame_dig -1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/staking/contract.algo.ts:512-518
    // itxn
    //   .assetTransfer({
    //     assetReceiver: adminAddr,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/contract.algo.ts:517
    // fee: 1000,
    intc 4 // 1000
    itxn_field Fee
    // smart_contracts/staking/contract.algo.ts:512-519
    // itxn
    //   .assetTransfer({
    //     assetReceiver: adminAddr,
    //     assetAmount: amount,
    //     xferAsset: asset,
    //     fee: 1000,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.deleteUserBox(userAddress: bytes) -> void:
deleteUserBox:
    // smart_contracts/staking/contract.algo.ts:526-527
    // @abimethod()
    // public deleteUserBox(userAddress: Account): void {
    proto 1 0
    intc_0 // 0
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    dup
    bytec_3 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:532
    // assert(Txn.sender === boxOwner || Txn.sender === adminAddr, 'Only box owner or admin can delete box')
    txn Sender
    frame_dig -1
    ==
    bnz deleteUserBox_bool_true@2
    txn Sender
    frame_dig 1
    ==
    bz deleteUserBox_bool_false@3

deleteUserBox_bool_true@2:
    intc_1 // 1

deleteUserBox_bool_merge@4:
    // smart_contracts/staking/contract.algo.ts:532
    // assert(Txn.sender === boxOwner || Txn.sender === adminAddr, 'Only box owner or admin can delete box')
    assert // Only box owner or admin can delete box
    // smart_contracts/staking/contract.algo.ts:535
    // const stakeInfo = this.getUserStakeInfo(userAddress)
    frame_dig -1
    callsub getUserStakeInfo
    // smart_contracts/staking/contract.algo.ts:536
    // assert(stakeInfo.stakedAmount.native === 0, 'User still has active stake')
    intc_0 // 0
    extract_uint64
    !
    assert // User still has active stake
    // smart_contracts/staking/contract.algo.ts:65
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    bytec 11 // "stakers"
    // smart_contracts/staking/contract.algo.ts:539
    // const userBox = this.stakers(userAddress)
    frame_dig -1
    // smart_contracts/staking/contract.algo.ts:65
    // public stakers = BoxMap<Account, UserStakeInfo>({ keyPrefix: 'stakers' })
    concat
    // smart_contracts/staking/contract.algo.ts:539
    // const userBox = this.stakers(userAddress)
    dup
    frame_bury 0
    // smart_contracts/staking/contract.algo.ts:540
    // if (userBox.exists) {
    box_len
    bury 1
    bz deleteUserBox_after_if_else@6
    // smart_contracts/staking/contract.algo.ts:541
    // userBox.delete()
    frame_dig 0
    box_del
    pop

deleteUserBox_after_if_else@6:
    retsub

deleteUserBox_bool_false@3:
    intc_0 // 0
    b deleteUserBox_bool_merge@4


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.updateWeeklyRewards(newWeeklyRewards: uint64) -> void:
updateWeeklyRewards:
    // smart_contracts/staking/contract.algo.ts:548-549
    // @abimethod()
    // public updateWeeklyRewards(newWeeklyRewards: uint64): void {
    proto 1 0
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_3 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:552
    // assert(Txn.sender === adminAddr, 'Only admin can update weekly rewards')
    txn Sender
    ==
    assert // Only admin can update weekly rewards
    // smart_contracts/staking/contract.algo.ts:555
    // this.updateRewards()
    callsub updateRewards
    // smart_contracts/staking/contract.algo.ts:61
    // public weeklyRewards = GlobalState<uint64>({ initialValue: 0 })
    bytec 8 // "weeklyRewards"
    // smart_contracts/staking/contract.algo.ts:558
    // this.weeklyRewards.value = newWeeklyRewards
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/staking/contract.algo.ts::ASAStakingContract.updateRewardPeriod(newRewardPeriod: uint64) -> void:
updateRewardPeriod:
    // smart_contracts/staking/contract.algo.ts:564-565
    // @abimethod()
    // public updateRewardPeriod(newRewardPeriod: uint64): void {
    proto 1 0
    // smart_contracts/staking/contract.algo.ts:53
    // public adminAddress = GlobalState<Account>({ initialValue: Account()})
    intc_0 // 0
    bytec_3 // "adminAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/contract.algo.ts:568
    // assert(Txn.sender === adminAddr, 'Only admin can update reward period')
    txn Sender
    ==
    assert // Only admin can update reward period
    // smart_contracts/staking/contract.algo.ts:571
    // this.updateRewards()
    callsub updateRewards
    // smart_contracts/staking/contract.algo.ts:62
    // public rewardPeriod = GlobalState<uint64>({ initialValue: 0 })
    bytec 9 // "rewardPeriod"
    // smart_contracts/staking/contract.algo.ts:574
    // this.rewardPeriod.value = newRewardPeriod
    frame_dig -1
    app_global_put
    retsub
